"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const rhea = require("rhea");
const chai_1 = require("chai");
const index_1 = require("../lib/index");
describe("Receiver", () => {
    let mockService;
    let mockServiceListener;
    let connection;
    beforeEach((done) => {
        mockService = rhea.create_container();
        mockServiceListener = mockService.listen({ port: 0 });
        mockServiceListener.on("listening", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            connection = new index_1.Connection({
                port: mockServiceListener.address().port,
                reconnect: false,
            });
            yield connection.open();
            done();
        }));
    });
    afterEach(() => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        yield connection.close();
        mockServiceListener.close();
    }));
    it("can be opened and closed", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        const receiver = yield connection.createReceiver();
        chai_1.assert.isTrue(receiver.isOpen(), "Receiver should be open.");
        chai_1.assert.isFalse(receiver.isClosed(), "Receiver should not be closed.");
        chai_1.assert.isFalse(receiver.isItselfClosed(), "Receiver should not be fully closed.");
        yield receiver.close();
        chai_1.assert.isTrue(receiver.isClosed(), "Receiver should be closed.");
        chai_1.assert.isTrue(receiver.isItselfClosed(), "Receiver should be fully closed.");
        chai_1.assert.isFalse(receiver.isOpen(), "Receiver should not be open.");
    }));
    it(".remove() removes event listeners", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        const receiver = yield connection.createReceiver();
        receiver.on(rhea.ReceiverEvents.receiverOpen, () => {
            /** no-op */
        });
        chai_1.assert.isAtLeast(receiver.listenerCount(rhea.ReceiverEvents.receiverOpen), 1);
        receiver.remove();
        chai_1.assert.strictEqual(receiver.listenerCount(rhea.ReceiverEvents.receiverOpen), 0);
    }));
    it(".close() removes event listeners", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        const receiver = yield connection.createReceiver();
        receiver.on(rhea.ReceiverEvents.receiverOpen, () => {
            /** no-op */
        });
        chai_1.assert.isAtLeast(receiver.listenerCount(rhea.ReceiverEvents.receiverOpen), 1);
        yield receiver.close();
        chai_1.assert.strictEqual(receiver.listenerCount(rhea.ReceiverEvents.receiverOpen), 0);
    }));
    // TODO: This test fails because we first get a receiver_open event instead of
    // a receiver_close event which does get fired, but by then we have removed listeners
    // it("createReceiver() bubbles up error", async () => {
    //   const errorCondition = "amqp:connection:forced";
    //   const errorDescription = "testing error on create";
    //   mockService.on(
    //     rhea.SenderEvents.senderOpen,
    //     (context: rhea.EventContext) => {
    //       context.sender?.close({
    //         condition: errorCondition,
    //         description: errorDescription,
    //       });
    //     }
    //   );
    //   try {
    //     await connection.createReceiver();
    //     throw new Error("boo");
    //   } catch (error) {
    //     assert.exists(error, "Expected an AMQP error.");
    //     assert.strictEqual(error.condition, errorCondition);
    //     assert.strictEqual(error.description, errorDescription);
    //   }
    // });
    describe("supports events", () => {
        it("receiverError on receiver.close() is bubbled up", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const errorCondition = "amqp:connection:forced";
            const errorDescription = "testing error on close";
            mockService.on(rhea.SenderEvents.senderClose, (context) => {
                context.sender && context.sender.close({
                    condition: errorCondition,
                    description: errorDescription,
                });
            });
            const receiver = yield connection.createReceiver();
            try {
                yield receiver.close();
                throw new Error("boo");
            }
            catch (error) {
                chai_1.assert.exists(error, "Expected an AMQP error.");
                chai_1.assert.strictEqual(error.condition, errorCondition);
                chai_1.assert.strictEqual(error.description, errorDescription);
            }
        }));
    });
});
//# sourceMappingURL=receiver.spec.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const rhea = require("rhea");
const chai_1 = require("chai");
const index_1 = require("../lib/index");
const abort_controller_1 = require("@azure/abort-controller");
const utils_1 = require("../lib/util/utils");
describe("Sender", () => {
    let mockService;
    let mockServiceListener;
    let connection;
    beforeEach((done) => {
        mockService = rhea.create_container();
        mockServiceListener = mockService.listen({ port: 0 });
        mockServiceListener.on("listening", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            connection = new index_1.Connection({
                port: mockServiceListener.address().port,
                reconnect: false,
            });
            yield connection.open();
            done();
        }));
    });
    afterEach(() => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        yield connection.close();
        mockServiceListener.close();
    }));
    it("can be opened and closed", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        const sender = yield connection.createSender();
        chai_1.assert.isTrue(sender.isOpen(), "Sender should be open.");
        chai_1.assert.isFalse(sender.isClosed(), "Sender should not be closed.");
        chai_1.assert.isFalse(sender.isItselfClosed(), "Sender should not be fully closed.");
        yield sender.close();
        chai_1.assert.isTrue(sender.isClosed(), "Sender should be closed.");
        chai_1.assert.isTrue(sender.isItselfClosed(), "Sender should be fully closed.");
        chai_1.assert.isFalse(sender.isOpen(), "Sender should not be open.");
    }));
    it("Delivery returned from `AwaitableSender.send()` is not undefined", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        const sender = yield connection.createAwaitableSender();
        const response = yield sender.send({ body: "message" }, { timeoutInSeconds: 1 });
        chai_1.assert.exists(response, "Response from the AwaitableSender.send() is undefined");
        chai_1.assert.exists(response.id, "Delivery returned from the AwaitableSender.send() is undefined");
        yield sender.close();
    }));
    it(".remove() removes event listeners", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        const sender = yield connection.createSender();
        sender.on(rhea.SenderEvents.senderOpen, () => {
            /** no-op */
        });
        chai_1.assert.isAtLeast(sender.listenerCount(rhea.SenderEvents.senderOpen), 1);
        sender.remove();
        chai_1.assert.strictEqual(sender.listenerCount(rhea.SenderEvents.senderOpen), 0);
    }));
    it(".close() removes event listeners", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        const sender = yield connection.createSender();
        sender.on(rhea.SenderEvents.senderOpen, () => {
            /** no-op */
        });
        chai_1.assert.isAtLeast(sender.listenerCount(rhea.SenderEvents.senderOpen), 1);
        yield sender.close();
        chai_1.assert.strictEqual(sender.listenerCount(rhea.SenderEvents.senderOpen), 0);
    }));
    it("createSender() bubbles up error", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        const errorCondition = "amqp:connection:forced";
        const errorDescription = "testing error on create";
        mockService.on(rhea.ReceiverEvents.receiverOpen, (context) => {
            context.receiver &&
                context.receiver.close({
                    condition: errorCondition,
                    description: errorDescription,
                });
        });
        try {
            yield connection.createSender();
            throw new Error("boo");
        }
        catch (error) {
            chai_1.assert.exists(error, "Expected an AMQP error.");
            chai_1.assert.strictEqual(error.condition, errorCondition);
            chai_1.assert.strictEqual(error.description, errorDescription);
        }
    }));
    it("InsufficientCreditError", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        const connection = new index_1.Connection({
            port: mockServiceListener.address().port,
            reconnect: false,
        });
        yield connection.open();
        const sender = yield connection.createAwaitableSender();
        sender.sendable = () => {
            return false;
        };
        let insufficientCreditErrorThrown = false;
        try {
            yield sender.send({ body: "hello" });
        }
        catch (error) {
            insufficientCreditErrorThrown = error instanceof index_1.InsufficientCreditError;
        }
        chai_1.assert.isTrue(insufficientCreditErrorThrown, "AbortError should have been thrown.");
        yield connection.close();
    }));
    describe("supports events", () => {
        it("senderError on sender.close() is bubbled up", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const errorCondition = "amqp:connection:forced";
            const errorDescription = "testing error on close";
            mockService.on(rhea.ReceiverEvents.receiverClose, (context) => {
                context.receiver &&
                    context.receiver.close({
                        condition: errorCondition,
                        description: errorDescription,
                    });
            });
            const sender = yield connection.createSender();
            try {
                yield sender.close();
                throw new Error("boo");
            }
            catch (error) {
                chai_1.assert.exists(error, "Expected an AMQP error.");
                chai_1.assert.strictEqual(error.condition, errorCondition);
                chai_1.assert.strictEqual(error.description, errorDescription);
            }
        }));
    });
    describe("AbortSignal", () => {
        it("send() fails with aborted signal", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const connection = new index_1.Connection({
                port: mockServiceListener.address().port,
                reconnect: false,
            });
            yield connection.open();
            const sender = yield connection.createAwaitableSender();
            const abortController = new abort_controller_1.AbortController();
            const abortSignal = abortController.signal;
            // Pass an already aborted signal to send()
            abortController.abort();
            const sendPromise = sender.send({ body: "hello" }, {
                abortSignal,
            });
            let abortErrorThrown = false;
            try {
                yield sendPromise;
            }
            catch (error) {
                abortErrorThrown = error.name === utils_1.abortErrorName;
            }
            chai_1.assert.isTrue(abortErrorThrown, "AbortError should have been thrown.");
            yield connection.close();
        }));
        it("send() fails with aborted signal even when insufficient credits", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const connection = new index_1.Connection({
                port: mockServiceListener.address().port,
                reconnect: false,
            });
            yield connection.open();
            const sender = yield connection.createAwaitableSender();
            sender.sendable = () => {
                return false;
            };
            const abortController = new abort_controller_1.AbortController();
            const abortSignal = abortController.signal;
            // Pass an already aborted signal to send()
            abortController.abort();
            const sendPromise = sender.send({ body: "hello" }, {
                abortSignal,
            });
            let abortErrorThrown = false;
            try {
                yield sendPromise;
            }
            catch (error) {
                abortErrorThrown = error.name === utils_1.abortErrorName;
            }
            chai_1.assert.isTrue(abortErrorThrown, "AbortError should have been thrown.");
            yield connection.close();
        }));
        it("send() fails when abort signal is fired", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const connection = new index_1.Connection({
                port: mockServiceListener.address().port,
                reconnect: false,
            });
            yield connection.open();
            const sender = yield connection.createAwaitableSender();
            const abortController = new abort_controller_1.AbortController();
            const abortSignal = abortController.signal;
            // Fire abort signal after passing it to send()
            const sendPromise = sender.send({ body: "hello" }, {
                abortSignal,
            });
            abortController.abort();
            let abortErrorThrown = false;
            try {
                yield sendPromise;
            }
            catch (error) {
                abortErrorThrown = error.name === utils_1.abortErrorName;
            }
            chai_1.assert.isTrue(abortErrorThrown, "AbortError should have been thrown.");
            yield connection.close();
        }));
    });
});
//# sourceMappingURL=sender.spec.js.map
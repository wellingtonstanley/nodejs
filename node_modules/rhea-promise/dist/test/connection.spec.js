"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const rhea = require("rhea");
const chai_1 = require("chai");
const index_1 = require("../lib/index");
const abort_controller_1 = require("@azure/abort-controller");
const utils_1 = require("../lib/util/utils");
describe("Connection", () => {
    let mockService;
    let mockServiceListener;
    beforeEach((done) => {
        mockService = rhea.create_container();
        mockServiceListener = mockService.listen({ port: 0 });
        mockServiceListener.on("listening", () => {
            done();
        });
    });
    afterEach(() => {
        mockServiceListener.close();
    });
    it("can be opened and closed", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        const connection = new index_1.Connection({
            port: mockServiceListener.address().port,
        });
        yield connection.open();
        chai_1.assert.isTrue(connection.isOpen(), "Connection should be open.");
        chai_1.assert.isTrue(connection.isRemoteOpen(), "Connection should be established.");
        yield connection.close();
        chai_1.assert.isFalse(connection.isRemoteOpen(), "Connection should be disconnected.");
        chai_1.assert.isFalse(connection.isOpen(), "Connection should be closed.");
    }));
    it("createSession()", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        const connection = new index_1.Connection({
            port: mockServiceListener.address().port,
        });
        yield connection.open();
        chai_1.assert.isTrue(connection.isOpen(), "Connection should be open.");
        const session = yield connection.createSession();
        chai_1.assert.isTrue(session.isOpen(), "Session should be open.");
        yield connection.close();
        chai_1.assert.isFalse(session.isOpen(), "Session should be not be open after connection closed.");
    }));
    it("createSender()", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        const connection = new index_1.Connection({
            port: mockServiceListener.address().port,
        });
        yield connection.open();
        chai_1.assert.isTrue(connection.isOpen(), "Connection should be open.");
        const sender = yield connection.createSender();
        chai_1.assert.isTrue(sender.isOpen(), "Sender should be open.");
        yield connection.close();
        chai_1.assert.isFalse(sender.isOpen(), "Sender should be not be open after connection closed.");
    }));
    it("createSender() with given session", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        const connection = new index_1.Connection({
            port: mockServiceListener.address().port,
        });
        yield connection.open();
        chai_1.assert.isTrue(connection.isOpen(), "Connection should be open.");
        const session = yield connection.createSession();
        chai_1.assert.isTrue(session.isOpen(), "Session should be open.");
        const sender = yield connection.createSender({ session });
        chai_1.assert.isTrue(sender.isOpen(), "Sender should be open.");
        chai_1.assert.equal(sender.session, session, "Session of sender should be the same as the session passed to createSender()");
        yield connection.close();
        chai_1.assert.isFalse(sender.isOpen(), "Sender should be not be open after connection closed.");
    }));
    it("createAwaitableSender()", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        const connection = new index_1.Connection({
            port: mockServiceListener.address().port,
        });
        yield connection.open();
        chai_1.assert.isTrue(connection.isOpen(), "Connection should be open.");
        const sender = yield connection.createAwaitableSender();
        chai_1.assert.isTrue(sender.isOpen(), "Sender should be open.");
        yield connection.close();
        chai_1.assert.isFalse(sender.isOpen(), "Sender should be not be open after connection closed.");
    }));
    it("createAwaitableSender() with given session", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        const connection = new index_1.Connection({
            port: mockServiceListener.address().port,
        });
        yield connection.open();
        chai_1.assert.isTrue(connection.isOpen(), "Connection should be open.");
        const session = yield connection.createSession();
        chai_1.assert.isTrue(session.isOpen(), "Session should be open.");
        const sender = yield connection.createAwaitableSender({ session });
        chai_1.assert.isTrue(sender.isOpen(), "Sender should be open.");
        chai_1.assert.equal(sender.session, session, "Session of sender should be the same as the session passed to createSender()");
        yield connection.close();
        chai_1.assert.isFalse(sender.isOpen(), "Sender should be not be open after connection closed.");
    }));
    it("createReceiver()", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        const connection = new index_1.Connection({
            port: mockServiceListener.address().port,
        });
        yield connection.open();
        chai_1.assert.isTrue(connection.isOpen(), "Connection should be open.");
        const receiver = yield connection.createReceiver();
        chai_1.assert.isTrue(receiver.isOpen(), "Receiver should be open.");
        yield connection.close();
        chai_1.assert.isFalse(receiver.isOpen(), "Receiver should be not be open after connection closed.");
    }));
    it("createReceiver() with given session", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        const connection = new index_1.Connection({
            port: mockServiceListener.address().port,
        });
        yield connection.open();
        chai_1.assert.isTrue(connection.isOpen(), "Connection should be open.");
        const session = yield connection.createSession();
        chai_1.assert.isTrue(session.isOpen(), "Session should be open.");
        const receiver = yield connection.createReceiver({ session });
        chai_1.assert.isTrue(receiver.isOpen(), "Receiver should be open.");
        chai_1.assert.equal(receiver.session, session, "Session of receiver should be the same as the session passed to createReceiver()");
        yield connection.close();
        chai_1.assert.isFalse(receiver.isOpen(), "Receiver should be not be open after connection closed.");
    }));
    it("createRequestResponseLink()", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        const connection = new index_1.Connection({
            port: mockServiceListener.address().port,
        });
        yield connection.open();
        chai_1.assert.isTrue(connection.isOpen(), "Connection should be open.");
        const requestResponseLink = yield connection.createRequestResponseLink({}, {});
        chai_1.assert.isTrue(requestResponseLink.session.isOpen(), "Session should be open.");
        chai_1.assert.isTrue(requestResponseLink.receiver.isOpen(), "Receiver should be open.");
        chai_1.assert.isTrue(requestResponseLink.sender.isOpen(), "Sender should be open.");
        yield connection.close();
        chai_1.assert.isFalse(requestResponseLink.session.isOpen(), "Session should be not be open after connection closed.");
        chai_1.assert.isFalse(requestResponseLink.receiver.isOpen(), "Receiver should be not be open after connection closed.");
        chai_1.assert.isFalse(requestResponseLink.sender.isOpen(), "Sender should be not be open after connection closed.");
    }));
    it("createRequestResponseLink() with given session", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        const connection = new index_1.Connection({
            port: mockServiceListener.address().port,
        });
        yield connection.open();
        chai_1.assert.isTrue(connection.isOpen(), "Connection should be open.");
        const session = yield connection.createSession();
        chai_1.assert.isTrue(session.isOpen(), "Session should be open.");
        const requestResponseLink = yield connection.createRequestResponseLink({}, {}, { session });
        chai_1.assert.isTrue(requestResponseLink.session.isOpen(), "Session should be open.");
        chai_1.assert.isTrue(requestResponseLink.receiver.isOpen(), "Receiver should be open.");
        chai_1.assert.isTrue(requestResponseLink.sender.isOpen(), "Sender should be open.");
        chai_1.assert.equal(requestResponseLink.session, session, "Session of requestResponseLink should be the same as the session passed to createRequestResponseLink()");
        yield connection.close();
        chai_1.assert.isFalse(requestResponseLink.session.isOpen(), "Session should be not be open after connection closed.");
        chai_1.assert.isFalse(requestResponseLink.receiver.isOpen(), "Receiver should be not be open after connection closed.");
        chai_1.assert.isFalse(requestResponseLink.sender.isOpen(), "Sender should be not be open after connection closed.");
    }));
    describe("supports events", () => {
        it("connectionOpen", (done) => {
            const connection = new index_1.Connection({
                port: mockServiceListener.address().port,
            });
            connection.on(index_1.ConnectionEvents.connectionOpen, (event) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                chai_1.assert.exists(event, "Expected an AMQP event.");
                yield connection.close();
                done();
            }));
            connection.open();
        });
        it("connectionClose", (done) => {
            const connection = new index_1.Connection({
                port: mockServiceListener.address().port,
            });
            connection.on(index_1.ConnectionEvents.connectionClose, (event) => {
                chai_1.assert.exists(event, "Expected an AMQP event.");
                done();
            });
            (function run() {
                return tslib_1.__awaiter(this, void 0, void 0, function* () {
                    yield connection.open();
                    yield connection.close();
                });
            })();
        });
        it("connectionError on connection open", (done) => {
            const errorCondition = "amqp:connection:forced";
            const errorDescription = "testing error on close";
            mockService.on(rhea.ConnectionEvents.connectionOpen, (context) => {
                context.connection.close({
                    condition: errorCondition,
                    description: errorDescription,
                });
            });
            const connection = new index_1.Connection({
                port: mockServiceListener.address().port,
                reconnect: false,
            });
            connection.on(index_1.ConnectionEvents.connectionError, (event) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                chai_1.assert.exists(event, "Expected an AMQP event.");
                const error = event.error;
                chai_1.assert.exists(error, "Expected an AMQP error.");
                chai_1.assert.strictEqual(error.condition, errorCondition);
                chai_1.assert.strictEqual(error.description, errorDescription);
                yield connection.close();
                done();
            }));
            connection.open();
        });
        it("disconnected", (done) => {
            mockService.on(rhea.ConnectionEvents.connectionOpen, (context) => {
                context.connection.close({
                    condition: "amqp:connection:forced",
                    description: "testing error on close",
                });
            });
            const connection = new index_1.Connection({
                port: mockServiceListener.address().port,
                reconnect: false,
            });
            connection.on(index_1.ConnectionEvents.disconnected, (event) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                chai_1.assert.exists(event, "Expected an AMQP event.");
                yield connection.close();
                done();
            }));
            connection.open();
        });
        it("connectionError on connection.close() is bubbled up", (done) => {
            const errorCondition = "amqp:connection:forced";
            const errorDescription = "testing error on close";
            mockService.on(rhea.ConnectionEvents.connectionClose, (context) => {
                context.connection.close({
                    condition: errorCondition,
                    description: errorDescription,
                });
            });
            const connection = new index_1.Connection({
                port: mockServiceListener.address().port,
                reconnect: false,
            });
            connection.on(index_1.ConnectionEvents.connectionOpen, (event) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                chai_1.assert.exists(event, "Expected an AMQP event.");
                try {
                    yield connection.close();
                    throw new Error("boo");
                }
                catch (error) {
                    chai_1.assert.exists(error, "Expected an AMQP error.");
                    chai_1.assert.strictEqual(error.condition, errorCondition);
                    chai_1.assert.strictEqual(error.description, errorDescription);
                }
                done();
            }));
            connection.open();
        });
    });
    describe("AbortError", () => {
        it("connection.open() fails with aborted signal", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const connection = new index_1.Connection({
                port: mockServiceListener.address().port,
                reconnect: false,
            });
            const abortController = new abort_controller_1.AbortController();
            const abortSignal = abortController.signal;
            // Pass an already aborted signal to open()
            abortController.abort();
            const connectionOpenPromise = connection.open({ abortSignal });
            let abortErrorThrown = false;
            try {
                yield connectionOpenPromise;
            }
            catch (error) {
                abortErrorThrown = error.name === utils_1.abortErrorName;
            }
            chai_1.assert.isTrue(abortErrorThrown, "AbortError should have been thrown.");
            chai_1.assert.isFalse(connection.isOpen(), "Connection should not be open.");
        }));
        it("connection.open() fails when abort signal is fired", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const connection = new index_1.Connection({
                port: mockServiceListener.address().port,
                reconnect: false,
            });
            const abortController = new abort_controller_1.AbortController();
            const abortSignal = abortController.signal;
            // Abort the signal after passing it to open()
            const connectionOpenPromise = connection.open({ abortSignal });
            abortController.abort();
            let abortErrorThrown = false;
            try {
                yield connectionOpenPromise;
            }
            catch (error) {
                abortErrorThrown = error.name === utils_1.abortErrorName;
            }
            chai_1.assert.isTrue(abortErrorThrown, "AbortError should have been thrown.");
            chai_1.assert.isFalse(connection.isOpen(), "Connection should not be open.");
        }));
        it("connection.close() fails with aborted signal", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const connection = new index_1.Connection({
                port: mockServiceListener.address().port,
                reconnect: false,
            });
            yield connection.open();
            chai_1.assert.isTrue(connection.isOpen(), "Connection should be open.");
            const abortController = new abort_controller_1.AbortController();
            const abortSignal = abortController.signal;
            // Pass an already aborted signal to close()
            abortController.abort();
            const connectionClosePromise = connection.close({ abortSignal });
            let abortErrorThrown = false;
            try {
                yield connectionClosePromise;
            }
            catch (error) {
                abortErrorThrown = error.name === utils_1.abortErrorName;
            }
            chai_1.assert.isTrue(abortErrorThrown, "AbortError should have been thrown.");
            chai_1.assert.isFalse(connection.isOpen(), "Connection should not be open.");
            chai_1.assert.isTrue(connection.isRemoteOpen(), "Connection remote endpoint should not have gotten a chance to close.");
        }));
        it("connection.close() fails when abort signal is fired", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const connection = new index_1.Connection({
                port: mockServiceListener.address().port,
                reconnect: false,
            });
            yield connection.open();
            chai_1.assert.isTrue(connection.isOpen(), "Connection should be open.");
            const abortController = new abort_controller_1.AbortController();
            const abortSignal = abortController.signal;
            // Abort the signal after passing it to open()
            const connectionClosePromise = connection.close({ abortSignal });
            abortController.abort();
            let abortErrorThrown = false;
            try {
                yield connectionClosePromise;
            }
            catch (error) {
                abortErrorThrown = error.name === utils_1.abortErrorName;
            }
            chai_1.assert.isTrue(abortErrorThrown, "AbortError should have been thrown.");
            chai_1.assert.isFalse(connection.isOpen(), "Connection should not be open.");
            chai_1.assert.isTrue(connection.isRemoteOpen(), "Connection remote endpoint should not have gotten a chance to close.");
        }));
        it("createSession() fails with aborted signal", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const connection = new index_1.Connection({
                port: mockServiceListener.address().port,
                reconnect: false,
            });
            yield connection.open();
            const abortController = new abort_controller_1.AbortController();
            const abortSignal = abortController.signal;
            // Pass an already aborted signal to createSession()
            abortController.abort();
            const createSessionPromise = connection.createSession({ abortSignal });
            let abortErrorThrown = false;
            try {
                yield createSessionPromise;
            }
            catch (error) {
                abortErrorThrown = error.name === utils_1.abortErrorName;
            }
            chai_1.assert.isTrue(abortErrorThrown, "AbortError should have been thrown.");
            const sessionMap = connection["_connection"]["local_channel_map"];
            chai_1.assert.deepEqual(sessionMap, {});
            yield connection.close();
        }));
        it("createSession() fails when abort signal is fired", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const connection = new index_1.Connection({
                port: mockServiceListener.address().port,
                reconnect: false,
            });
            yield connection.open();
            const abortController = new abort_controller_1.AbortController();
            const abortSignal = abortController.signal;
            // Abort the signal after passing it to createSession()
            const createSessionPromise = connection.createSession({ abortSignal });
            abortController.abort();
            let abortErrorThrown = false;
            try {
                yield createSessionPromise;
            }
            catch (error) {
                abortErrorThrown = error.name === utils_1.abortErrorName;
            }
            chai_1.assert.isTrue(abortErrorThrown, "AbortError should have been thrown.");
            const sessionMap = connection["_connection"]["local_channel_map"];
            // There should be at most 1 session.
            const [sessionName] = Object.keys(sessionMap);
            const session = sessionName && sessionMap[sessionName];
            if (!session.is_closed()) {
                yield new Promise(resolve => {
                    session.once(rhea.SessionEvents.sessionClose, resolve);
                });
            }
            chai_1.assert.isTrue(session.is_closed(), "Session should be closed.");
            chai_1.assert.deepEqual(sessionMap, {});
            yield connection.close();
        }));
        it("createSender() fails with aborted signal", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const connection = new index_1.Connection({
                port: mockServiceListener.address().port,
                reconnect: false,
            });
            yield connection.open();
            const abortController = new abort_controller_1.AbortController();
            const abortSignal = abortController.signal;
            // Pass an already aborted signal to createSender()
            abortController.abort();
            const createSenderPromise = connection.createSender({ abortSignal });
            let abortErrorThrown = false;
            try {
                yield createSenderPromise;
            }
            catch (error) {
                abortErrorThrown = error.name === utils_1.abortErrorName;
            }
            chai_1.assert.isTrue(abortErrorThrown, "AbortError should have been thrown.");
            yield connection.close();
        }));
        it("createSender() fails when abort signal is fired", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const connection = new index_1.Connection({
                port: mockServiceListener.address().port,
                reconnect: false,
            });
            yield connection.open();
            const abortController = new abort_controller_1.AbortController();
            const abortSignal = abortController.signal;
            // Abort the signal after passing it to createSender()
            const createSenderPromise = connection.createSender({ abortSignal });
            abortController.abort();
            let abortErrorThrown = false;
            try {
                yield createSenderPromise;
            }
            catch (error) {
                abortErrorThrown = error.name === utils_1.abortErrorName;
            }
            chai_1.assert.isTrue(abortErrorThrown, "AbortError should have been thrown.");
            yield connection.close();
        }));
        it("createAwaitableSender() fails with aborted signal", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const connection = new index_1.Connection({
                port: mockServiceListener.address().port,
                reconnect: false,
            });
            yield connection.open();
            const abortController = new abort_controller_1.AbortController();
            const abortSignal = abortController.signal;
            // Pass an already aborted signal to createAwaitableSender()
            abortController.abort();
            const createAwaitableSenderPromise = connection.createAwaitableSender({ abortSignal });
            let abortErrorThrown = false;
            try {
                yield createAwaitableSenderPromise;
            }
            catch (error) {
                abortErrorThrown = error.name === utils_1.abortErrorName;
            }
            chai_1.assert.isTrue(abortErrorThrown, "AbortError should have been thrown.");
            yield connection.close();
        }));
        it("createAwaitableSender() fails when abort signal is fired", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const connection = new index_1.Connection({
                port: mockServiceListener.address().port,
                reconnect: false,
            });
            yield connection.open();
            const abortController = new abort_controller_1.AbortController();
            const abortSignal = abortController.signal;
            // Abort the signal after passing it to createAwaitableSender()
            const createAwaitableSenderPromise = connection.createAwaitableSender({ abortSignal });
            abortController.abort();
            let abortErrorThrown = false;
            try {
                yield createAwaitableSenderPromise;
            }
            catch (error) {
                abortErrorThrown = error.name === utils_1.abortErrorName;
            }
            chai_1.assert.isTrue(abortErrorThrown, "AbortError should have been thrown.");
            yield connection.close();
        }));
        it("createReceiver() fails with aborted signal", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const connection = new index_1.Connection({
                port: mockServiceListener.address().port,
                reconnect: false,
            });
            yield connection.open();
            const abortController = new abort_controller_1.AbortController();
            const abortSignal = abortController.signal;
            // Pass an already aborted signal to createReceiver()
            abortController.abort();
            const createReceiverPromise = connection.createReceiver({ abortSignal });
            let abortErrorThrown = false;
            try {
                yield createReceiverPromise;
            }
            catch (error) {
                abortErrorThrown = error.name === utils_1.abortErrorName;
            }
            chai_1.assert.isTrue(abortErrorThrown, "AbortError should have been thrown.");
            yield connection.close();
        }));
        it("createReceiver() fails when abort signal is fired", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const connection = new index_1.Connection({
                port: mockServiceListener.address().port,
                reconnect: false,
            });
            yield connection.open();
            const abortController = new abort_controller_1.AbortController();
            const abortSignal = abortController.signal;
            // Abort the signal after passing it to createReceiver()
            const createReceiverPromise = connection.createReceiver({ abortSignal });
            abortController.abort();
            let abortErrorThrown = false;
            try {
                yield createReceiverPromise;
            }
            catch (error) {
                abortErrorThrown = error.name === utils_1.abortErrorName;
            }
            chai_1.assert.isTrue(abortErrorThrown, "AbortError should have been thrown.");
            yield connection.close();
        }));
        it("createRequestResponseLink() fails with aborted signal", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const connection = new index_1.Connection({
                port: mockServiceListener.address().port,
                reconnect: false,
            });
            yield connection.open();
            const abortController = new abort_controller_1.AbortController();
            const abortSignal = abortController.signal;
            // Pass an already aborted signal to createReceiver()
            abortController.abort();
            const createPromise = connection.createRequestResponseLink({}, {}, { abortSignal });
            let abortErrorThrown = false;
            try {
                yield createPromise;
            }
            catch (error) {
                abortErrorThrown = error.name === utils_1.abortErrorName;
            }
            chai_1.assert.isTrue(abortErrorThrown, "AbortError should have been thrown.");
            yield connection.close();
        }));
        it("createRequestResponseLink() fails when abort signal is fired", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const connection = new index_1.Connection({
                port: mockServiceListener.address().port,
                reconnect: false,
            });
            yield connection.open();
            const abortController = new abort_controller_1.AbortController();
            const abortSignal = abortController.signal;
            // Abort the signal after passing it to createReceiver()
            const createPromise = connection.createRequestResponseLink({}, {}, { abortSignal });
            abortController.abort();
            let abortErrorThrown = false;
            try {
                yield createPromise;
            }
            catch (error) {
                abortErrorThrown = error.name === utils_1.abortErrorName;
            }
            chai_1.assert.isTrue(abortErrorThrown, "AbortError should have been thrown.");
            yield connection.close();
        }));
        it("constructor sets operationTimeoutInSeconds option when passing a ConnectionOptions", () => {
            const connectionOptions = {
                operationTimeoutInSeconds: 30,
                transport: "tls",
            };
            const connection = new index_1.Connection(connectionOptions);
            chai_1.assert.equal(30, connection["options"].operationTimeoutInSeconds);
        });
        it("constructor sets operationTimeoutInSeconds option when passing a ConnectionOptions with undefined operationTimeoutInSeconds", () => {
            const connectionOptions = {
                transport: "tls",
            };
            const connection = new index_1.Connection(connectionOptions);
            chai_1.assert.equal(60, connection["options"].operationTimeoutInSeconds);
        });
        it("constructor sets operationTimeoutInSeconds option when not passing any options", () => {
            const connection = new index_1.Connection();
            chai_1.assert.equal(60, connection["options"].operationTimeoutInSeconds);
        });
        it("constructor sets operationTimeoutInSeconds option when passing a CreatedRheaConnectionOptions", () => {
            const container = new index_1.Container();
            const rheaConnection = rhea.create_connection();
            const createdRheaConnectionOptions = {
                operationTimeoutInSeconds: 20,
                rheaConnection,
                container,
            };
            const connection = new index_1.Connection(createdRheaConnectionOptions);
            chai_1.assert.equal(20, connection["options"].operationTimeoutInSeconds);
        });
        it("constructor sets operationTimeoutInSeconds option when passing a CreatedRheaConnectionOptions with undefined operationTimeoutInSeconds", () => {
            const container = new index_1.Container();
            const rheaConnection = rhea.create_connection();
            const createdRheaConnectionOptions = {
                rheaConnection,
                container,
            };
            const connection2 = new index_1.Connection(createdRheaConnectionOptions);
            chai_1.assert.equal(60, connection2["options"].operationTimeoutInSeconds);
        });
    });
});
//# sourceMappingURL=connection.spec.js.map
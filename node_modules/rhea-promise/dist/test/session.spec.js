"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const rhea = require("rhea");
const chai_1 = require("chai");
const index_1 = require("../lib/index");
const abort_controller_1 = require("@azure/abort-controller");
const utils_1 = require("../lib/util/utils");
describe("Session", () => {
    let mockService;
    let mockServiceListener;
    let connection;
    beforeEach((done) => {
        mockService = rhea.create_container();
        mockServiceListener = mockService.listen({ port: 0 });
        mockServiceListener.on("listening", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            connection = new index_1.Connection({
                port: mockServiceListener.address().port,
                reconnect: false,
            });
            yield connection.open();
            done();
        }));
    });
    afterEach(() => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        yield connection.close();
        mockServiceListener.close();
    }));
    it("can be opened and closed", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        const session = yield connection.createSession();
        chai_1.assert.isTrue(session.isOpen(), "Session should be open.");
        chai_1.assert.isFalse(session.isClosed(), "Session should not be closed.");
        chai_1.assert.isFalse(session.isItselfClosed(), "Session should not be fully closed.");
        yield session.close();
        chai_1.assert.isTrue(session.isClosed(), "Session should be closed.");
        chai_1.assert.isTrue(session.isItselfClosed(), "Session should be fully closed.");
        chai_1.assert.isFalse(session.isOpen(), "Session should not be open.");
    }));
    it(".remove() removes event listeners", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        const session = new index_1.Session(connection, connection["_connection"].create_session());
        session.on(index_1.SessionEvents.sessionOpen, () => {
            /** no-op */
        });
        chai_1.assert.isAtLeast(session.listenerCount(index_1.SessionEvents.sessionOpen), 1);
        session.remove();
        chai_1.assert.strictEqual(session.listenerCount(index_1.SessionEvents.sessionOpen), 0);
        yield session.close();
    }));
    it(".close() removes event listeners", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        const session = new index_1.Session(connection, connection["_connection"].create_session());
        session.on(index_1.SessionEvents.sessionOpen, () => {
            /** no-op */
        });
        chai_1.assert.isAtLeast(session.listenerCount(index_1.SessionEvents.sessionOpen), 1);
        yield session.close();
        chai_1.assert.strictEqual(session.listenerCount(index_1.SessionEvents.sessionOpen), 0);
    }));
    describe("supports events", () => {
        it("sessionOpen", (done) => {
            const session = new index_1.Session(connection, connection["_connection"].create_session());
            session.on(index_1.SessionEvents.sessionOpen, (event) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                chai_1.assert.exists(event, "Expected an AMQP event.");
                chai_1.assert.isTrue(session.isOpen(), "Expected session to be open.");
                chai_1.assert.isFalse(session.isClosed(), "Expected session to not be closed.");
                yield session.close();
                done();
            }));
            // Open the session.
            session.begin();
        });
        it("sessionClose", (done) => {
            const session = new index_1.Session(connection, connection["_connection"].create_session());
            session.on(index_1.SessionEvents.sessionOpen, () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                yield session.close();
            }));
            session.on(index_1.SessionEvents.sessionClose, (event) => {
                chai_1.assert.exists(event, "Expected an AMQP event.");
                done();
            });
            // Open the session.
            session.begin();
        });
        it("sessionError", (done) => {
            const errorCondition = "amqp:connection:forced";
            const errorDescription = "testing error on close";
            mockService.on(rhea.SessionEvents.sessionOpen, (context) => {
                context.session &&
                    context.session.close({
                        condition: errorCondition,
                        description: errorDescription,
                    });
            });
            const session = new index_1.Session(connection, connection["_connection"].create_session());
            session.on(index_1.SessionEvents.sessionError, (event) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                chai_1.assert.exists(event, "Expected an AMQP event.");
                chai_1.assert.exists(event.session, "Expected session to be defined on AMQP event.");
                if (event.session) {
                    const error = event.session.error;
                    chai_1.assert.exists(error, "Expected an AMQP error.");
                    chai_1.assert.strictEqual(error.condition, errorCondition);
                    chai_1.assert.strictEqual(error.description, errorDescription);
                }
                yield session.close();
                done();
            }));
            session.begin();
        });
        it("sessionError on session.close() is bubbled up", (done) => {
            const errorCondition = "amqp:connection:forced";
            const errorDescription = "testing error on close";
            mockService.on(rhea.SessionEvents.sessionClose, (context) => {
                context.session &&
                    context.session.close({
                        condition: errorCondition,
                        description: errorDescription,
                    });
            });
            const session = new index_1.Session(connection, connection["_connection"].create_session());
            session.on(index_1.SessionEvents.sessionOpen, () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                try {
                    yield session.close();
                    throw new Error("boo");
                }
                catch (error) {
                    chai_1.assert.exists(error, "Expected an AMQP error.");
                    chai_1.assert.strictEqual(error.condition, errorCondition);
                    chai_1.assert.strictEqual(error.description, errorDescription);
                }
                done();
            }));
            // Open the session.
            session.begin();
        });
    });
    describe("AbortError", () => {
        it("session.close() fails with aborted signal", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const connection = new index_1.Connection({
                port: mockServiceListener.address().port,
                reconnect: false,
            });
            yield connection.open();
            const session = yield connection.createSession();
            chai_1.assert.isTrue(session.isOpen(), "Session should be open.");
            const abortController = new abort_controller_1.AbortController();
            const abortSignal = abortController.signal;
            // Pass an already aborted signal to close()
            abortController.abort();
            const sessionClosePromise = session.close({ abortSignal });
            let abortErrorThrown = false;
            try {
                yield sessionClosePromise;
            }
            catch (error) {
                abortErrorThrown = error.name === utils_1.abortErrorName;
            }
            chai_1.assert.isTrue(abortErrorThrown, "AbortError should have been thrown.");
            chai_1.assert.isFalse(session.isOpen(), "Session should not be open.");
            chai_1.assert.isTrue(session["_session"].is_remote_open(), "Session remote endpoint should not have gotten a chance to close.");
            yield connection.close();
        }));
        it("session.close() fails when abort signal is fired", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const connection = new index_1.Connection({
                port: mockServiceListener.address().port,
                reconnect: false,
            });
            yield connection.open();
            const session = yield connection.createSession();
            chai_1.assert.isTrue(session.isOpen(), "Session should be open.");
            const abortController = new abort_controller_1.AbortController();
            const abortSignal = abortController.signal;
            // Abort the signal after passing it to open()
            const sessionClosePromise = session.close({ abortSignal });
            abortController.abort();
            let abortErrorThrown = false;
            try {
                yield sessionClosePromise;
            }
            catch (error) {
                abortErrorThrown = error.name === utils_1.abortErrorName;
            }
            chai_1.assert.isTrue(abortErrorThrown, "AbortError should have been thrown.");
            chai_1.assert.isFalse(session.isOpen(), "Session should not be open.");
            chai_1.assert.isTrue(session["_session"].is_remote_open(), "Session remote endpoint should not have gotten a chance to close.");
            yield connection.close();
        }));
        it("createSender() fails with aborted signal", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const connection = new index_1.Connection({
                port: mockServiceListener.address().port,
                reconnect: false,
            });
            yield connection.open();
            const session = yield connection.createSession();
            const abortController = new abort_controller_1.AbortController();
            const abortSignal = abortController.signal;
            // Pass an already aborted signal to createSender()
            abortController.abort();
            const createSenderPromise = session.createSender({ abortSignal });
            let abortErrorThrown = false;
            try {
                yield createSenderPromise;
            }
            catch (error) {
                abortErrorThrown = error.name === utils_1.abortErrorName;
            }
            chai_1.assert.isTrue(abortErrorThrown, "AbortError should have been thrown.");
            chai_1.assert.isUndefined(extractLink(session), "Expected the session to not have any links.");
            yield connection.close();
        }));
        it("createSender() fails when abort signal is fired", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const connection = new index_1.Connection({
                port: mockServiceListener.address().port,
                reconnect: false,
            });
            yield connection.open();
            const session = yield connection.createSession();
            const abortController = new abort_controller_1.AbortController();
            const abortSignal = abortController.signal;
            // Abort the signal after passing it to createSender()
            const createSenderPromise = session.createSender({ abortSignal });
            abortController.abort();
            const link = extractLink(session);
            let abortErrorThrown = false;
            try {
                yield createSenderPromise;
            }
            catch (error) {
                abortErrorThrown = error.name === utils_1.abortErrorName;
            }
            chai_1.assert.isTrue(abortErrorThrown, "AbortError should have been thrown.");
            chai_1.assert.isFalse(link.is_open(), "Link should not be open.");
            // Cancelling link creation should guarantee that the underlying
            // link is closed and removed from the session.
            if (!link.is_closed()) {
                yield new Promise(resolve => {
                    link.once(rhea.SenderEvents.senderClose, resolve);
                });
            }
            chai_1.assert.isTrue(link.is_closed(), "Link should be closed.");
            chai_1.assert.isUndefined(extractLink(session), "Expected the session to not have any links.");
            yield connection.close();
        }));
        it("createAwaitableSender() fails with aborted signal", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const connection = new index_1.Connection({
                port: mockServiceListener.address().port,
                reconnect: false,
            });
            yield connection.open();
            const session = yield connection.createSession();
            const abortController = new abort_controller_1.AbortController();
            const abortSignal = abortController.signal;
            // Pass an already aborted signal to createAwaitableSender()
            abortController.abort();
            const createAwaitableSenderPromise = session.createAwaitableSender({ abortSignal });
            let abortErrorThrown = false;
            try {
                yield createAwaitableSenderPromise;
            }
            catch (error) {
                abortErrorThrown = error.name === utils_1.abortErrorName;
            }
            chai_1.assert.isTrue(abortErrorThrown, "AbortError should have been thrown.");
            chai_1.assert.isUndefined(extractLink(session), "Expected the session to not have any links.");
            yield connection.close();
        }));
        it("createAwaitableSender() fails when abort signal is fired", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const connection = new index_1.Connection({
                port: mockServiceListener.address().port,
                reconnect: false,
            });
            yield connection.open();
            const session = yield connection.createSession();
            const abortController = new abort_controller_1.AbortController();
            const abortSignal = abortController.signal;
            // Abort the signal after passing it to createAwaitableSender()
            const createAwaitableSenderPromise = session.createAwaitableSender({ abortSignal });
            abortController.abort();
            const link = extractLink(session);
            let abortErrorThrown = false;
            try {
                yield createAwaitableSenderPromise;
            }
            catch (error) {
                abortErrorThrown = error.name === utils_1.abortErrorName;
            }
            chai_1.assert.isTrue(abortErrorThrown, "AbortError should have been thrown.");
            chai_1.assert.isFalse(link.is_open(), "Link should not be open.");
            // Cancelling link creation should guarantee that the underlying
            // link is closed and removed from the session.
            if (!link.is_closed()) {
                yield new Promise(resolve => {
                    link.once(rhea.SenderEvents.senderClose, resolve);
                });
            }
            chai_1.assert.isTrue(link.is_closed(), "Link should be closed.");
            chai_1.assert.isUndefined(extractLink(session), "Expected the session to not have any links.");
            yield connection.close();
        }));
        it("createReceiver() fails with aborted signal", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const connection = new index_1.Connection({
                port: mockServiceListener.address().port,
                reconnect: false,
            });
            yield connection.open();
            const session = yield connection.createSession();
            const abortController = new abort_controller_1.AbortController();
            const abortSignal = abortController.signal;
            // Pass an already aborted signal to createReceiver()
            abortController.abort();
            const createReceiverPromise = session.createReceiver({ abortSignal });
            let abortErrorThrown = false;
            try {
                yield createReceiverPromise;
            }
            catch (error) {
                abortErrorThrown = error.name === utils_1.abortErrorName;
            }
            chai_1.assert.isTrue(abortErrorThrown, "AbortError should have been thrown.");
            chai_1.assert.isUndefined(extractLink(session), "Expected the session to not have any links.");
            yield connection.close();
        }));
        it("createReceiver() fails when abort signal is fired", () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const connection = new index_1.Connection({
                port: mockServiceListener.address().port,
                reconnect: false,
            });
            yield connection.open();
            const session = yield connection.createSession();
            const abortController = new abort_controller_1.AbortController();
            const abortSignal = abortController.signal;
            // Abort the signal after passing it to createReceiver()
            const createReceiverPromise = session.createReceiver({ abortSignal });
            abortController.abort();
            const link = extractLink(session);
            let abortErrorThrown = false;
            try {
                yield createReceiverPromise;
            }
            catch (error) {
                abortErrorThrown = error.name === utils_1.abortErrorName;
            }
            chai_1.assert.isTrue(abortErrorThrown, "AbortError should have been thrown.");
            chai_1.assert.isFalse(link.is_open(), "Link should not be open.");
            // Cancelling link creation should guarantee that the underlying
            // link is closed and removed from the session.
            if (!link.is_closed()) {
                yield new Promise(resolve => {
                    link.once(rhea.ReceiverEvents.receiverClose, resolve);
                });
            }
            chai_1.assert.isTrue(link.is_closed(), "Link should be closed.");
            chai_1.assert.isUndefined(extractLink(session), "Expected the session to not have any links.");
            yield connection.close();
        }));
    });
    function extractLink(session) {
        return session["_session"].find_link(() => true);
    }
});
//# sourceMappingURL=session.spec.js.map
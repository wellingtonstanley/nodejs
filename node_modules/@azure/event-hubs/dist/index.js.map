{"version":3,"file":"index.js","sources":["../src/logger.ts","../src/partitionProcessor.ts","../src/eventPosition.ts","../src/models/public.ts","../src/dataTransformer.ts","../src/util/constants.ts","../src/eventData.ts","../src/util/retries.ts","../src/util/utils.ts","../src/util/timerLoop.ts","../src/withAuth.ts","../src/partitionReceiver.ts","../src/diagnostics/tracing.ts","../src/diagnostics/instrumentEventData.ts","../src/partitionPump.ts","../src/pumpManager.ts","../src/util/delayWithoutThrow.ts","../src/eventProcessor.ts","../src/util/connectionStringUtils.ts","../src/util/error.ts","../src/managementClient.ts","../src/util/parseEndpoint.ts","../src/eventhubConnectionConfig.ts","../src/util/runtimeInfo.ts","../src/util/typeGuards.ts","../src/connectionContext.ts","../src/loadBalancerStrategies/loadBalancingStrategy.ts","../src/loadBalancerStrategies/balancedStrategy.ts","../src/loadBalancerStrategies/greedyStrategy.ts","../src/inMemoryCheckpointStore.ts","../src/impl/partitionGate.ts","../src/loadBalancerStrategies/unbalancedStrategy.ts","../src/eventHubConsumerClient.ts","../src/eventDataBatch.ts","../src/eventHubSender.ts","../src/eventHubProducerClient.ts","../src/impl/awaitableQueue.ts","../src/util/getPromiseParts.ts","../src/batchingPartitionChannel.ts","../src/impl/partitionKeyToIdMapper.ts","../src/impl/partitionAssigner.ts","../src/eventHubBufferedProducerClient.ts","../src/eventDataAdapter.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AzureLogger, AzureLogLevel, createClientLogger, Debugger } from \"@azure/logger\";\nimport { isObjectWithProperties } from \"@azure/core-util\";\n\n/**\n * The `@azure/logger` configuration for this package.\n * This will output logs using the `azure:event-hubs` namespace prefix.\n */\nexport const logger = createClientLogger(\"event-hubs\");\n\n/**\n * Logs the error's stack trace to \"verbose\" if a stack trace is available.\n * @param error - Error containing a stack trace.\n * @internal\n */\nexport function logErrorStackTrace(error: unknown): void {\n  if (isObjectWithProperties(error, [\"stack\"])) {\n    logger.verbose(error.stack);\n  }\n}\n\n/**\n * Creates a logger that includes the connectionId, sender or receiver name, and\n * client type.\n * @internal\n */\nexport function createLogPrefix(\n  connectionId?: string,\n  type?: \"Sender\" | \"Receiver\" | \"Management\",\n  name?: string\n): string {\n  const parts: string[] = [];\n  if (connectionId) {\n    parts.push(`[${connectionId}]`);\n  }\n  if (type) {\n    parts.push(type);\n  }\n  if (name) {\n    parts.push(name);\n  }\n  return parts.join(\" \");\n}\n\n/**\n * @internal\n */\nexport type SimpleLogger = {\n  [Property in keyof AzureLogger]: Debugger[\"log\"];\n};\n\nfunction createLogFunction(\n  azureLogger: AzureLogger,\n  prefix: string,\n  level: AzureLogLevel\n): (arg: any, ...args: any[]) => void {\n  return (arg: any, ...args: any[]) =>\n    azureLogger[level](\n      ...(typeof arg === \"string\" ? [`${prefix}: ${arg}`] : [prefix, arg]),\n      ...args\n    );\n}\n\n/**\n * @internal\n */\nexport function createSimpleLogger(azureLogger: AzureLogger, prefix: string): SimpleLogger {\n  return {\n    info: createLogFunction(azureLogger, prefix, \"info\"),\n    error: createLogFunction(azureLogger, prefix, \"error\"),\n    verbose: createLogFunction(azureLogger, prefix, \"verbose\"),\n    warning: createLogFunction(azureLogger, prefix, \"warning\"),\n  };\n}\n\n/** @internal */\nexport function logObj(obj: unknown): void {\n  JSON.stringify(obj, undefined, 2);\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  BasicPartitionProperties,\n  PartitionContext,\n  SubscriptionEventHandlers,\n} from \"./eventHubConsumerClientModels\";\nimport { CheckpointStore } from \"./eventProcessor\";\nimport { CloseReason } from \"./models/public\";\nimport { LastEnqueuedEventProperties } from \"./partitionReceiver\";\nimport { ReceivedEventData } from \"./eventData\";\nimport { logger } from \"./logger\";\n\n/**\n * A checkpoint is meant to represent the last successfully processed event by the user from a particular\n * partition of a consumer group in an Event Hub instance.\n *\n * When the `updateCheckpoint()` method on the `PartitionProcessor` class is called by the user, a\n * `Checkpoint` is created internally. It is then stored in the storage solution implemented by the\n * `CheckpointManager` chosen by the user when creating an `EventProcessor`.\n *\n * Users are never expected to interact with `Checkpoint` directly. This interface exists to support the\n * internal workings of `EventProcessor` and `CheckpointManager`.\n **/\nexport interface Checkpoint {\n  /**\n   * The fully qualified Event Hubs namespace. This is likely to be similar to\n   * <yournamespace>.servicebus.windows.net\n   */\n  fullyQualifiedNamespace: string;\n  /**\n   * The event hub name\n   */\n  eventHubName: string;\n  /**\n   * The consumer group name\n   */\n  consumerGroup: string;\n  /**\n   * The identifier of the Event Hub partition\n   */\n  partitionId: string;\n  /**\n   * The sequence number of the event\n   */\n  sequenceNumber: number;\n  /**\n   * The offset of the event.\n   */\n  offset: number;\n}\n\n/**\n * The `PartitionProcessor` is responsible for processing events received from Event Hubs when using `EventProcessor`\n *\n * The EventProcessor creates a new instance of the PartitionProcessor for each partition of the event hub it starts processing. When you extend the `PartitionProcessor` in order to customize it as you see fit,\n * - Override the `processEvents()` method to add the code to process the received events. This is also a good place to update the checkpoints using the `updateCheckpoint()` method\n * - Optionally override the `processError()` method to handle any error that might have occurred when processing the events.\n * - Optionally override the `initialize()` method to implement any set up related tasks you would want to carry out before starting to receive events from the partition\n * - Optionally override the `close()` method to implement any tear down or clean up tasks you would want to carry out.\n * @internal\n */\nexport class PartitionProcessor implements PartitionContext {\n  private _lastEnqueuedEventProperties?: LastEnqueuedEventProperties;\n\n  constructor(\n    private _eventHandlers: SubscriptionEventHandlers,\n    private _checkpointStore: CheckpointStore,\n    private _context: BasicPartitionProperties & {\n      eventProcessorId: string;\n    }\n  ) {}\n\n  /**\n   * Information on the last enqueued event in the partition that is being processed.\n   * This property is updated by the `EventProcessor` if the `trackLastEnqueuedEventProperties` option is set to true\n   * when creating an instance of EventProcessor\n   * @readonly\n   */\n  public get lastEnqueuedEventProperties(): LastEnqueuedEventProperties {\n    return this._lastEnqueuedEventProperties!;\n  }\n\n  /**\n   * Information on the last enqueued event in the partition that is being processed.\n   * This property is updated by the `EventProcessor` if the `trackLastEnqueuedEventProperties` option is set to true\n   * when creating an instance of EventProcessor\n   */\n  public set lastEnqueuedEventProperties(properties: LastEnqueuedEventProperties) {\n    this._lastEnqueuedEventProperties = properties;\n  }\n\n  /**\n   * The fully qualified namespace from where the current partition is being processed. It is set by the `EventProcessor`\n   * @readonly\n   */\n  public get fullyQualifiedNamespace(): string {\n    return this._context.fullyQualifiedNamespace;\n  }\n\n  /**\n   * The name of the consumer group from where the current partition is being processed. It is set by the `EventProcessor`\n   * @readonly\n   */\n  public get consumerGroup(): string {\n    return this._context.consumerGroup!;\n  }\n\n  /**\n   * The name of the event hub to which the current partition belongs. It is set by the `EventProcessor`\n   * @readonly\n   */\n  public get eventHubName(): string {\n    return this._context.eventHubName;\n  }\n\n  /**\n   * The identifier of the Event Hub partition that is being processed. It is set by the `EventProcessor`\n   * @readonly\n   */\n  public get partitionId(): string {\n    return this._context.partitionId;\n  }\n\n  /**\n   * The unique identifier of the `EventProcessor` that has spawned the current instance of `PartitionProcessor`. This is set by the `EventProcessor`\n   */\n  public get eventProcessorId(): string {\n    return this._context.eventProcessorId;\n  }\n\n  /**\n   * This method is called when the `EventProcessor` takes ownership of a new partition and before any\n   * events are received.\n   */\n  async initialize(): Promise<void> {\n    return this._eventHandlers.processInitialize?.(this);\n  }\n\n  /**\n   * This method is called before the partition processor is closed by the EventProcessor.\n   *\n   * @param reason - The reason for closing this partition processor.\n   */\n  async close(reason: CloseReason): Promise<void> {\n    if (this._eventHandlers.processClose) {\n      await this._eventHandlers.processClose(reason, this);\n    }\n  }\n\n  /**\n   * This method is called when new events are received.\n   *\n   * This is also a good place to update checkpoints as appropriate.\n   *\n   * @param event - The received events to be processed.\n   */\n  async processEvents(events: ReceivedEventData[]): Promise<void> {\n    await this._eventHandlers.processEvents(events, this);\n  }\n\n  /**\n   * This method is called when an error occurs while receiving events from Event Hubs.\n   *\n   * @param error - The error to be processed.\n   */\n  async processError(error: Error): Promise<void> {\n    if (this._eventHandlers.processError) {\n      try {\n        await this._eventHandlers.processError(error, this);\n      } catch (err: any) {\n        logger.verbose(`Error thrown from user's processError handler : ${err}`);\n      }\n    }\n  }\n\n  /**\n   * Updates the checkpoint using the event data.\n   *\n   * A checkpoint is meant to represent the last successfully processed event by the user from a particular\n   * partition of a consumer group in an Event Hub instance.\n   *\n   * @param eventData - The event that you want to update the checkpoint with.\n   */\n  public async updateCheckpoint(eventData: ReceivedEventData): Promise<void> {\n    const checkpoint: Checkpoint = {\n      fullyQualifiedNamespace: this._context.fullyQualifiedNamespace,\n      eventHubName: this._context.eventHubName,\n      consumerGroup: this._context.consumerGroup,\n      partitionId: this._context.partitionId,\n      sequenceNumber: eventData.sequenceNumber,\n      offset: eventData.offset,\n    };\n\n    await this._checkpointStore!.updateCheckpoint(checkpoint);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { Constants, ErrorNameConditionMapper, translate } from \"@azure/core-amqp\";\nimport { isDefined, objectHasProperty } from \"@azure/core-util\";\n\n/**\n * Represents the position of an event in an Event Hub partition, typically used when calling the `subscribe()`\n * method on an `EventHubConsumerClient` to specify the position in the partition to begin receiving events from.\n *\n * To get an EventPosition representing the start or end of the stream, use the constants\n * `earliestEventPosition` and `latestEventPosition` respectively.\n *\n */\nexport interface EventPosition {\n  /**\n   * The offset of the event identified by this position.\n   * Expected to be undefined if the position is just created from a sequence number or an enqueued time.\n   *\n   * The offset is the relative position for an event in the context of the partition.\n   * The offset should not be considered a stable value.\n   * The same offset may refer to a different event as events reach the age limit for\n   * retention and are no longer visible within the partition.\n   */\n  offset?: number | \"@latest\";\n  /**\n   * Indicates if the specified offset is inclusive of the event which it identifies.\n   * This information is only relevent if the event position was identified by an offset or sequence number.\n   * Default value: `false`.\n   */\n  isInclusive?: boolean;\n  /**\n   * The enqueued time in UTC of the event identified by this position.\n   * When provided as a number this value is the number of milliseconds since the Unix Epoch.\n   * Expected to be undefined if the position is just created from a sequence number or an offset.\n   */\n  enqueuedOn?: Date | number;\n\n  /**\n   * The sequence number of the event identified by this position.\n   * Expected to be undefined if the position is just created from an offset or enqueued time.\n   */\n  sequenceNumber?: number;\n}\n\n/**\n * @internal\n * Gets the expression to be set as the filter clause when creating the receiver\n * @returns filterExpression\n */\nexport function getEventPositionFilter(eventPosition: EventPosition): string {\n  let result;\n  // order of preference\n  if (isDefined(eventPosition.offset)) {\n    result = eventPosition.isInclusive\n      ? `${Constants.offsetAnnotation} >= '${eventPosition.offset}'`\n      : `${Constants.offsetAnnotation} > '${eventPosition.offset}'`;\n  } else if (isDefined(eventPosition.sequenceNumber)) {\n    result = eventPosition.isInclusive\n      ? `${Constants.sequenceNumberAnnotation} >= '${eventPosition.sequenceNumber}'`\n      : `${Constants.sequenceNumberAnnotation} > '${eventPosition.sequenceNumber}'`;\n  } else if (isDefined(eventPosition.enqueuedOn)) {\n    const time =\n      eventPosition.enqueuedOn instanceof Date\n        ? eventPosition.enqueuedOn.getTime()\n        : eventPosition.enqueuedOn;\n    result = `${Constants.enqueuedTimeAnnotation} > '${time}'`;\n  }\n\n  if (!result) {\n    throw translate({\n      condition: ErrorNameConditionMapper.ArgumentError,\n      description: \"No starting position was set in the EventPosition.\",\n    });\n  }\n  return result;\n}\n\n/**\n * @internal\n */\nexport function isLatestPosition(eventPosition: EventPosition): boolean {\n  if (eventPosition.offset === \"@latest\") {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Gets the `EventPosition` corresponding to the location of the the first event present in the partition.\n * Pass this position to the `EventHubConsumerClient.subscribe()` method to begin receiving events from the\n * first event in the partition which has not expired due to the retention policy.\n */\nexport const earliestEventPosition: EventPosition = {\n  offset: -1,\n};\n\n/**\n * Gets the `EventPosition` corresponding to the end of the partition.\n * Pass this position to the `EventHubConsumerClient.subscribe()` method to begin receiving events from the\n * event that is enqueued right after the method call.\n * @returns EventPosition\n */\nexport const latestEventPosition: EventPosition = {\n  offset: \"@latest\",\n};\n\n/**\n * @internal\n */\nexport function validateEventPositions(\n  position: EventPosition | { [partitionId: string]: EventPosition }\n): void {\n  if (!isDefined(position)) {\n    return;\n  }\n\n  const keys = Object.keys(position);\n\n  if (!keys.length) {\n    throw new TypeError(\n      \"Invalid value for EventPosition found. Pass an object with either of offset, sequenceNumber or enqueuedOn properties set.\"\n    );\n  }\n\n  if (isEventPosition(position)) {\n    validateEventPosition(position);\n    return;\n  }\n\n  const positions = position as { [partitionId: string]: EventPosition };\n  for (let i = 0; i < keys.length; i++) {\n    if (Object.prototype.hasOwnProperty.call(positions, keys[i])) {\n      validateEventPosition(positions[keys[i]]);\n    }\n  }\n}\n\n/**\n * Determines whether a position is an EventPosition.\n * Does not validate that the position is allowed.\n * @internal\n */\nexport function isEventPosition(position: unknown): position is EventPosition {\n  if (!position) {\n    return false;\n  }\n\n  if (objectHasProperty(position, \"offset\") && isDefined(position.offset)) {\n    return true;\n  }\n\n  if (objectHasProperty(position, \"sequenceNumber\") && isDefined(position.sequenceNumber)) {\n    return true;\n  }\n\n  if (objectHasProperty(position, \"enqueuedOn\") && isDefined(position.enqueuedOn)) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction validateEventPosition(position: EventPosition): void {\n  if (!isDefined(position)) {\n    return;\n  }\n  const offsetPresent = isDefined(position.offset);\n  const sequenceNumberPresent = isDefined(position.sequenceNumber);\n  const enqueuedOnPresent = isDefined(position.enqueuedOn);\n\n  if (\n    (offsetPresent && sequenceNumberPresent) ||\n    (offsetPresent && enqueuedOnPresent) ||\n    (enqueuedOnPresent && sequenceNumberPresent)\n  ) {\n    throw new TypeError(\n      \"Invalid value for EventPosition found. Set only one of offset, sequenceNumber or enqueuedOn properties.\"\n    );\n  }\n\n  if (!offsetPresent && !enqueuedOnPresent && !sequenceNumberPresent) {\n    throw new TypeError(\n      \"Invalid value for EventPosition found. Pass an object with either of offset, sequenceNumber or enqueuedOn properties set.\"\n    );\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { RetryOptions, WebSocketOptions } from \"@azure/core-amqp\";\nimport { OperationOptions } from \"../util/operationOptions\";\n\n/**\n * The set of options to configure the behavior of `getEventHubProperties`.\n * - `abortSignal`  : An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n * - `parentSpan` : The `Span` or `SpanContext` to use as the `parent` of the span created while calling this operation.\n */\nexport interface GetEventHubPropertiesOptions extends OperationOptions {}\n\n/**\n * The set of options to configure the behavior of `getPartitionProperties`.\n * - `abortSignal`  : An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n * - `parentSpan` : The `Span` or `SpanContext` to use as the `parent` of the span created while calling this operation.\n */\nexport interface GetPartitionPropertiesOptions extends OperationOptions {}\n\n/**\n * The set of options to configure the behavior of `getPartitionIds`.\n * - `abortSignal`  : An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n * - `parentSpan` : The `Span` or `SpanContext` to use as the `parent` of the span created while calling this operation.\n */\nexport interface GetPartitionIdsOptions extends OperationOptions {}\n\n/**\n * Options to configure the `sendBatch` method on the `EventHubProducerClient`\n * when sending an array of events.\n * If `partitionId` is set, `partitionKey` must not be set and vice versa.\n *\n * - `partitionId`  : The partition this batch will be sent to.\n * - `partitionKey` : A value that is hashed to produce a partition assignment.\n * - `abortSignal`  : A signal used to cancel the send operation.\n */\nexport interface SendBatchOptions extends OperationOptions {\n  /**\n   * The partition this batch will be sent to.\n   * If this value is set then partitionKey can not be set.\n   */\n  partitionId?: string;\n  /**\n   * A value that is hashed to produce a partition assignment.\n   * It guarantees that messages with the same partitionKey end up in the same partition.\n   * Specifying this will throw an error if the producer was created using a `paritionId`.\n   */\n  partitionKey?: string;\n}\n\n/**\n * The set of options to configure the `send` operation on the `EventHubProducer`.\n * - `partitionKey` : A value that is hashed to produce a partition assignment.\n * - `abortSignal`  : A signal used to cancel the send operation.\n *\n * Example usage:\n * ```js\n * {\n *     partitionKey: 'foo'\n * }\n * ```\n *\n * @internal\n */\nexport interface SendOptions extends OperationOptions {\n  /**\n   * A value that is hashed to produce a partition assignment.\n   * It guarantees that messages with the same partitionKey end up in the same partition.\n   * Specifying this will throw an error if the producer was created using a `paritionId`.\n   */\n  partitionKey?: string;\n}\n\n/**\n * An enum representing the different reasons for an `EventHubConsumerClient` to stop processing\n * events from a partition in a consumer group of an Event Hub.\n */\nexport enum CloseReason {\n  /**\n   * Ownership of the partition was lost or transitioned to a new processor instance.\n   */\n  OwnershipLost = \"OwnershipLost\",\n  /**\n   * The EventProcessor was shutdown.\n   */\n  Shutdown = \"Shutdown\",\n}\n\n/**\n * Describes the options that can be provided while creating the EventHubClient.\n * - `userAgent`        : A string to append to the built in user agent string that is passed as a connection property\n * to the service.\n * - `webSocketOptions` : Options to configure the channelling of the AMQP connection over Web Sockets.\n *    - `websocket`     : The WebSocket constructor used to create an AMQP connection if you choose to make the connection\n * over a WebSocket.\n *    - `webSocketConstructorOptions` : Options to pass to the Websocket constructor when you choose to make the connection\n * over a WebSocket.\n * - `retryOptions`     : The retry options for all the operations on the client/producer/consumer.\n *    - `maxRetries` : The number of times the operation can be retried in case of a retryable error.\n *    - `maxRetryDelayInMs`: The maximum delay between retries. Applicable only when performing exponential retries.\n *    - `mode`: Which retry mode to apply, specified by the `RetryMode` enum. Options are `Exponential` and `Fixed`. Defaults to `Fixed`.\n *    - `retryDelayInMs`: Amount of time to wait in milliseconds before making the next attempt. When `mode` is set to `Exponential`,\n *       this is used to compute the exponentially increasing delays between retries. Default: 30000 milliseconds.\n *    - `timeoutInMs`: Amount of time in milliseconds to wait before the operation times out. This will trigger a retry if there are any\n *       retry attempts remaining. Minimum value: 60000 milliseconds.\n *\n * A simple usage can be `{ \"maxRetries\": 4 }`.\n *\n * Example usage:\n * ```js\n * {\n *     retryOptions: {\n *         maxRetries: 4\n *     }\n * }\n * ```\n */\nexport interface EventHubClientOptions {\n  /**\n   * A custom endpoint to use when connecting to the Event Hubs service.\n   * This can be useful when your network does not allow connecting to the\n   * standard Azure Event Hubs endpoint address, but does allow connecting\n   * through an intermediary.\n   *\n   * Example: \"https://my.custom.endpoint:100/\"\n   */\n  customEndpointAddress?: string;\n  /**\n   * Options to configure the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   *\n   */\n  retryOptions?: RetryOptions;\n  /**\n   * Options to configure the channelling of the AMQP connection over Web Sockets.\n   */\n  webSocketOptions?: WebSocketOptions;\n  /**\n   * Value that is appended to the built in user agent string that is passed to the Event Hubs service.\n   */\n  userAgent?: string;\n}\n\n/**\n * Describes the options that can be provided while creating the EventHubConsumerClient.\n * - `loadBalancingOptions`: Options to tune how the EventHubConsumerClient claims partitions.\n * - `userAgent`        : A string to append to the built in user agent string that is passed as a connection property\n * to the service.\n * - `webSocketOptions` : Options to configure the channelling of the AMQP connection over Web Sockets.\n *    - `websocket`     : The WebSocket constructor used to create an AMQP connection if you choose to make the connection\n * over a WebSocket.\n *    - `webSocketConstructorOptions` : Options to pass to the Websocket constructor when you choose to make the connection\n * over a WebSocket.\n * - `retryOptions`     : The retry options for all the operations on the client/producer/consumer.\n *    - `maxRetries` : The number of times the operation can be retried in case of a retryable error.\n *    - `maxRetryDelayInMs`: The maximum delay between retries. Applicable only when performing exponential retries.\n *    - `mode`: Which retry mode to apply, specified by the `RetryMode` enum. Options are `Exponential` and `Fixed`. Defaults to `Fixed`.\n *    - `retryDelayInMs`: Amount of time to wait in milliseconds before making the next attempt. When `mode` is set to `Exponential`,\n *       this is used to compute the exponentially increasing delays between retries. Default: 30000 milliseconds.\n *    - `timeoutInMs`: Amount of time in milliseconds to wait before the operation times out. This will trigger a retry if there are any\n *       retry attempts remaining. Minimum value: 60000 milliseconds.\n *\n * A simple usage can be `{ \"maxRetries\": 4 }`.\n *\n * Example usage:\n * ```js\n * {\n *     retryOptions: {\n *         maxRetries: 4\n *     }\n * }\n * ```\n */\nexport interface EventHubConsumerClientOptions extends EventHubClientOptions {\n  /**\n   * Options to tune how the EventHubConsumerClient claims partitions.\n   */\n  loadBalancingOptions?: LoadBalancingOptions;\n}\n\n/**\n * An options bag to configure load balancing settings.\n */\nexport interface LoadBalancingOptions {\n  /**\n   * Whether to apply a greedy or a more balanced approach when\n   * claiming partitions.\n   *\n   * - balanced: The `EventHubConsumerClient` will take a measured approach to\n   * requesting partition ownership when balancing work with other clients,\n   * slowly claiming partitions until a stabilized distribution is achieved.\n   *\n   * - greedy: The `EventHubConsumerClient` will attempt to claim ownership\n   * of its fair share of partitions aggressively when balancing work with\n   * other clients.\n   *\n   * This option is ignored when either:\n   *   - `CheckpointStore` is __not__ provided to the `EventHubConsumerClient`.\n   *   - `subscribe()` is called for a single partition.\n   * Default: balanced\n   */\n  strategy?: \"balanced\" | \"greedy\";\n  /**\n   * The length of time between attempts to claim partitions.\n   * Default: 10000\n   */\n  updateIntervalInMs?: number;\n  /**\n   * The length of time a partition claim is valid.\n   * Default: 60000\n   */\n  partitionOwnershipExpirationIntervalInMs?: number;\n}\n\n/**\n * Options to configure the `createBatch` method on the `EventHubProducerClient`.\n * - `partitionKey`  : A value that is hashed to produce a partition assignment.\n * - `maxSizeInBytes`: The upper limit for the size of batch.\n * - `abortSignal`   : A signal the request to cancel the send operation.\n *\n * Example usage:\n * ```js\n * {\n *     partitionKey: 'foo',\n *     maxSizeInBytes: 1024 * 1024 // 1 MB\n * }\n * ```\n */\nexport interface CreateBatchOptions extends OperationOptions {\n  /**\n   * A value that is hashed to produce a partition assignment. It guarantees that messages\n   * with the same partitionKey end up in the same partition.\n   * If this value is set then partitionId can not be set.\n   */\n  partitionKey?: string;\n  /**\n   * The partition this batch will be sent to.\n   * If this value is set then partitionKey can not be set.\n   */\n  partitionId?: string;\n  /**\n   * The upper limit for the size of batch. The `tryAdd` function will return `false` after this limit is reached.\n   */\n  maxSizeInBytes?: number;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { logErrorStackTrace, logger } from \"./logger\";\nimport { Buffer } from \"buffer\";\nimport isBuffer from \"is-buffer\";\nimport { message } from \"rhea-promise\";\n\n/**\n * The allowed AMQP message body types.\n * @internal\n */\nexport type BodyTypes = \"data\" | \"value\" | \"sequence\";\n\n/** @internal */\nexport const dataSectionTypeCode = 0x75 as const;\n/** @internal */\nexport const sequenceSectionTypeCode = 0x76 as const;\n/** @internal */\nexport const valueSectionTypeCode = 0x77 as const;\n\n/**\n * The default data transformer that will be used by the Azure SDK.\n * @internal\n */\nexport const defaultDataTransformer = {\n  /**\n   * A function that takes the body property from an EventData object\n   * and returns an encoded body (some form of AMQP type).\n   *\n   * @param body - The AMQP message body\n   * @param bodyType - The AMQP section to story the body in.\n   * @returns The encoded AMQP message body as an AMQP Data/Sequence/Value section.\n   */\n  encode(body: unknown, bodyType: BodyTypes): any {\n    let result: any;\n    // string, undefined, null, boolean, array, object, number should end up here\n    // coercing undefined to null as that will ensure that null value will be given to the\n    // customer on receive.\n    if (body === undefined) body = null;\n\n    if (bodyType === \"value\") {\n      // TODO: Expose value_section from `rhea` similar to the data_section and sequence_section.\n      // Right now there isn't a way to create a value section officially.\n      result = message.data_section(body);\n      result.typecode = valueSectionTypeCode;\n    } else if (bodyType === \"sequence\") {\n      result = message.sequence_section(body);\n    } else if (isBuffer(body) || body instanceof Uint8Array) {\n      result = message.data_section(body);\n    } else if (body === null && bodyType === \"data\") {\n      result = message.data_section(null);\n    } else {\n      try {\n        const bodyStr = JSON.stringify(body);\n        result = message.data_section(Buffer.from(bodyStr, \"utf8\"));\n      } catch (err: any) {\n        const msg =\n          `An error occurred while executing JSON.stringify() on the given body ` +\n          body +\n          `${err ? err.stack : JSON.stringify(err)}`;\n        logger.warning(\"[encode] \" + msg);\n        logErrorStackTrace(err);\n        throw new Error(msg);\n      }\n    }\n    return result;\n  },\n\n  /**\n   * A function that takes the body property from an AMQP message, which can come from either\n   * the 'data', 'value' or 'sequence' sections of an AMQP message.\n   *\n   * If the body is not a JSON string the the raw contents will be returned, along with the bodyType\n   * indicating which part of the AMQP message the body was decoded from.\n   *\n   * @param body - The AMQP message body as received from rhea.\n   * @param skipParsingBodyAsJson - Boolean to skip running JSON.parse() on message body when body type is `content`.\n   * @returns The decoded/raw body and the body type.\n   */\n  decode(\n    body: unknown | RheaAmqpSection,\n    skipParsingBodyAsJson: boolean\n  ): { body: unknown; bodyType: BodyTypes } {\n    try {\n      if (isRheaAmqpSection(body)) {\n        switch (body.typecode) {\n          case dataSectionTypeCode:\n            return {\n              body: skipParsingBodyAsJson ? body.content : tryToJsonDecode(body.content),\n              bodyType: \"data\",\n            };\n          case sequenceSectionTypeCode:\n            return { body: body.content, bodyType: \"sequence\" };\n          case valueSectionTypeCode:\n            return { body: body.content, bodyType: \"value\" };\n        }\n      } else {\n        if (isBuffer(body)) {\n          return { body: skipParsingBodyAsJson ? body : tryToJsonDecode(body), bodyType: \"data\" };\n        }\n\n        return { body, bodyType: \"value\" };\n      }\n    } catch (err: any) {\n      logger.verbose(\n        \"[decode] An error occurred while decoding the received message body. The error is: %O\",\n        err\n      );\n      throw err;\n    }\n  },\n};\n\n/**\n * Attempts to decode 'body' as a JSON string. If it fails it returns body\n * verbatim.\n *\n * @param body - An AMQP message body.\n * @returns A JSON decoded object, or body if body was not a JSON string.\n *\n * @internal\n */\nfunction tryToJsonDecode(body: unknown): unknown {\n  let processedBody: any = body;\n  try {\n    // Trying to stringify and JSON.parse() anything else will fail flat and we shall return\n    // the original type back\n    const bodyStr: string = processedBody.toString(\"utf8\");\n    processedBody = JSON.parse(bodyStr);\n  } catch (err: any) {\n    logger.verbose(\n      \"[decode] An error occurred while trying JSON.parse() on the received body. The error is %O\",\n      err\n    );\n  }\n  return processedBody;\n}\n\n/**\n * Mirror of the internal Section interface in rhea.\n *\n * @internal\n */\nexport interface RheaAmqpSection {\n  typecode:\n    | typeof dataSectionTypeCode\n    | typeof sequenceSectionTypeCode\n    | typeof valueSectionTypeCode;\n  content: any;\n}\n\n/** @internal */\nexport function isRheaAmqpSection(\n  possibleSection: any | RheaAmqpSection\n): possibleSection is RheaAmqpSection {\n  return (\n    possibleSection != null &&\n    typeof possibleSection.typecode === \"number\" &&\n    (possibleSection.typecode === dataSectionTypeCode ||\n      possibleSection.typecode === valueSectionTypeCode ||\n      possibleSection.typecode === sequenceSectionTypeCode)\n  );\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/**\n * @internal\n */\nexport const packageJsonInfo = {\n  name: \"@azure/event-hubs\",\n  version: \"5.10.0\",\n};\n\n/**\n * @internal\n */\nexport const idempotentProducerAmqpPropertyNames = {\n  capability: \"com.microsoft:idempotent-producer\",\n  epoch: \"com.microsoft:producer-epoch\",\n  producerId: \"com.microsoft:producer-id\",\n  producerSequenceNumber: \"com.microsoft:producer-sequence-number\",\n} as const;\n\n/**\n * @internal\n */\nexport const PENDING_PUBLISH_SEQ_NUM_SYMBOL = Symbol.for(\n  \"@azure/event-hubs.pendingPublishSequenceNumber\"\n);\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AmqpAnnotatedMessage, Constants } from \"@azure/core-amqp\";\nimport { BodyTypes, defaultDataTransformer } from \"./dataTransformer\";\nimport {\n  DeliveryAnnotations,\n  MessageAnnotations,\n  Message as RheaMessage,\n  types,\n} from \"rhea-promise\";\nimport { isDefined, isObjectWithProperties, objectHasProperty } from \"@azure/core-util\";\nimport {\n  idempotentProducerAmqpPropertyNames,\n  PENDING_PUBLISH_SEQ_NUM_SYMBOL,\n} from \"./util/constants\";\n\n/**\n * Describes the delivery annotations.\n * @internal\n */\nexport interface EventHubDeliveryAnnotations extends DeliveryAnnotations {\n  /**\n   * The offset of the last event.\n   */\n  last_enqueued_offset?: string;\n  /**\n   * The sequence number of the last event.\n   */\n  last_enqueued_sequence_number?: number;\n  /**\n   * The enqueued time of the last event.\n   */\n  last_enqueued_time_utc?: number;\n  /**\n   * The retrieval time of the last event.\n   */\n  runtime_info_retrieval_time_utc?: number;\n  /**\n   * Any unknown delivery annotations.\n   */\n  [x: string]: any;\n}\n\n/**\n * Map containing message attributes that will be held in the message header.\n * @internal\n */\nexport interface EventHubMessageAnnotations extends MessageAnnotations {\n  /**\n   * Annotation for the partition key set for the event.\n   */\n  \"x-opt-partition-key\"?: string | null;\n  /**\n   * Annontation for the sequence number of the event.\n   */\n  \"x-opt-sequence-number\"?: number;\n  /**\n   * Annotation for the enqueued time of the event.\n   */\n  \"x-opt-enqueued-time\"?: number;\n  /**\n   * Annotation for the offset of the event.\n   */\n  \"x-opt-offset\"?: string;\n  /**\n   * Any other annotation that can be added to the message.\n   */\n  [x: string]: any;\n}\n\n/**\n * Describes the structure of an event to be sent or received from the EventHub.\n * @internal\n */\nexport interface EventDataInternal {\n  /**\n   * The message body that needs to be sent or is received.\n   */\n  body: any;\n  /**\n   * The enqueued time of the event.\n   */\n  enqueuedTimeUtc?: Date;\n  /**\n   * If specified EventHub will hash this to a partitionId.\n   * It guarantees that messages end up in a specific partition on the event hub.\n   */\n  partitionKey?: string | null;\n  /**\n   * The offset of the event.\n   */\n  offset?: number;\n  /**\n   * The sequence number of the event.\n   */\n  sequenceNumber?: number;\n  /**\n   * The application specific properties.\n   */\n  properties?: { [property: string]: any };\n  /**\n   * The last sequence number of the event within the partition stream of the Event Hub.\n   */\n  lastSequenceNumber?: number;\n  /**\n   * The offset of the last enqueued event.\n   */\n  lastEnqueuedOffset?: string;\n  /**\n   * The enqueued UTC time of the last event.\n   */\n  lastEnqueuedTime?: Date;\n  /**\n   * The time when the runtime info was retrieved\n   */\n  retrievalTime?: Date;\n  /**\n   * The properties set by the service.\n   */\n  systemProperties?: { [property: string]: any };\n  /**\n   * The content type of the message. Optionally describes\n   * the payload of the message, with a descriptor following the format of RFC2045, Section 5, for\n   * example \"application/json\".\n   */\n  contentType?: string;\n\n  /**\n   * The correlation identifier that allows an\n   * application to specify a context for the message for the purposes of correlation, for example\n   * reflecting the MessageId of a message that is being replied to.\n   */\n  correlationId?: string | number | Buffer;\n\n  /**\n   * The message identifier is an\n   * application-defined value that uniquely identifies the message and its payload.\n   *\n   * Note: Numbers that are not whole integers are not allowed.\n   */\n  messageId?: string | number | Buffer;\n  /**\n   * Returns the underlying raw amqp message.\n   */\n  getRawAmqpMessage(): AmqpAnnotatedMessage;\n  /**\n   * The pending publish sequence number, set while the event\n   * is being published with idempotent partitions enabled.\n   */\n  [PENDING_PUBLISH_SEQ_NUM_SYMBOL]?: number;\n  /**\n   * The sequence number the event was published with\n   * when idempotent partitions are enabled.\n   */\n  _publishedSequenceNumber?: number;\n}\n\nconst messagePropertiesMap = {\n  message_id: \"messageId\",\n  user_id: \"userId\",\n  to: \"to\",\n  subject: \"subject\",\n  reply_to: \"replyTo\",\n  correlation_id: \"correlationId\",\n  content_type: \"contentType\",\n  content_encoding: \"contentEncoding\",\n  absolute_expiry_time: \"absoluteExpiryTime\",\n  creation_time: \"creationTime\",\n  group_id: \"groupId\",\n  group_sequence: \"groupSequence\",\n  reply_to_group_id: \"replyToGroupId\",\n} as const;\n\n/**\n * Converts the AMQP message to an EventData.\n * @param msg - The AMQP message that needs to be converted to EventData.\n * @param skipParsingBodyAsJson - Boolean to skip running JSON.parse() on message body when body type is `content`.\n * @internal\n */\nexport function fromRheaMessage(\n  msg: RheaMessage,\n  skipParsingBodyAsJson: boolean\n): EventDataInternal {\n  const rawMessage = AmqpAnnotatedMessage.fromRheaMessage(msg);\n  const { body, bodyType } = defaultDataTransformer.decode(msg.body, skipParsingBodyAsJson);\n  rawMessage.bodyType = bodyType;\n\n  const data: EventDataInternal = {\n    body,\n    getRawAmqpMessage() {\n      return rawMessage;\n    },\n  };\n\n  if (msg.message_annotations) {\n    for (const annotationKey of Object.keys(msg.message_annotations)) {\n      switch (annotationKey) {\n        case Constants.partitionKey:\n          data.partitionKey = msg.message_annotations[annotationKey];\n          break;\n        case Constants.sequenceNumber:\n          data.sequenceNumber = msg.message_annotations[annotationKey];\n          break;\n        case Constants.enqueuedTime:\n          data.enqueuedTimeUtc = new Date(msg.message_annotations[annotationKey]);\n          break;\n        case Constants.offset:\n          data.offset = msg.message_annotations[annotationKey];\n          break;\n        default:\n          if (!data.systemProperties) {\n            data.systemProperties = {};\n          }\n          data.systemProperties[annotationKey] = convertDatesToNumbers(\n            msg.message_annotations[annotationKey]\n          );\n          break;\n      }\n    }\n  }\n  if (msg.application_properties) {\n    data.properties = convertDatesToNumbers(msg.application_properties);\n  }\n  if (msg.delivery_annotations) {\n    data.lastEnqueuedOffset = msg.delivery_annotations.last_enqueued_offset;\n    data.lastSequenceNumber = msg.delivery_annotations.last_enqueued_sequence_number;\n    data.lastEnqueuedTime = new Date(msg.delivery_annotations.last_enqueued_time_utc as number);\n    data.retrievalTime = new Date(\n      msg.delivery_annotations.runtime_info_retrieval_time_utc as number\n    );\n  }\n\n  const messageProperties = Object.keys(messagePropertiesMap) as Array<\n    keyof typeof messagePropertiesMap\n  >;\n  for (const messageProperty of messageProperties) {\n    if (!data.systemProperties) {\n      data.systemProperties = {};\n    }\n    if (msg[messageProperty] != null) {\n      data.systemProperties[messagePropertiesMap[messageProperty]] = convertDatesToNumbers(\n        msg[messageProperty]\n      );\n    }\n  }\n\n  if (msg.content_type != null) {\n    data.contentType = msg.content_type;\n  }\n  if (msg.correlation_id != null) {\n    data.correlationId = msg.correlation_id;\n  }\n  if (msg.message_id != null) {\n    data.messageId = msg.message_id;\n  }\n\n  return data;\n}\n\n/**\n * Converts an EventData object to an AMQP message.\n * @param data - The EventData object that needs to be converted to an AMQP message.\n * @param partitionKey - An optional key to determine the partition that this event should land in.\n * @internal\n */\nexport function toRheaMessage(\n  data: EventData | AmqpAnnotatedMessage,\n  partitionKey?: string\n): RheaMessage {\n  let rheaMessage: RheaMessage;\n  if (isAmqpAnnotatedMessage(data)) {\n    rheaMessage = {\n      ...AmqpAnnotatedMessage.toRheaMessage(data),\n      body: defaultDataTransformer.encode(data.body, data.bodyType ?? \"data\"),\n    };\n  } else {\n    let bodyType: BodyTypes = \"data\";\n    if (typeof (data as EventDataInternal).getRawAmqpMessage === \"function\") {\n      /*\n        If the event is being round-tripped, then we respect the `bodyType` of the\n        underlying AMQP message.\n      */\n      bodyType = (data as EventDataInternal).getRawAmqpMessage().bodyType ?? \"data\";\n    }\n\n    rheaMessage = {\n      body: defaultDataTransformer.encode(data.body, bodyType),\n    };\n    // As per the AMQP 1.0 spec If the message-annotations or delivery-annotations section is omitted,\n    // it is equivalent to a message-annotations section containing anempty map of annotations.\n    rheaMessage.message_annotations = {};\n\n    if (data.properties) {\n      rheaMessage.application_properties = data.properties;\n    }\n\n    if (isDefined(partitionKey)) {\n      rheaMessage.message_annotations[Constants.partitionKey] = partitionKey;\n      // Event Hub service cannot route messages to a specific partition based on the partition key\n      // if AMQP message header is an empty object. Hence we make sure that header is always present\n      // with atleast one property. Setting durable to true, helps us achieve that.\n      rheaMessage.durable = true;\n    }\n\n    if (data.contentType != null) {\n      rheaMessage.content_type = data.contentType;\n    }\n    if (data.correlationId != null) {\n      rheaMessage.correlation_id = data.correlationId;\n    }\n    if (data.messageId != null) {\n      if (\n        typeof data.messageId === \"string\" &&\n        data.messageId.length > Constants.maxMessageIdLength\n      ) {\n        throw new Error(\n          `Length of 'messageId' property on the event cannot be greater than ${Constants.maxMessageIdLength} characters.`\n        );\n      }\n      rheaMessage.message_id = data.messageId;\n    }\n  }\n\n  return rheaMessage;\n}\n\n/**\n * The interface that describes the data to be sent to Event Hub.\n * Use this as a reference when creating the object to be sent when using the `EventHubProducerClient`.\n * For example, `{ body: \"your-data\" }` or\n * ```\n * {\n *    body: \"your-data\",\n *    properties: {\n *       propertyName: \"property value\"\n *    }\n * }\n * ```\n */\nexport interface EventData {\n  /**\n   * The message body that needs to be sent.\n   * If the application reading the events is not using this SDK,\n   * convert your body payload to a byte array or Buffer for better\n   * cross-language compatibility.\n   */\n  body: any;\n\n  /**\n   * The content type of the message. Optionally describes\n   * the payload of the message, with a descriptor following the format of RFC2045, Section 5, for\n   * example \"application/json\".\n   */\n  contentType?: string;\n\n  /**\n   * The correlation identifier that allows an\n   * application to specify a context for the message for the purposes of correlation, for example\n   * reflecting the MessageId of a message that is being replied to.\n   */\n  correlationId?: string | number | Buffer;\n\n  /**\n   * The message identifier is an\n   * application-defined value that uniquely identifies the message and its payload.\n   *\n   * Note: Numbers that are not whole integers are not allowed.\n   */\n  messageId?: string | number | Buffer;\n\n  /**\n   * Set of key value pairs that can be used to set properties specific to user application.\n   */\n  properties?: {\n    [key: string]: any;\n  };\n}\n\n/**\n * The interface that describes the structure of the event received from Event Hub.\n * Use this as a reference when creating the `processEvents` function to process the events\n * recieved from an Event Hub when using the `EventHubConsumerClient`.\n */\nexport interface ReceivedEventData {\n  /**\n   * The message body that needs to be sent or is received.\n   */\n  body: any;\n  /**\n   * The application specific properties.\n   */\n  properties?: {\n    [key: string]: any;\n  };\n  /**\n   * The enqueued time of the event.\n   */\n  enqueuedTimeUtc: Date;\n  /**\n   * When specified Event Hub will hash this to a partitionId.\n   * It guarantees that messages end up in a specific partition on the event hub.\n   */\n  partitionKey: string | null;\n  /**\n   * The offset of the event.\n   */\n  offset: number;\n  /**\n   * The sequence number of the event.\n   */\n  sequenceNumber: number;\n  /**\n   * The properties set by the service.\n   */\n  systemProperties?: {\n    [key: string]: any;\n  };\n\n  /**\n   * The content type of the message. Optionally describes\n   * the payload of the message, with a descriptor following the format of RFC2045, Section 5, for\n   * example \"application/json\".\n   */\n  contentType?: string;\n\n  /**\n   * The correlation identifier that allows an\n   * application to specify a context for the message for the purposes of correlation, for example\n   * reflecting the MessageId of a message that is being replied to.\n   */\n  correlationId?: string | number | Buffer;\n\n  /**\n   * The message identifier is an\n   * application-defined value that uniquely identifies the message and its payload.\n   */\n  messageId?: string | number | Buffer;\n\n  /**\n   * Returns the underlying raw amqp message.\n   */\n  getRawAmqpMessage(): AmqpAnnotatedMessage;\n}\n\n/**\n * @internal\n */\nexport function isAmqpAnnotatedMessage(possible: unknown): possible is AmqpAnnotatedMessage {\n  return (\n    isObjectWithProperties(possible, [\"body\", \"bodyType\"]) &&\n    !objectHasProperty(possible, \"getRawAmqpMessage\")\n  );\n}\n\n/**\n * Converts any Date objects into a number representing date.getTime().\n * Recursively checks for any Date objects in arrays and objects.\n * @internal\n */\nfunction convertDatesToNumbers<T = unknown>(thing: T): T {\n  // fast exit\n  if (!isDefined(thing)) return thing;\n\n  // When 'thing' is a Date, return the number representation\n  if (\n    typeof thing === \"object\" &&\n    objectHasProperty(thing, \"getTime\") &&\n    typeof thing.getTime === \"function\"\n  ) {\n    return thing.getTime();\n  }\n\n  /*\n    Examples:\n    [0, 'foo', new Date(), { nested: new Date()}]\n  */\n  if (Array.isArray(thing)) {\n    return thing.map(convertDatesToNumbers) as unknown as T;\n  }\n\n  /*\n    Examples:\n    { foo: new Date(), children: { nested: new Date() }}\n  */\n  if (typeof thing === \"object\" && isDefined<object>(thing)) {\n    const thingShallowCopy = { ...thing };\n    for (const key of Object.keys(thingShallowCopy)) {\n      (thingShallowCopy as any)[key] = convertDatesToNumbers((thingShallowCopy as any)[key]);\n    }\n    return thingShallowCopy;\n  }\n\n  return thing;\n}\n\n/**\n * @internal\n */\nexport interface PopulateIdempotentMessageAnnotationsParameters {\n  isIdempotentPublishingEnabled: boolean;\n  ownerLevel?: number;\n  producerGroupId?: number;\n  publishSequenceNumber?: number;\n}\n\n/**\n * Populates a rhea message with idempotent producer properties.\n * @internal\n */\nexport function populateIdempotentMessageAnnotations(\n  rheaMessage: RheaMessage,\n  {\n    isIdempotentPublishingEnabled,\n    ownerLevel,\n    producerGroupId,\n    publishSequenceNumber,\n  }: PopulateIdempotentMessageAnnotationsParameters\n): void {\n  if (!isIdempotentPublishingEnabled) {\n    return;\n  }\n\n  const messageAnnotations = rheaMessage.message_annotations || {};\n  if (!rheaMessage.message_annotations) {\n    rheaMessage.message_annotations = messageAnnotations;\n  }\n\n  if (isDefined(ownerLevel)) {\n    messageAnnotations[idempotentProducerAmqpPropertyNames.epoch] = types.wrap_short(ownerLevel);\n  }\n  if (isDefined(producerGroupId)) {\n    messageAnnotations[idempotentProducerAmqpPropertyNames.producerId] =\n      types.wrap_long(producerGroupId);\n  }\n  if (isDefined(publishSequenceNumber)) {\n    messageAnnotations[idempotentProducerAmqpPropertyNames.producerSequenceNumber] =\n      types.wrap_int(publishSequenceNumber);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { Constants, RetryOptions } from \"@azure/core-amqp\";\n\n/**\n * @internal\n */\nexport function getRetryAttemptTimeoutInMs(retryOptions: RetryOptions = {}): number {\n  const { timeoutInMs } = retryOptions;\n  return typeof timeoutInMs !== \"number\" ||\n    !isFinite(timeoutInMs) ||\n    timeoutInMs < Constants.defaultOperationTimeoutInMs\n    ? Constants.defaultOperationTimeoutInMs\n    : timeoutInMs;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { randomUUID } from \"@azure/core-util\";\n\n/**\n * Returns a random name by appending a guid to the input string as follows:\n * `{name}-{uuid}`.\n * @internal\n */\nexport function getRandomName(prefix?: string): string {\n  const str = randomUUID();\n  return prefix ? `${prefix}-${str}` : str;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/**\n * A timer loop is a loop over multiple instances of a promise every specific\n * time interval. It is different from `setInterval` in that it waits until the\n * promise is settled before it goes to the next iteration.\n * */\nexport interface TimerLoop {\n  /**\n   * Starts the timer loop. If the loop is already running, the loop will be\n   * restarted.\n   */\n  start: () => void;\n  /**\n   * Stops the timer loop. If the loop is not running, it is a no-op.\n   */\n  stop: () => void;\n  /**\n   * Whether the loop is running.\n   */\n  isRunning: boolean;\n}\n\n/**\n * Creates a timer loop with the given timeout and task.\n * @internal\n */\nexport function createTimerLoop(\n  timeoutInMs: number,\n  createTask: () => Promise<unknown>\n): TimerLoop {\n  let token: ReturnType<typeof setTimeout>;\n  const loop = {\n    start: () => {\n      clearTimeout(token);\n      token = setTimeout(\n        () =>\n          createTask()\n            .catch(() => {\n              /** eats up any unhandled error */\n            })\n            .finally(loop.start),\n        timeoutInMs\n      );\n      loop.isRunning = true;\n    },\n    stop: () => {\n      clearTimeout(token);\n      loop.isRunning = false;\n    },\n    isRunning: false,\n  };\n  return loop;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  Constants,\n  TokenType,\n  defaultCancellableLock,\n  isSasTokenProvider,\n  SasTokenProvider,\n  CbsClient,\n  CbsResponse,\n} from \"@azure/core-amqp\";\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { AccessToken, TokenCredential } from \"@azure/core-auth\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { createTimerLoop, TimerLoop } from \"./util/timerLoop\";\nimport { SimpleLogger, logObj } from \"./logger\";\n\n/**\n *\n * @param callback - The callback to be executed after the token is obtained.\n * @param context - The connection context.\n * @param audience - The audience for which the token is needed.\n * @param timeoutInMs - The timeout in milliseconds.\n * @param logger - The logger to be used for logging.\n * @returns  A TimerLoop that keeps the token refreshed.\n * @internal\n */\nexport async function withAuth(\n  callback: () => Promise<void>,\n  context: ConnectionContext,\n  audience: string,\n  timeoutInMs: number,\n  logger: SimpleLogger,\n  options: {\n    abortSignal?: AbortSignalLike;\n  }\n): Promise<TimerLoop> {\n  const info = await getTokenInfo(context.tokenCredential, audience);\n  await setupClaimNegotiation(context, audience, info, timeoutInMs, logger, options);\n  await callback();\n  async function createTask() {\n    try {\n      await setupClaimNegotiation(context, audience, info, timeoutInMs, logger, options);\n      logger.verbose(\n        `next token renewal is in ${info.timeoutInMs} milliseconds @(${new Date(\n          Date.now() + info.timeoutInMs\n        ).toString()}).`\n      );\n    } catch (err) {\n      logger.verbose(`an error occurred while renewing the token: ${logObj(err)}`);\n    }\n  }\n  const loop = createTimerLoop(info.timeoutInMs, createTask);\n  loop.start();\n  return loop;\n}\n\n/**\n * @internal\n */\nexport async function openCbsSession(\n  client: CbsClient,\n  timeoutAfterStartTime: number,\n  { abortSignal }: { abortSignal?: AbortSignalLike } = {}\n): Promise<void> {\n  return defaultCancellableLock.acquire(\n    client.cbsLock,\n    () =>\n      client.init({\n        abortSignal,\n        timeoutInMs: timeoutAfterStartTime - Date.now(),\n      }),\n    {\n      abortSignal,\n      timeoutInMs: timeoutAfterStartTime - Date.now(),\n    }\n  );\n}\n\n/**\n * A representation of an access token.\n * @internal\n */\ninterface TokenInfo {\n  /** The access token */\n  token: AccessToken;\n  /** The type of the token */\n  type: TokenType;\n  /** The time duration after which the token should be refreshed */\n  timeoutInMs: number;\n}\n\nasync function getAadToken(cred: TokenCredential): Promise<TokenInfo> {\n  const token = await cred.getToken(Constants.aadEventHubsScope);\n  if (!token) {\n    throw new Error(`Failed to get token from the provided \"TokenCredential\" object`);\n  }\n  return {\n    token,\n    type: TokenType.CbsTokenTypeJwt,\n    timeoutInMs: token.expiresOnTimestamp - Date.now() - 2 * 60 * 1000,\n  };\n}\n\nfunction getSharedKeyBasedToken(cred: SasTokenProvider, audience: string): TokenInfo {\n  return {\n    token: cred.getToken(audience),\n    type: TokenType.CbsTokenTypeSas,\n    timeoutInMs: 45 * 60 * 1000,\n  };\n}\n\nasync function getTokenInfo(\n  cred: SasTokenProvider | TokenCredential,\n  audience: string\n): Promise<TokenInfo> {\n  return isSasTokenProvider(cred) ? getSharedKeyBasedToken(cred, audience) : getAadToken(cred);\n}\n\nfunction negotiateClaim(\n  { token, type }: TokenInfo,\n  audience: string,\n  cbsSession: CbsClient,\n  timeoutAfterStartTime: number,\n  lock: string,\n  abortSignal?: AbortSignalLike\n): Promise<CbsResponse> {\n  return defaultCancellableLock.acquire(\n    lock,\n    () =>\n      cbsSession.negotiateClaim(audience, token.token, type, {\n        abortSignal,\n        timeoutInMs: timeoutAfterStartTime - Date.now(),\n      }),\n    {\n      abortSignal,\n      timeoutInMs: timeoutAfterStartTime - Date.now(),\n    }\n  );\n}\n\nasync function setupClaimNegotiation(\n  context: ConnectionContext,\n  audience: string,\n  info: TokenInfo,\n  timeoutInMs: number,\n  logger: SimpleLogger,\n  {\n    abortSignal,\n  }: {\n    abortSignal?: AbortSignalLike;\n  }\n): Promise<void> {\n  const startTime = Date.now();\n  logger.verbose(\n    `acquiring cbs lock: '${context.cbsSession.cbsLock}' for creating the cbs session`\n  );\n\n  await openCbsSession(context.cbsSession, timeoutInMs + startTime, { abortSignal });\n  logger.verbose(`acquiring cbs lock: '${context.negotiateClaimLock}' for cbs auth`);\n  await negotiateClaim(\n    info,\n    audience,\n    context.cbsSession,\n    timeoutInMs + startTime,\n    context.negotiateClaimLock,\n    abortSignal\n  );\n  logger.verbose(\"claim negotiation succeeded\");\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortController, AbortError, AbortSignalLike } from \"@azure/abort-controller\";\nimport {\n  Constants,\n  MessagingError,\n  RetryOperationType,\n  StandardAbortMessage,\n  retry,\n  translate,\n  RetryConfig,\n} from \"@azure/core-amqp\";\nimport {\n  EventContext,\n  Receiver as Link,\n  ReceiverOptions as RheaReceiverOptions,\n  Source,\n  types,\n} from \"rhea-promise\";\nimport { EventDataInternal, ReceivedEventData, fromRheaMessage } from \"./eventData\";\nimport { EventPosition, getEventPositionFilter } from \"./eventPosition\";\nimport {\n  createLogPrefix,\n  createSimpleLogger,\n  logErrorStackTrace,\n  logObj,\n  logger as azureLogger,\n  SimpleLogger,\n} from \"./logger\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { EventHubConsumerOptions } from \"./models/private\";\nimport { getRetryAttemptTimeoutInMs } from \"./util/retries\";\nimport { createAbortablePromise } from \"@azure/core-util\";\nimport { TimerLoop } from \"./util/timerLoop\";\nimport { getRandomName } from \"./util/utils\";\nimport { withAuth } from \"./withAuth\";\n\ntype Writable<T> = {\n  -readonly [P in keyof T]: T[P];\n};\n/** @internal */\nexport type WritableReceiver = Writable<PartitionReceiver>;\n\nconst abortLogMessage = \"operation has been cancelled by the user\";\n/** The time to wait in ms before attempting to read from the queue */\nconst qReadIntervalInMs = 20;\n\n/**\n * A set of information about the last enqueued event of a partition, as observed by the consumer as\n * events are received from the Event Hubs service\n */\nexport interface LastEnqueuedEventProperties {\n  /**\n   * The sequence number of the event that was last enqueued into the Event Hub partition from which\n   * this event was received.\n   */\n  sequenceNumber?: number;\n  /**\n   * The date and time, in UTC, that the last event was enqueued into the Event Hub partition from\n   * which this event was received.\n   */\n  enqueuedOn?: Date;\n  /**\n   * The offset of the event that was last enqueued into the Event Hub partition from which\n   * this event was received.\n   */\n  offset?: string;\n  /**\n   * The date and time, in UTC, that the last event was retrieved from the Event Hub partition.\n   */\n  retrievedOn?: Date;\n}\n\n/** @internal */\nexport interface PartitionReceiver {\n  readonly checkpoint: number;\n  readonly lastEnqueuedEventProperties: LastEnqueuedEventProperties;\n  readonly isClosed: boolean;\n  readonly close: () => Promise<void>;\n  readonly abort: () => Promise<void>;\n  readonly isOpen: () => boolean;\n  readonly receiveBatch: (\n    maxMessageCount: number,\n    maxWaitTimeInSeconds?: number,\n    abortSignal?: AbortSignalLike\n  ) => Promise<ReceivedEventData[]>;\n  /** Needed for tests only */\n  readonly _onError?: (error: MessagingError | Error) => void;\n  readonly connect: (options: ConnectOptions) => Promise<void>;\n}\n\ninterface ConnectOptions {\n  abortSignal: AbortSignalLike | undefined;\n  timeoutInMs: number;\n}\n\ninterface ReceiverState {\n  link?: Link;\n  authLoop?: TimerLoop;\n  isConnecting: boolean;\n}\n\n/** @internal */\nexport function createReceiver(\n  ctx: ConnectionContext,\n  consumerGroup: string,\n  partitionId: string,\n  eventPosition: EventPosition,\n  options: EventHubConsumerOptions = {}\n): PartitionReceiver {\n  const address = ctx.config.getReceiverAddress(partitionId, consumerGroup);\n  const name = getRandomName(address);\n  const audience = ctx.config.getReceiverAudience(partitionId, consumerGroup);\n  const logPrefix = createLogPrefix(ctx.connectionId, \"Receiver\", name);\n  const logger = createSimpleLogger(azureLogger, logPrefix);\n  const queue: ReceivedEventData[] = [];\n  const state: ReceiverState = {\n    isConnecting: false,\n  };\n\n  const obj: WritableReceiver = {\n    _onError: undefined,\n    checkpoint: -1,\n    lastEnqueuedEventProperties: {},\n    isClosed: false,\n    close: async () => {\n      clearHandlers(obj);\n      delete ctx.receivers[name];\n      logger.verbose(\"deleted the receiver from the client cache\");\n      state.authLoop?.stop();\n      return state.link\n        ?.close()\n        .catch((err) => {\n          logger.warning(`an error occurred while closing: ${err?.name}: ${err?.message}`);\n          logErrorStackTrace(err);\n          throw err;\n        })\n        .finally(() => {\n          obj.isClosed = true;\n          logger.verbose(\"is closed\");\n          state.link = undefined;\n          state.authLoop = undefined;\n        });\n    },\n    abort: () => {\n      obj._onError?.(new AbortError(StandardAbortMessage));\n      logger.info(abortLogMessage);\n      return obj.close();\n    },\n    isOpen: () => {\n      const isOpen = !!state.link?.isOpen();\n      logger.verbose(`is open? -> ${isOpen}`);\n      return isOpen;\n    },\n    async connect({ abortSignal, timeoutInMs }: ConnectOptions): Promise<void> {\n      if (state.isConnecting || obj.isOpen()) {\n        return;\n      }\n      state.isConnecting = true;\n      logger.verbose(\"is trying to connect\");\n      try {\n        await ctx.readyToOpenLink({ abortSignal });\n        state.authLoop = await withAuth(\n          () =>\n            setupLink(\n              ctx,\n              name,\n              address,\n              obj,\n              state,\n              queue,\n              eventPosition,\n              logger,\n              options,\n              abortSignal\n            ),\n          ctx,\n          audience,\n          timeoutInMs,\n          logger,\n          {\n            abortSignal,\n          }\n        );\n      } catch (err) {\n        state.isConnecting = false;\n        const error = translate(err);\n        logger.error(\n          `an error occurred while creating the receiver: ${error?.name}: ${error?.message}`\n        );\n        logErrorStackTrace(err);\n        throw error;\n      }\n    },\n    receiveBatch: (\n      maxMessageCount: number,\n      maxWaitTimeInSeconds: number = 60,\n      abortSignal?: AbortSignalLike\n    ) => {\n      const cleanupBeforeAbort = (): Promise<void> => {\n        logger.info(abortLogMessage);\n        return obj.close();\n      };\n      const retrieveEvents = (): Promise<ReceivedEventData[]> => {\n        const eventsToRetrieveCount = Math.max(maxMessageCount - queue.length, 0);\n        logger.verbose(\n          `already has ${queue.length} events and wants to receive ${eventsToRetrieveCount} more events`\n        );\n        if (abortSignal?.aborted) {\n          cleanupBeforeAbort();\n          return Promise.reject(new AbortError(StandardAbortMessage));\n        }\n        return obj.isClosed || ctx.wasConnectionCloseCalled\n          ? Promise.resolve(queue.splice(0))\n          : eventsToRetrieveCount === 0\n          ? Promise.resolve(queue.splice(0, maxMessageCount))\n          : new Promise<void>((resolve, reject) => {\n              obj._onError = reject;\n              obj // eslint-disable-line promise/catch-or-return\n                .connect({\n                  abortSignal,\n                  timeoutInMs: getRetryAttemptTimeoutInMs(options.retryOptions),\n                })\n                .then(() => {\n                  if (addCredits(state.link, eventsToRetrieveCount) > 0) {\n                    return logger.verbose(\n                      `setting the wait timer for ${maxWaitTimeInSeconds} seconds`\n                    );\n                  } else return;\n                })\n                .then(() =>\n                  waitForEvents(\n                    maxMessageCount,\n                    maxWaitTimeInSeconds * 1000,\n                    qReadIntervalInMs,\n                    queue,\n                    {\n                      abortSignal,\n                      cleanupBeforeAbort,\n                      receivedAfterWait: () =>\n                        logger.info(\n                          `${Math.min(\n                            maxMessageCount,\n                            queue.length\n                          )} messages received within ${maxWaitTimeInSeconds} seconds`\n                        ),\n                      receivedAlready: () =>\n                        logger.info(`${maxMessageCount} messages already received`),\n                      receivedNone: () =>\n                        logger.info(\n                          `no messages received when max wait time in seconds ${maxWaitTimeInSeconds} is over`\n                        ),\n                    }\n                  )\n                )\n                .catch(reject)\n                .then(resolve);\n            })\n              .then(() => queue.splice(0, maxMessageCount))\n              .finally(() => clearHandlers(obj));\n      };\n      return retry(\n        Object.defineProperties(\n          {\n            operation: retrieveEvents,\n            operationType: RetryOperationType.receiveMessage,\n            abortSignal: abortSignal,\n            retryOptions: options.retryOptions ?? {},\n          },\n          {\n            connectionId: {\n              enumerable: true,\n              get: () => ctx.connectionId,\n            },\n            connectionHost: {\n              enumerable: true,\n              get: () => ctx.config.host,\n            },\n          }\n        ) as RetryConfig<ReceivedEventData[]>\n      );\n    },\n  };\n  return obj;\n}\n\nfunction delay(\n  waitTimeInMs: number,\n  options?: {\n    abortSignal?: AbortSignalLike;\n    cleanupBeforeAbort?: () => void;\n    abortErrorMsg?: string;\n  }\n): Promise<void> {\n  let token: ReturnType<typeof setTimeout>;\n  return createAbortablePromise<void>((resolve) => {\n    token = setTimeout(resolve, waitTimeInMs);\n  }, options).finally(() => clearTimeout(token));\n}\n\n/**\n * @internal\n */\nexport function checkOnInterval(\n  waitTimeInMs: number,\n  check: () => boolean,\n  options?: {\n    abortSignal?: AbortSignalLike;\n    cleanupBeforeAbort?: () => void;\n    abortErrorMsg?: string;\n  }\n): Promise<void> {\n  let token: ReturnType<typeof setInterval>;\n  return createAbortablePromise<void>((resolve) => {\n    token = setInterval(() => {\n      if (check()) {\n        resolve();\n      }\n    }, waitTimeInMs);\n  }, options).finally(() => clearInterval(token));\n}\n\n/**\n * Returns a promise that will resolve when it is time to read from the queue\n * @param maxEventCount - The maximum number of events to receive.\n * @param maxWaitTimeInMs - The maximum time to wait in ms for the queue to contain any events.\n * @param readIntervalWaitTimeInMs - The time interval to wait in ms before checking the queue.\n * @param queue - The queue to read from.\n * @param options - The options bag.\n * @returns a promise that will resolve when it is time to read from the queue\n * @internal\n */\nexport function waitForEvents(\n  maxEventCount: number,\n  maxWaitTimeInMs: number,\n  readIntervalWaitTimeInMs: number,\n  queue: unknown[],\n  options: {\n    abortSignal?: AbortSignalLike;\n    cleanupBeforeAbort?: () => void;\n    receivedAfterWait?: () => void;\n    receivedAlready?: () => void;\n    receivedNone?: () => void;\n  } = {}\n): Promise<void> {\n  const {\n    abortSignal: clientAbortSignal,\n    cleanupBeforeAbort,\n    receivedNone,\n    receivedAfterWait,\n    receivedAlready,\n  } = options;\n\n  if (queue.length >= maxEventCount) {\n    return Promise.resolve().then(receivedAlready);\n  }\n\n  const aborter = new AbortController();\n  const abortListener = () => {\n    aborter.abort();\n  };\n  clientAbortSignal?.addEventListener(\"abort\", abortListener);\n\n  const updatedOptions = {\n    abortSignal: aborter.signal,\n    abortErrorMsg: StandardAbortMessage,\n    cleanupBeforeAbort: () => {\n      if (clientAbortSignal?.aborted) {\n        cleanupBeforeAbort?.();\n      }\n    },\n  };\n  return Promise.race([\n    checkOnInterval(readIntervalWaitTimeInMs, () => queue.length > 0, updatedOptions)\n      .then(() => delay(readIntervalWaitTimeInMs, updatedOptions))\n      .then(receivedAfterWait),\n    delay(maxWaitTimeInMs, updatedOptions).then(receivedNone),\n  ]).finally(() => {\n    aborter.abort();\n    clientAbortSignal?.removeEventListener(\"abort\", abortListener);\n  });\n}\n\nfunction convertAMQPMesage(data: EventDataInternal): ReceivedEventData {\n  const rawMessage = data.getRawAmqpMessage();\n  const receivedEventData: ReceivedEventData = {\n    body: data.body,\n    properties: data.properties,\n    offset: data.offset!,\n    sequenceNumber: data.sequenceNumber!,\n    enqueuedTimeUtc: data.enqueuedTimeUtc!,\n    partitionKey: data.partitionKey!,\n    systemProperties: data.systemProperties,\n    getRawAmqpMessage() {\n      return rawMessage;\n    },\n  };\n  if (data.correlationId != null) {\n    receivedEventData.correlationId = data.correlationId;\n  }\n  if (data.contentType != null) {\n    receivedEventData.contentType = data.contentType;\n  }\n  if (data.messageId != null) {\n    receivedEventData.messageId = data.messageId;\n  }\n  return receivedEventData;\n}\n\nfunction setEventProps(eventProps: LastEnqueuedEventProperties, data: EventDataInternal): void {\n  eventProps.sequenceNumber = data.lastSequenceNumber;\n  eventProps.enqueuedOn = data.lastEnqueuedTime;\n  eventProps.offset = data.lastEnqueuedOffset;\n  eventProps.retrievedOn = data.retrievalTime;\n}\n\nfunction addCredits(receiver: Link | undefined, eventsToRetrieveCount: number): number {\n  const creditsToAdd = eventsToRetrieveCount - (receiver?.credit ?? 0);\n  if (creditsToAdd > 0) {\n    receiver?.addCredit(creditsToAdd);\n  }\n  return creditsToAdd;\n}\n\nfunction clearHandlers(obj: WritableReceiver): void {\n  obj._onError = undefined;\n}\n\nfunction onMessage(\n  context: EventContext,\n  obj: WritableReceiver,\n  queue: ReceivedEventData[],\n  options: EventHubConsumerOptions\n): void {\n  if (!context.message) {\n    return;\n  }\n  const data = fromRheaMessage(context.message, !!options.skipParsingBodyAsJson);\n  const receivedEventData = convertAMQPMesage(data);\n  obj.checkpoint = receivedEventData.sequenceNumber;\n  if (options.trackLastEnqueuedEventProperties) {\n    setEventProps(obj.lastEnqueuedEventProperties, data);\n  }\n  queue.push(receivedEventData);\n}\n\nfunction onError(\n  context: EventContext,\n  obj: PartitionReceiver,\n  receiver: Link | undefined,\n  logger: SimpleLogger\n): void {\n  const rheaReceiver = receiver || context.receiver;\n  const amqpError = rheaReceiver?.error;\n  logger.verbose(`'receiver_error' event occurred: ${logObj(amqpError)}`);\n  if (obj._onError && amqpError) {\n    const error = translate(amqpError);\n    logErrorStackTrace(error);\n    obj._onError(error);\n  }\n}\n\nfunction onSessionError(context: EventContext, obj: PartitionReceiver, logger: SimpleLogger): void {\n  const sessionError = context.session?.error;\n  logger.verbose(`'session_error' event occurred: ${logObj(sessionError)}`);\n  if (obj._onError && sessionError) {\n    const error = translate(sessionError);\n    logErrorStackTrace(error);\n    obj._onError(error);\n  }\n}\n\nasync function onClose(\n  context: EventContext,\n  state: ReceiverState,\n  logger: SimpleLogger\n): Promise<void> {\n  const rheaReceiver = state.link || context.receiver;\n  logger.verbose(\n    `'receiver_close' event occurred. Value for isItselfClosed on the receiver is: '${rheaReceiver\n      ?.isItselfClosed()\n      .toString()}' Value for isConnecting on the session is: '${state.isConnecting}'`\n  );\n  if (rheaReceiver && !state.isConnecting) {\n    return rheaReceiver.close().catch((err) => {\n      logger.verbose(`error when closing after 'receiver_close' event: ${logObj(err)}`);\n    });\n  }\n}\n\nasync function onSessionClose(\n  context: EventContext,\n  state: ReceiverState,\n  logger: SimpleLogger\n): Promise<void> {\n  const rheaReceiver = state.link || context.receiver;\n  logger.verbose(\n    `'session_close' event occurred. Value for isSessionItselfClosed on the session is: '${rheaReceiver\n      ?.isSessionItselfClosed()\n      .toString()}' Value for isConnecting on the session is: '${state.isConnecting}'`\n  );\n  if (rheaReceiver && !state.isConnecting) {\n    return rheaReceiver.close().catch((err) => {\n      logger.verbose(`error when closing after 'session_close' event: ${logObj(err)}`);\n    });\n  }\n}\n\nfunction createRheaOptions(\n  name: string,\n  address: string,\n  obj: PartitionReceiver,\n  state: ReceiverState,\n  queue: ReceivedEventData[],\n  eventPosition: EventPosition,\n  logger: SimpleLogger,\n  options: EventHubConsumerOptions\n): RheaReceiverOptions {\n  const rheaOptions: RheaReceiverOptions & { source: Source } = {\n    name,\n    autoaccept: true,\n    source: {\n      address,\n    },\n    credit_window: 0,\n    onClose: (context) => onClose(context, state, logger),\n    onSessionClose: (context) => onSessionClose(context, state, logger),\n    onError: (context) => onError(context, obj, state.link, logger),\n    onMessage: (context) => onMessage(context, obj, queue, options),\n    onSessionError: (context) => onSessionError(context, obj, logger),\n  };\n  const ownerLevel = options.ownerLevel;\n  if (typeof ownerLevel === \"number\") {\n    rheaOptions.properties = {\n      [Constants.attachEpoch]: types.wrap_long(ownerLevel),\n    };\n  }\n  if (options.trackLastEnqueuedEventProperties) {\n    rheaOptions.desired_capabilities = Constants.enableReceiverRuntimeMetricName;\n  }\n  const filterClause = getEventPositionFilter(\n    obj.checkpoint > -1 ? { sequenceNumber: obj.checkpoint } : eventPosition\n  );\n  rheaOptions.source.filter = {\n    \"apache.org:selector-filter:string\": types.wrap_described(filterClause, 0x468c00000004),\n  };\n  return rheaOptions;\n}\n\nasync function setupLink(\n  ctx: ConnectionContext,\n  name: string,\n  address: string,\n  obj: PartitionReceiver,\n  state: ReceiverState,\n  queue: ReceivedEventData[],\n  eventPosition: EventPosition,\n  logger: SimpleLogger,\n  options: EventHubConsumerOptions,\n  abortSignal?: AbortSignalLike\n): Promise<void> {\n  const rheaOptions = createRheaOptions(\n    name,\n    address,\n    obj,\n    state,\n    queue,\n    eventPosition,\n    logger,\n    options\n  );\n  logger.verbose(`trying to be created with options ${logObj(rheaOptions)}`);\n  state.link = await ctx.connection.createReceiver({\n    ...rheaOptions,\n    abortSignal,\n  });\n  state.isConnecting = false;\n  logger.verbose(\"is created successfully\");\n  ctx.receivers[name] = obj;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { createTracingClient, TracingSpanOptions, TracingSpanKind } from \"@azure/core-tracing\";\nimport { EventHubConnectionConfig } from \"../eventhubConnectionConfig\";\nimport { packageJsonInfo } from \"../util/constants\";\n\n/**\n * The names of the operations that can be instrumented.\n */\nexport type MessagingOperationNames = \"publish\" | \"receive\" | \"process\";\n\n/**\n * The {@link TracingClient} that is used to add tracing spans.\n */\nexport const tracingClient = createTracingClient({\n  namespace: \"Microsoft.EventHub\",\n  packageName: packageJsonInfo.name,\n  packageVersion: packageJsonInfo.version,\n});\n\n/**\n * Creates {@link TracingSpanOptions} from the provided data.\n * @param eventHubConfig - The configuration object containing initial attributes to set on the span.\n * @param spanKind - The {@link TracingSpanKind} for the newly created span.\n * @param operation - The operation type.\n * @returns a {@link TracingSpanOptions} that can be passed to a {@link TracingClient}\n */\nexport function toSpanOptions(\n  eventHubConfig: Pick<EventHubConnectionConfig, \"entityPath\" | \"host\">,\n  operation?: MessagingOperationNames,\n  spanKind?: TracingSpanKind\n): TracingSpanOptions {\n  const propertyName =\n    operation === \"process\" || operation === \"receive\"\n      ? \"messaging.source.name\"\n      : \"messaging.destination.name\";\n\n  const spanAttributes = {\n    \"messaging.system\": \"eventhubs\",\n    [propertyName]: eventHubConfig.entityPath,\n    \"net.peer.name\": eventHubConfig.host,\n  };\n\n  if (operation) {\n    spanAttributes[\"messaging.operation\"] = operation;\n  }\n\n  const spanOptions: TracingSpanOptions = {\n    spanAttributes: spanAttributes,\n  };\n  if (spanKind) {\n    spanOptions.spanKind = spanKind;\n  }\n  return spanOptions;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { EventData, isAmqpAnnotatedMessage } from \"../eventData\";\nimport { TracingContext } from \"@azure/core-tracing\";\nimport { AmqpAnnotatedMessage } from \"@azure/core-amqp\";\nimport { OperationOptions } from \"../util/operationOptions\";\nimport { MessagingOperationNames, toSpanOptions, tracingClient } from \"./tracing\";\n\n/**\n * @internal\n */\nexport const TRACEPARENT_PROPERTY = \"Diagnostic-Id\";\n\n/**\n * Populates the `EventData` with `SpanContext` info to support trace propagation.\n * Creates and returns a copy of the passed in `EventData` unless the `EventData`\n * has already been instrumented.\n * @param eventData - The `EventData` or `AmqpAnnotatedMessage` to instrument.\n * @param span - The `Span` containing the context to propagate tracing information.\n * @param operation - The type of the operation being performed.\n */\nexport function instrumentEventData(\n  eventData: EventData | AmqpAnnotatedMessage,\n  options: OperationOptions,\n  entityPath: string,\n  host: string,\n  operation?: MessagingOperationNames\n): { event: EventData; spanContext: TracingContext | undefined } {\n  const props = isAmqpAnnotatedMessage(eventData)\n    ? eventData.applicationProperties\n    : eventData.properties;\n\n  // check if the event has already been instrumented\n  const previouslyInstrumented = Boolean(props?.[TRACEPARENT_PROPERTY]);\n\n  if (previouslyInstrumented) {\n    return { event: eventData, spanContext: undefined };\n  }\n\n  const { span: messageSpan, updatedOptions } = tracingClient.startSpan(\n    \"message\",\n    options,\n    toSpanOptions({ entityPath, host }, operation, \"producer\")\n  );\n  try {\n    if (!messageSpan.isRecording()) {\n      return {\n        event: eventData,\n        spanContext: undefined,\n      };\n    }\n\n    const traceParent = tracingClient.createRequestHeaders(\n      updatedOptions.tracingOptions?.tracingContext\n    )[\"traceparent\"];\n    if (traceParent) {\n      const copiedProps = { ...props };\n\n      // create a copy so the original isn't modified\n      if (isAmqpAnnotatedMessage(eventData)) {\n        eventData = { ...eventData, applicationProperties: copiedProps };\n      } else {\n        eventData = { ...eventData, properties: copiedProps };\n      }\n      copiedProps[TRACEPARENT_PROPERTY] = traceParent;\n    }\n\n    return {\n      event: eventData,\n      spanContext: updatedOptions.tracingOptions?.tracingContext,\n    };\n  } finally {\n    messageSpan.end();\n  }\n}\n\n/**\n * Extracts the `SpanContext` from an `EventData` if the context exists.\n * @param eventData - An individual `EventData` object.\n * @internal\n */\nexport function extractSpanContextFromEventData(eventData: EventData): TracingContext | undefined {\n  if (!eventData.properties || !eventData.properties[TRACEPARENT_PROPERTY]) {\n    return;\n  }\n\n  const diagnosticId = eventData.properties[TRACEPARENT_PROPERTY];\n  return tracingClient.parseTraceparentHeader(diagnosticId);\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { TracingSpanOptions, TracingSpanLink } from \"@azure/core-tracing\";\nimport { logErrorStackTrace, logger } from \"./logger\";\nimport { AbortController } from \"@azure/abort-controller\";\nimport { CloseReason } from \"./models/public\";\nimport { CommonEventProcessorOptions } from \"./models/private\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { EventHubConnectionConfig } from \"./eventhubConnectionConfig\";\nimport { createReceiver, PartitionReceiver } from \"./partitionReceiver\";\nimport { EventPosition } from \"./eventPosition\";\nimport { MessagingError } from \"@azure/core-amqp\";\nimport { PartitionProcessor } from \"./partitionProcessor\";\nimport { ReceivedEventData } from \"./eventData\";\nimport { toSpanOptions, tracingClient } from \"./diagnostics/tracing\";\nimport { extractSpanContextFromEventData } from \"./diagnostics/instrumentEventData\";\n\n/**\n * @internal\n */\nexport class PartitionPump {\n  private _partitionProcessor: PartitionProcessor;\n  private _processorOptions: CommonEventProcessorOptions;\n  private _receiver: PartitionReceiver | undefined;\n  private _isReceiving: boolean = false;\n  private _isStopped: boolean = false;\n  private _abortController: AbortController;\n  constructor(\n    private _context: ConnectionContext,\n    partitionProcessor: PartitionProcessor,\n    private readonly _startPosition: EventPosition,\n    options: CommonEventProcessorOptions\n  ) {\n    this._partitionProcessor = partitionProcessor;\n    this._processorOptions = options;\n    this._abortController = new AbortController();\n  }\n\n  public get isReceiving(): boolean {\n    return this._isReceiving;\n  }\n\n  async start(): Promise<void> {\n    this._isReceiving = true;\n    try {\n      await this._partitionProcessor.initialize();\n    } catch (err) {\n      // swallow the error from the user-defined code\n      this._partitionProcessor.processError(err as Error);\n    }\n\n    // this is intentionally not await'd - the _receiveEvents loop will continue to\n    // execute and can be stopped by calling .stop()\n    this._receiveEvents(this._partitionProcessor.partitionId);\n    logger.info(\n      `Successfully started the receiver for partition \"${this._partitionProcessor.partitionId}\".`\n    );\n  }\n\n  /**\n   * Creates a new `PartitionReceiver` and replaces any existing receiver.\n   * @param partitionId - The partition the receiver should read messages from.\n   * @param lastSeenSequenceNumber - The sequence number to begin receiving messages from (exclusive).\n   * If `-1`, then the PartitionPump's startPosition will be used instead.\n   */\n  private _setOrReplaceReceiver(\n    partitionId: string,\n    lastSeenSequenceNumber: number\n  ): PartitionReceiver {\n    // Determine what the new EventPosition should be.\n    // If this PartitionPump has received events, we'll start from the last\n    // seen sequenceNumber (exclusive).\n    // Otherwise, use the `_startPosition`.\n    const currentEventPosition: EventPosition =\n      lastSeenSequenceNumber >= 0\n        ? {\n            sequenceNumber: lastSeenSequenceNumber,\n            isInclusive: false,\n          }\n        : this._startPosition;\n\n    // Set or replace the PartitionPump's receiver.\n    this._receiver = createReceiver(\n      this._context,\n      this._partitionProcessor.consumerGroup,\n      partitionId,\n      currentEventPosition,\n      {\n        ownerLevel: this._processorOptions.ownerLevel,\n        trackLastEnqueuedEventProperties: this._processorOptions.trackLastEnqueuedEventProperties,\n        retryOptions: this._processorOptions.retryOptions,\n        skipParsingBodyAsJson: this._processorOptions.skipParsingBodyAsJson,\n      }\n    );\n\n    return this._receiver;\n  }\n\n  private async _receiveEvents(partitionId: string): Promise<void> {\n    let lastSeenSequenceNumber = -1;\n    let receiver = this._setOrReplaceReceiver(partitionId, lastSeenSequenceNumber);\n\n    while (this._isReceiving) {\n      try {\n        // Check if the receiver was closed so we can recreate it.\n        if (receiver.isClosed) {\n          receiver = this._setOrReplaceReceiver(partitionId, lastSeenSequenceNumber);\n        }\n\n        const receivedEvents = await receiver.receiveBatch(\n          this._processorOptions.maxBatchSize,\n          this._processorOptions.maxWaitTimeInSeconds,\n          this._abortController.signal\n        );\n\n        if (\n          this._processorOptions.trackLastEnqueuedEventProperties &&\n          receiver.lastEnqueuedEventProperties\n        ) {\n          this._partitionProcessor.lastEnqueuedEventProperties =\n            receiver.lastEnqueuedEventProperties;\n        }\n        // avoid calling user's processEvents handler if the pump was stopped while receiving events\n        if (!this._isReceiving) {\n          return;\n        }\n\n        if (receivedEvents.length) {\n          lastSeenSequenceNumber = receivedEvents[receivedEvents.length - 1].sequenceNumber;\n        }\n\n        await tracingClient.withSpan(\n          \"PartitionPump.process\",\n          {},\n          () => this._partitionProcessor.processEvents(receivedEvents),\n          toProcessingSpanOptions(receivedEvents, this._context.config)\n        );\n      } catch (err: any) {\n        // check if this pump is still receiving\n        // it may not be if the EventProcessor was stopped during processEvents\n        if (!this._isReceiving) {\n          // no longer receiving, so close was called from somewhere else\n          return;\n        }\n\n        logger.warning(\n          `An error was thrown while receiving or processing events on partition \"${this._partitionProcessor.partitionId}\"`\n        );\n        logErrorStackTrace(err);\n        // forward error to user's processError and swallow errors they may throw\n        try {\n          await this._partitionProcessor.processError(err as Error);\n        } catch (errorFromUser) {\n          // Using verbose over warning because this error is swallowed.\n          logger.verbose(\"An error was thrown by user's processError method: \", errorFromUser);\n        }\n\n        // close the partition processor if a non-retryable error was encountered\n        if (typeof err !== \"object\" || !(err as MessagingError).retryable) {\n          try {\n            // If the exception indicates that the partition was stolen (i.e some other consumer with same ownerlevel\n            // started consuming the partition), update the closeReason\n            if (err.code === \"ReceiverDisconnectedError\") {\n              return await this.stop(CloseReason.OwnershipLost);\n            }\n            // this will close the pump and will break us out of the while loop\n            return await this.stop(CloseReason.Shutdown);\n          } catch (errorFromStop) {\n            // Using verbose over warning because this error is swallowed.\n            logger.verbose(\n              `An error occurred while closing the receiver with reason ${CloseReason.Shutdown}: `,\n              errorFromStop\n            );\n          }\n        }\n      }\n    }\n  }\n\n  async stop(reason: CloseReason): Promise<void> {\n    if (this._isStopped) {\n      return;\n    }\n    this._isStopped = true;\n    this._isReceiving = false;\n    try {\n      // Trigger the cancellation before closing the receiver,\n      // otherwise the receiver will remove the listener on the abortSignal\n      // before it has a chance to be emitted.\n      this._abortController.abort();\n      await this._receiver?.close();\n      await this._partitionProcessor.close(reason);\n    } catch (err: any) {\n      logger.warning(`An error occurred while closing the receiver: ${err?.name}: ${err?.message}`);\n      logErrorStackTrace(err);\n      this._partitionProcessor.processError(err);\n      throw err;\n    }\n  }\n}\n\n/**\n * @internal\n */\nexport function toProcessingSpanOptions(\n  receivedEvents: ReceivedEventData[],\n  eventHubProperties: Pick<EventHubConnectionConfig, \"entityPath\" | \"host\">\n): TracingSpanOptions {\n  const spanLinks: TracingSpanLink[] = [];\n  for (const receivedEvent of receivedEvents) {\n    const tracingContext = extractSpanContextFromEventData(receivedEvent);\n    if (tracingContext) {\n      spanLinks.push({\n        tracingContext,\n        attributes: {\n          enqueuedTime: receivedEvent.enqueuedTimeUtc.getTime(),\n        },\n      });\n    }\n  }\n  return {\n    spanLinks,\n    spanKind: \"consumer\",\n    ...toSpanOptions(eventHubProperties, \"process\"),\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { logErrorStackTrace, logger } from \"./logger\";\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { CloseReason } from \"./models/public\";\nimport { CommonEventProcessorOptions } from \"./models/private\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { EventPosition } from \"./eventPosition\";\nimport { PartitionProcessor } from \"./partitionProcessor\";\nimport { PartitionPump } from \"./partitionPump\";\n\n/**\n * The PumpManager handles the creation and removal of PartitionPumps.\n * It also starts a PartitionPump when it is created, and stops a\n * PartitionPump when it is removed.\n * @internal\n */\nexport interface PumpManager {\n  /**\n   * Creates and starts a PartitionPump.\n   * @param startPosition - The position in the partition to start reading from.\n   * @param eventHubClient - The EventHubClient to forward to the PartitionPump.\n   * @param partitionProcessor - The PartitionProcessor to forward to the PartitionPump.\n   * @param abortSignal - Used to cancel pump creation.\n   */\n  createPump(\n    startPosition: EventPosition,\n    connectionContext: ConnectionContext,\n    partitionProcessor: PartitionProcessor,\n    abortSignal: AbortSignalLike\n  ): Promise<void>;\n\n  /**\n   * Indicates whether the pump manager is actively receiving events from a given partition.\n   * @param partitionId - The partition to check.\n   */\n  isReceivingFromPartition(partitionId: string): boolean;\n\n  /**\n   * Stops all PartitionPumps and removes them from the internal map.\n   * @param reason - The reason for removing the pump.\n   */\n  removeAllPumps(reason: CloseReason): Promise<void>;\n}\n\n/**\n * The PumpManager handles the creation and removal of PartitionPumps.\n * It also starts a PartitionPump when it is created, and stops a\n * PartitionPump when it is removed.\n * @internal\n */\nexport class PumpManagerImpl implements PumpManager {\n  private readonly _eventProcessorName: string;\n  private readonly _options: CommonEventProcessorOptions;\n  private _partitionIdToPumps: {\n    [partitionId: string]: PartitionPump | undefined;\n  } = {};\n\n  constructor(eventProcessorName: string, eventProcessorOptions: CommonEventProcessorOptions) {\n    this._eventProcessorName = eventProcessorName;\n    this._options = eventProcessorOptions;\n  }\n\n  /**\n   * Returns a list of partitionIds that are actively receiving messages.\n   */\n  public receivingFromPartitions(): string[] {\n    return Object.keys(this._partitionIdToPumps).filter((id) => {\n      const pump = this._partitionIdToPumps[id];\n      return Boolean(pump && pump.isReceiving);\n    });\n  }\n\n  /**\n   * Indicates whether the pump manager is actively receiving events from a given partition.\n   * @internal\n   */\n  public isReceivingFromPartition(partitionId: string): boolean {\n    const pump = this._partitionIdToPumps[partitionId];\n    return Boolean(pump && pump.isReceiving);\n  }\n\n  /**\n   * Creates and starts a PartitionPump.\n   * @param startPosition - The position in the partition to start reading from.\n   * @param connectionContext - The ConnectionContext to forward to the PartitionPump.\n   * @param partitionProcessor - The PartitionProcessor to forward to the PartitionPump.\n   */\n  public async createPump(\n    startPosition: EventPosition,\n    connectionContext: ConnectionContext,\n    partitionProcessor: PartitionProcessor,\n    abortSignal: AbortSignalLike\n  ): Promise<void> {\n    const partitionId = partitionProcessor.partitionId;\n    if (abortSignal.aborted) {\n      logger.verbose(\n        `${this._eventProcessorName}] The subscription was closed before creating the pump for partition ${partitionId}.`\n      );\n      return;\n    }\n    // attempt to get an existing pump\n    const existingPump = this._partitionIdToPumps[partitionId];\n    if (existingPump) {\n      if (existingPump.isReceiving) {\n        logger.verbose(\n          `[${this._eventProcessorName}] [${partitionId}] The existing pump is running.`\n        );\n        return;\n      }\n      logger.verbose(\n        `[${this._eventProcessorName}] [${partitionId}] The existing pump is not running.`\n      );\n      await this.removePump(partitionId, CloseReason.OwnershipLost);\n    }\n\n    logger.verbose(`[${this._eventProcessorName}] [${partitionId}] Creating a new pump.`);\n\n    const pump = new PartitionPump(\n      connectionContext,\n      partitionProcessor,\n      startPosition,\n      this._options\n    );\n\n    try {\n      // Set the pump before starting it in case the user\n      // closes the subscription while `start()` is in progress.\n      this._partitionIdToPumps[partitionId] = pump;\n      await pump.start();\n    } catch (err: any) {\n      logger.verbose(\n        `[${this._eventProcessorName}] [${partitionId}] An error occured while adding/updating a pump: ${err}`\n      );\n      logErrorStackTrace(err);\n    }\n  }\n\n  /**\n   * Stop a PartitionPump and removes it from the internal map.\n   * @param partitionId - The partitionId to remove the associated PartitionPump from.\n   * @param reason - The reason for removing the pump.\n   */\n  public async removePump(partitionId: string, reason: CloseReason): Promise<void> {\n    try {\n      const pump = this._partitionIdToPumps[partitionId];\n      if (pump) {\n        delete this._partitionIdToPumps[partitionId];\n        logger.verbose(`[${this._eventProcessorName}] [${partitionId}] Stopping the pump.`);\n        await pump.stop(reason);\n      } else {\n        logger.verbose(\n          `[${this._eventProcessorName}] [${partitionId}] No pump was found to remove.`\n        );\n      }\n    } catch (err: any) {\n      logger.verbose(\n        `[${this._eventProcessorName}] [${partitionId}] An error occured while removing a pump: ${err}`\n      );\n      logErrorStackTrace(err);\n    }\n  }\n\n  /**\n   * Stops all PartitionPumps and removes them from the internal map.\n   * @param reason - The reason for removing the pump.\n   */\n  public async removeAllPumps(reason: CloseReason): Promise<void> {\n    const partitionIds = Object.keys(this._partitionIdToPumps);\n\n    logger.verbose(`[${this._eventProcessorName}] Removing all pumps due to reason ${reason}.`);\n\n    const tasks: PromiseLike<void>[] = [];\n    for (const partitionId of partitionIds) {\n      const pump = this._partitionIdToPumps[partitionId];\n      if (pump) {\n        tasks.push(pump.stop(reason));\n      }\n    }\n\n    try {\n      await Promise.all(tasks);\n    } catch (err: any) {\n      logger.verbose(\n        `[${this._eventProcessorName}] An error occured while removing all pumps: ${err}`\n      );\n      logErrorStackTrace(err);\n    } finally {\n      this._partitionIdToPumps = {};\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { delay } from \"@azure/core-amqp\";\n\n/**\n * @param delayInMs - The number of milliseconds to be delayed.\n * @param abortSignal - The abortSignal associated with the containing operation.\n * @internal\n */\nexport async function delayWithoutThrow(\n  delayInMs: number,\n  abortSignal?: AbortSignalLike\n): Promise<void> {\n  try {\n    await delay(delayInMs, abortSignal);\n  } catch {\n    /* no-op to swallow AbortError */\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortController, AbortError, AbortSignalLike } from \"@azure/abort-controller\";\nimport { Checkpoint, PartitionProcessor } from \"./partitionProcessor\";\nimport { EventPosition, isEventPosition, latestEventPosition } from \"./eventPosition\";\nimport { PumpManager, PumpManagerImpl } from \"./pumpManager\";\nimport { logErrorStackTrace, logger } from \"./logger\";\nimport { CloseReason } from \"./models/public\";\nimport { CommonEventProcessorOptions } from \"./models/private\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { LoadBalancingStrategy } from \"./loadBalancerStrategies/loadBalancingStrategy\";\nimport { OperationOptions } from \"./util/operationOptions\";\nimport { SubscriptionEventHandlers } from \"./eventHubConsumerClientModels\";\nimport { delayWithoutThrow } from \"./util/delayWithoutThrow\";\nimport { getRandomName } from \"./util/utils\";\n\n/**\n * An interface representing the details on which instance of a `EventProcessor` owns processing\n * of a given partition from a consumer group of an Event Hub instance.\n *\n * **Note**: This is used internally by the `EventProcessor` and user never has to create it directly.\n */\nexport interface PartitionOwnership {\n  /**\n   * The fully qualified Event Hubs namespace. This is likely to be similar to\n   * <yournamespace>.servicebus.windows.net\n   */\n  fullyQualifiedNamespace: string;\n  /**\n   * The event hub name\n   */\n  eventHubName: string;\n  /**\n   * The consumer group name\n   */\n  consumerGroup: string;\n  /**\n   * The identifier of the Event Hub partition.\n   */\n  partitionId: string;\n  /**\n   * The unique identifier of the event processor.\n   */\n  ownerId: string;\n  /**\n   * The last modified time.\n   */\n  lastModifiedTimeInMs?: number;\n  /**\n   * The unique identifier for the operation.\n   */\n  etag?: string;\n}\n\n/**\n * A checkpoint store stores and retrieves partition ownership information and checkpoint details\n * for each partition in a given consumer group of an event hub instance.\n *\n * Users are not meant to implement an `CheckpointStore`.\n * Users are expected to choose existing implementations of this interface, instantiate it, and pass\n * it to the `EventHubConsumerClient` class constructor when instantiating a client.\n * Users are not expected to use any of the methods on a checkpoint store, these are used internally by\n * the client.\n *\n * Implementations of `CheckpointStore` can be found on npm by searching for packages with the prefix &commat;azure/eventhub-checkpointstore-.\n */\nexport interface CheckpointStore {\n  /**\n   * Called to get the list of all existing partition ownership from the underlying data store. Could return empty\n   * results if there are is no existing ownership information.\n   *\n   * @param fullyQualifiedNamespace - The fully qualified Event Hubs namespace. This is likely to be similar to\n   * <yournamespace>.servicebus.windows.net.\n   * @param eventHubName - The event hub name.\n   * @param consumerGroup - The consumer group name.\n   * @param options - A set of options that can be specified to influence the behavior of this method.\n   *  - `abortSignal`: A signal used to request operation cancellation.\n   *  - `tracingOptions`: Options for configuring tracing.\n   * @returns A list of partition ownership details of all the partitions that have/had an owner.\n   */\n  listOwnership(\n    fullyQualifiedNamespace: string,\n    eventHubName: string,\n    consumerGroup: string,\n    options?: OperationOptions\n  ): Promise<PartitionOwnership[]>;\n  /**\n   * Called to claim ownership of a list of partitions. This will return the list of partitions that were owned\n   * successfully.\n   *\n   * @param partitionOwnership - The list of partition ownership this instance is claiming to own.\n   * @param options - A set of options that can be specified to influence the behavior of this method.\n   *  - `abortSignal`: A signal used to request operation cancellation.\n   *  - `tracingOptions`: Options for configuring tracing.\n   * @returns A list of partitions this instance successfully claimed ownership.\n   */\n  claimOwnership(\n    partitionOwnership: PartitionOwnership[],\n    options?: OperationOptions\n  ): Promise<PartitionOwnership[]>;\n\n  /**\n   * Updates the checkpoint in the data store for a partition.\n   *\n   * @param checkpoint - The checkpoint.\n   * @param options - A set of options that can be specified to influence the behavior of this method.\n   *  - `abortSignal`: A signal used to request operation cancellation.\n   *  - `tracingOptions`: Options for configuring tracing.\n   */\n  updateCheckpoint(checkpoint: Checkpoint, options?: OperationOptions): Promise<void>;\n\n  /**\n   * Lists all the checkpoints in a data store for a given namespace, eventhub and consumer group.\n   *\n   * @param fullyQualifiedNamespace - The fully qualified Event Hubs namespace. This is likely to be similar to\n   * <yournamespace>.servicebus.windows.net.\n   * @param eventHubName - The event hub name.\n   * @param consumerGroup - The consumer group name.\n   * @param options - A set of options that can be specified to influence the behavior of this method.\n   *  - `abortSignal`: A signal used to request operation cancellation.\n   *  - `tracingOptions`: Options for configuring tracing.\n   * @returns A list of checkpoints for a given namespace, eventhub, and consumer group.\n   */\n  listCheckpoints(\n    fullyQualifiedNamespace: string,\n    eventHubName: string,\n    consumerGroup: string,\n    options?: OperationOptions\n  ): Promise<Checkpoint[]>;\n}\n\n/**\n * A set of options to pass to the constructor of `EventProcessor`.\n * You can specify\n * - `maxBatchSize`: The max size of the batch of events passed each time to user code for processing.\n * - `maxWaitTimeInSeconds`: The maximum amount of time to wait to build up the requested message count before\n * passing the data to user code for processing. If not provided, it defaults to 60 seconds.\n *\n * Example usage with default values:\n * ```ts\n * {\n *     maxBatchSize: 1,\n *     maxWaitTimeInSeconds: 60,\n * }\n * ```\n * @internal\n */\nexport interface FullEventProcessorOptions extends CommonEventProcessorOptions {\n  /**\n   * An optional pump manager to use, rather than instantiating one internally\n   * @internal\n   */\n  pumpManager?: PumpManager;\n  /**\n   * The amount of time between load balancing attempts.\n   */\n  loopIntervalInMs: number;\n  /**\n   * A specific partition to target.\n   */\n  processingTarget?: string;\n}\n\n/**\n * Event Processor based applications consist of one or more instances of EventProcessor which have been\n * configured to consume events from the same Event Hub and consumer group. They balance the\n * workload across different instances by distributing the partitions to be processed among themselves.\n * They also allow the user to track progress when events are processed using checkpoints.\n *\n * A checkpoint is meant to represent the last successfully processed event by the user from a particular\n * partition of a consumer group in an Event Hub instance.\n *\n * @internal\n */\nexport class EventProcessor {\n  private _processorOptions: FullEventProcessorOptions;\n  private _pumpManager: PumpManager;\n  private _id: string;\n  private _isRunning: boolean = false;\n  private _loopTask?: PromiseLike<void>;\n  private _abortController?: AbortController;\n  /**\n   * A specific partition to target.\n   */\n  private _processingTarget?: string;\n  /**\n   * Determines which partitions to claim as part of load balancing.\n   */\n  private _loadBalancingStrategy: LoadBalancingStrategy;\n  /**\n   * The amount of time between load balancing attempts.\n   */\n  private _loopIntervalInMs: number;\n  private _eventHubName: string;\n  private _fullyQualifiedNamespace: string;\n\n  /**\n   * @param consumerGroup - The name of the consumer group from which you want to process events.\n   * @param eventHubClient - An instance of `EventHubClient` that was created for the Event Hub instance.\n   * @param PartitionProcessorClass - A user-provided class that extends the `PartitionProcessor` class.\n   * This class will be responsible for processing and checkpointing events.\n   * @param checkpointStore - An instance of `CheckpointStore`. See &commat;azure/eventhubs-checkpointstore-blob for an implementation.\n   * For production, choose an implementation that will store checkpoints and partition ownership details to a durable store.\n   * @param options - A set of options to configure the Event Processor\n   * - `maxBatchSize`         : The max size of the batch of events passed each time to user code for processing.\n   * - `maxWaitTimeInSeconds` : The maximum amount of time to wait to build up the requested message count before\n   * passing the data to user code for processing. If not provided, it defaults to 60 seconds.\n   */\n  constructor(\n    private _consumerGroup: string,\n    private _context: ConnectionContext,\n    private _subscriptionEventHandlers: SubscriptionEventHandlers,\n    private _checkpointStore: CheckpointStore,\n    options: FullEventProcessorOptions\n  ) {\n    if (options.ownerId) {\n      this._id = options.ownerId;\n      logger.verbose(`Starting event processor with ID ${this._id}`);\n    } else {\n      this._id = getRandomName();\n      logger.verbose(`Starting event processor with autogenerated ID ${this._id}`);\n    }\n\n    this._eventHubName = this._context.config.entityPath;\n    this._fullyQualifiedNamespace = this._context.config.host;\n    this._processorOptions = options;\n    this._pumpManager =\n      options.pumpManager || new PumpManagerImpl(this._id, this._processorOptions);\n    this._processingTarget = options.processingTarget;\n    this._loopIntervalInMs = options.loopIntervalInMs;\n    this._loadBalancingStrategy = options.loadBalancingStrategy;\n  }\n\n  /**\n   * The unique identifier for the EventProcessor.\n   */\n  get id(): string {\n    return this._id;\n  }\n\n  private _createPartitionOwnershipRequest(\n    partitionOwnershipMap: Map<string, PartitionOwnership>,\n    partitionIdToClaim: string\n  ): PartitionOwnership {\n    const previousPartitionOwnership = partitionOwnershipMap.get(partitionIdToClaim);\n    const partitionOwnership: PartitionOwnership = {\n      ownerId: this._id,\n      partitionId: partitionIdToClaim,\n      fullyQualifiedNamespace: this._fullyQualifiedNamespace,\n      consumerGroup: this._consumerGroup,\n      eventHubName: this._eventHubName,\n      etag: previousPartitionOwnership ? previousPartitionOwnership.etag : undefined,\n    };\n\n    return partitionOwnership;\n  }\n\n  /*\n   * Claim ownership of the given partition if it's available\n   */\n  private async _claimOwnership(\n    ownershipRequest: PartitionOwnership,\n    abortSignal: AbortSignalLike\n  ): Promise<void> {\n    if (abortSignal.aborted) {\n      logger.verbose(\n        `[${this._id}] Subscription was closed before claiming ownership of ${ownershipRequest.partitionId}.`\n      );\n      return;\n    }\n    logger.info(\n      `[${this._id}] Attempting to claim ownership of partition ${ownershipRequest.partitionId}.`\n    );\n    try {\n      const claimedOwnerships = await this._checkpointStore.claimOwnership([ownershipRequest]);\n\n      // can happen if the partition was claimed out from underneath us - we shouldn't\n      // attempt to spin up a processor.\n      if (!claimedOwnerships.length) {\n        return;\n      }\n\n      logger.info(\n        `[${this._id}] Successfully claimed ownership of partition ${ownershipRequest.partitionId}.`\n      );\n\n      await this._startPump(ownershipRequest.partitionId, abortSignal);\n    } catch (err: any) {\n      logger.warning(\n        `[${this.id}] Failed to claim ownership of partition ${ownershipRequest.partitionId}`\n      );\n      logErrorStackTrace(err);\n      await this._handleSubscriptionError(err);\n    }\n  }\n\n  private async _startPump(partitionId: string, abortSignal: AbortSignalLike): Promise<void> {\n    if (abortSignal.aborted) {\n      logger.verbose(\n        `[${this._id}] The subscription was closed before starting to read from ${partitionId}.`\n      );\n      return;\n    }\n\n    if (this._pumpManager.isReceivingFromPartition(partitionId)) {\n      logger.verbose(\n        `[${this._id}] There is already an active partitionPump for partition \"${partitionId}\", skipping pump creation.`\n      );\n      return;\n    }\n\n    logger.verbose(\n      `[${this._id}] [${partitionId}] Calling user-provided PartitionProcessorFactory.`\n    );\n\n    const partitionProcessor = new PartitionProcessor(\n      this._subscriptionEventHandlers,\n      this._checkpointStore,\n      {\n        fullyQualifiedNamespace: this._fullyQualifiedNamespace,\n        eventHubName: this._eventHubName,\n        consumerGroup: this._consumerGroup,\n        partitionId: partitionId,\n        eventProcessorId: this.id,\n      }\n    );\n\n    const eventPosition = await this._getStartingPosition(partitionId);\n    await this._pumpManager.createPump(\n      eventPosition,\n      this._context,\n      partitionProcessor,\n      abortSignal\n    );\n\n    logger.verbose(`[${this._id}] PartitionPump created successfully.`);\n  }\n\n  private async _getStartingPosition(partitionIdToClaim: string): Promise<EventPosition> {\n    const availableCheckpoints = await this._checkpointStore.listCheckpoints(\n      this._fullyQualifiedNamespace,\n      this._eventHubName,\n      this._consumerGroup\n    );\n\n    const validCheckpoints = availableCheckpoints.filter(\n      (chk) => chk.partitionId === partitionIdToClaim\n    );\n\n    if (validCheckpoints.length > 0) {\n      return { offset: validCheckpoints[0].offset };\n    }\n\n    logger.verbose(\n      `No checkpoint found for partition ${partitionIdToClaim}. Looking for fallback.`\n    );\n    return getStartPosition(partitionIdToClaim, this._processorOptions.startPosition);\n  }\n\n  private async _runLoopForSinglePartition(\n    partitionId: string,\n    abortSignal: AbortSignalLike\n  ): Promise<void> {\n    while (!abortSignal.aborted) {\n      try {\n        await this._startPump(partitionId, abortSignal);\n      } catch (err: any) {\n        logger.warning(\n          `[${this._id}] An error occured within the EventProcessor loop: ${err?.name}: ${err?.message}`\n        );\n        logErrorStackTrace(err);\n        await this._handleSubscriptionError(err);\n      } finally {\n        // sleep for some time after which we can attempt to create a pump again.\n        logger.verbose(\n          `[${this._id}] Pausing the EventProcessor loop for ${this._loopIntervalInMs} ms.`\n        );\n        // swallow errors from delay since it's fine for delay to exit early\n        await delayWithoutThrow(this._loopIntervalInMs, abortSignal);\n      }\n    }\n    this._isRunning = false;\n  }\n\n  /**\n   * Every loop to this method will result in this EventProcessor owning at most one new partition.\n   *\n   * The load is considered balanced when no active EventProcessor owns 2 partitions more than any other active\n   * EventProcessor. Given that each invocation to this method results in ownership claim of at most one partition,\n   * this algorithm converges gradually towards a steady state.\n   *\n   * When a new partition is claimed, this method is also responsible for starting a partition pump that creates an\n   * EventHubConsumer for processing events from that partition.\n   */\n  private async _runLoopWithLoadBalancing(\n    loadBalancingStrategy: LoadBalancingStrategy,\n    abortSignal: AbortSignalLike\n  ): Promise<void> {\n    let cancelLoopResolver;\n    // This provides a mechanism for exiting the loop early\n    // if the subscription has had `close` called.\n    const cancelLoopPromise = new Promise<void>((resolve) => {\n      cancelLoopResolver = resolve;\n      if (abortSignal.aborted) {\n        resolve();\n        return;\n      }\n\n      abortSignal.addEventListener(\"abort\", resolve);\n    });\n\n    // Periodically check if any partitions need to be claimed and claim them.\n    while (!abortSignal.aborted) {\n      const iterationStartTimeInMs = Date.now();\n      try {\n        const { partitionIds } = await this._context.managementSession!.getEventHubProperties({\n          abortSignal: abortSignal,\n        });\n        await this._performLoadBalancing(loadBalancingStrategy, partitionIds, abortSignal);\n      } catch (err: any) {\n        logger.warning(\n          `[${this._id}] An error occurred within the EventProcessor loop: ${err?.name}: ${err?.message}`\n        );\n        logErrorStackTrace(err);\n        // Protect against the scenario where the user awaits on subscription.close() from inside processError.\n        await Promise.race([this._handleSubscriptionError(err), cancelLoopPromise]);\n      } finally {\n        // Sleep for some time, then continue the loop.\n        const iterationDeltaInMs = Date.now() - iterationStartTimeInMs;\n        const delayDurationInMs = Math.max(this._loopIntervalInMs - iterationDeltaInMs, 0);\n        logger.verbose(\n          `[${this._id}] Pausing the EventProcessor loop for ${delayDurationInMs} ms.`\n        );\n        // Swallow the error since it's fine to exit early from the delay.\n        await delayWithoutThrow(delayDurationInMs, abortSignal);\n      }\n    }\n\n    if (cancelLoopResolver) {\n      abortSignal.removeEventListener(\"abort\", cancelLoopResolver);\n    }\n    this._isRunning = false;\n  }\n\n  private async _performLoadBalancing(\n    loadBalancingStrategy: LoadBalancingStrategy,\n    partitionIds: string[],\n    abortSignal: AbortSignalLike\n  ): Promise<void> {\n    if (abortSignal.aborted) throw new AbortError(\"The operation was aborted.\");\n\n    // Retrieve current partition ownership details from the datastore.\n    const partitionOwnership = await this._checkpointStore.listOwnership(\n      this._fullyQualifiedNamespace,\n      this._eventHubName,\n      this._consumerGroup\n    );\n\n    if (abortSignal.aborted) throw new AbortError(\"The operation was aborted.\");\n\n    const { partitionOwnershipMap, partitionsToClaim } = computePartitionsToClaim({\n      id: this._id,\n      isReceivingFromPartition: (partitionId: string) =>\n        this._pumpManager.isReceivingFromPartition(partitionId),\n      loadBalancingStrategy,\n      partitionIds,\n      partitionOwnership,\n    });\n\n    for (const partitionToClaim of partitionsToClaim) {\n      const partitionOwnershipRequest = this._createPartitionOwnershipRequest(\n        partitionOwnershipMap,\n        partitionToClaim\n      );\n\n      await this._claimOwnership(partitionOwnershipRequest, abortSignal);\n    }\n  }\n\n  /**\n   * This is called when there are errors that are not specific to a partition (ex: load balancing)\n   */\n  private async _handleSubscriptionError(err: Error): Promise<void> {\n    // filter out any internal \"expected\" errors\n    if (err.name === \"AbortError\") {\n      return;\n    }\n\n    if (this._subscriptionEventHandlers.processError) {\n      try {\n        await this._subscriptionEventHandlers.processError(err, {\n          fullyQualifiedNamespace: this._fullyQualifiedNamespace,\n          eventHubName: this._eventHubName,\n          consumerGroup: this._consumerGroup,\n          partitionId: \"\",\n          updateCheckpoint: async () => {\n            /* no-op */\n          },\n        });\n      } catch (errorFromUser: any) {\n        logger.verbose(\n          `[${this._id}] An error was thrown from the user's processError handler: ${errorFromUser}`\n        );\n      }\n    }\n  }\n\n  /**\n   * Starts the `EventProcessor`. Based on the number of instances of `EventProcessor` that are running for the\n   * same consumer group, the partitions are distributed among these instances to process events.\n   *\n   * For each partition, the user provided `PartitionProcessor` is instantiated.\n   *\n   * Subsequent calls to start will be ignored if this event processor is already running.\n   * Calling `start()` after `stop()` is called will restart this event processor.\n   *\n   */\n  start(): void {\n    if (this._isRunning) {\n      logger.verbose(`[${this._id}] Attempted to start an already running EventProcessor.`);\n      return;\n    }\n\n    this._isRunning = true;\n    this._abortController = new AbortController();\n    logger.verbose(`[${this._id}] Starting an EventProcessor.`);\n\n    if (this._processingTarget) {\n      logger.verbose(`[${this._id}] Single partition target: ${this._processingTarget}`);\n      this._loopTask = this._runLoopForSinglePartition(\n        this._processingTarget,\n        this._abortController.signal\n      );\n    } else {\n      logger.verbose(`[${this._id}] Multiple partitions, using load balancer`);\n      this._loopTask = this._runLoopWithLoadBalancing(\n        this._loadBalancingStrategy,\n        this._abortController.signal\n      );\n    }\n  }\n\n  isRunning(): boolean {\n    return this._isRunning;\n  }\n\n  /**\n   * Stops processing events for all partitions owned by this event processor.\n   * All `PartitionProcessor` will be shutdown and any open resources will be closed.\n   *\n   * Subsequent calls to stop will be ignored if the event processor is not running.\n   *\n   */\n  async stop(): Promise<void> {\n    logger.verbose(`[${this._id}] Stopping an EventProcessor.`);\n    if (this._abortController) {\n      // cancel the event processor loop\n      this._abortController.abort();\n    }\n\n    try {\n      // remove all existing pumps\n      await this._pumpManager.removeAllPumps(CloseReason.Shutdown);\n\n      // waits for the event processor loop to complete\n      // will complete immediately if _loopTask is undefined\n      if (this._loopTask) {\n        await this._loopTask;\n      }\n    } catch (err: any) {\n      logger.verbose(`[${this._id}] An error occured while stopping the EventProcessor: ${err}`);\n    } finally {\n      logger.verbose(`[${this._id}] EventProcessor stopped.`);\n    }\n\n    if (this._processingTarget) {\n      logger.verbose(`[${this._id}] No partitions owned, skipping abandoning.`);\n    } else {\n      await this.abandonPartitionOwnerships();\n    }\n  }\n\n  private async abandonPartitionOwnerships(): Promise<PartitionOwnership[]> {\n    logger.verbose(`[${this._id}] Abandoning owned partitions`);\n    const allOwnerships = await this._checkpointStore.listOwnership(\n      this._fullyQualifiedNamespace,\n      this._eventHubName,\n      this._consumerGroup\n    );\n    const ourOwnerships = allOwnerships.filter((ownership) => ownership.ownerId === this._id);\n    // unclaim any partitions that we currently own\n    for (const ownership of ourOwnerships) {\n      ownership.ownerId = \"\";\n    }\n    return this._checkpointStore.claimOwnership(ourOwnerships);\n  }\n}\n\nfunction isAbandoned(ownership: PartitionOwnership): boolean {\n  return ownership.ownerId === \"\";\n}\n\nfunction getStartPosition(\n  partitionIdToClaim: string,\n  startPositions?: EventPosition | { [partitionId: string]: EventPosition }\n): EventPosition {\n  if (startPositions == null) {\n    return latestEventPosition;\n  }\n\n  if (isEventPosition(startPositions)) {\n    return startPositions;\n  }\n\n  const startPosition = (startPositions as { [partitionId: string]: EventPosition })[\n    partitionIdToClaim\n  ];\n\n  if (startPosition == null) {\n    return latestEventPosition;\n  }\n\n  return startPosition;\n}\n\nfunction computePartitionsToClaim(inputs: {\n  partitionOwnership: PartitionOwnership[];\n  id: string;\n  isReceivingFromPartition: (id: string) => boolean;\n  loadBalancingStrategy: LoadBalancingStrategy;\n  partitionIds: string[];\n}): {\n  partitionsToClaim: Set<string>;\n  partitionOwnershipMap: Map<string, PartitionOwnership>;\n} {\n  const { partitionOwnership, id, isReceivingFromPartition, loadBalancingStrategy, partitionIds } =\n    inputs;\n\n  const partitionOwnershipMap = new Map<string, PartitionOwnership>();\n  const nonAbandonedPartitionOwnershipMap = new Map<string, PartitionOwnership>();\n  const partitionsToRenew: string[] = [];\n\n  // Separate abandoned ownerships from claimed ownerships.\n  // We only want to pass active partition ownerships to the\n  // load balancer, but we need to hold onto the abandoned\n  // partition ownerships because we need the etag to claim them.\n  for (const ownership of partitionOwnership) {\n    partitionOwnershipMap.set(ownership.partitionId, ownership);\n    if (!isAbandoned(ownership)) {\n      nonAbandonedPartitionOwnershipMap.set(ownership.partitionId, ownership);\n    }\n    if (ownership.ownerId === id && isReceivingFromPartition(ownership.partitionId)) {\n      partitionsToRenew.push(ownership.partitionId);\n    }\n  }\n\n  // Pass the list of all the partition ids and the collection of claimed partition ownerships\n  // to the load balance strategy.\n  // The load balancing strategy only needs to know the full list of partitions,\n  // and which of those are currently claimed.\n  // Since abandoned partitions are no longer claimed, we exclude them.\n  const partitionsToClaim = loadBalancingStrategy.getPartitionsToClaim(\n    id,\n    nonAbandonedPartitionOwnershipMap,\n    partitionIds\n  );\n  partitionsToClaim.push(...partitionsToRenew);\n\n  return {\n    partitionsToClaim: new Set(partitionsToClaim),\n    partitionOwnershipMap,\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { parseConnectionString } from \"@azure/core-amqp\";\n\n/**\n * The set of properties that comprise an Event Hub connection string.\n */\nexport interface EventHubConnectionStringProperties {\n  /**\n   * The fully qualified Event Hub namespace extracted from the \"Endpoint\" in the\n   * connection string. This is likely to be similar to `{yournamespace}.servicebus.windows.net`.\n   * This is typically used to construct an EventHubProducerClient or an EventHubConsumerClient.\n   */\n  fullyQualifiedNamespace: string;\n  /**\n   * The value for \"Endpoint\" in the connection string.\n   */\n  endpoint: string;\n  /**\n   * The value for \"EntityPath\" in the connection string which would be the name of the event hub instance associated with the connection string.\n   * Connection string from a Shared Access Policy created at the namespace level\n   * will not have the EntityPath in it.\n   */\n  eventHubName?: string;\n  /**\n   * The value for \"SharedAccessKey\" in the connection string. This along with the \"SharedAccessKeyName\"\n   * in the connection string is used to generate a SharedAccessSignature which can be used authorize\n   * the connection to the service.\n   */\n  sharedAccessKey?: string;\n  /**\n   * The value for \"SharedAccessKeyName\" in the connection string. This along with the \"SharedAccessKey\"\n   * in the connection string is used to generate a SharedAccessSignature which can be used authorize\n   * the connection to the service.\n   */\n  sharedAccessKeyName?: string;\n  /**\n   * The value for \"SharedAccessSignature\" in the connection string. This is typically not present in the\n   * connection string generated for a Shared Access Policy. It is instead generated by the\n   * user and appended to the connection string for ease of use.\n   */\n  sharedAccessSignature?: string;\n}\n\n/**\n * Parses given connection string into the different properties applicable to Azure Event Hubs.\n * The properties are useful to then construct an EventHubProducerClient or an EventHubConsumerClient.\n * @param connectionString - The connection string associated with the Shared Access Policy created\n * for the Event Hubs namespace.\n */\nexport function parseEventHubConnectionString(\n  connectionString: string\n): Readonly<EventHubConnectionStringProperties> {\n  const parsedResult = parseConnectionString<{\n    Endpoint: string;\n    EntityPath?: string;\n    SharedAccessSignature?: string;\n    SharedAccessKey?: string;\n    SharedAccessKeyName?: string;\n  }>(connectionString);\n\n  validateProperties(\n    parsedResult.Endpoint,\n    parsedResult.SharedAccessSignature,\n    parsedResult.SharedAccessKey,\n    parsedResult.SharedAccessKeyName\n  );\n\n  const output: EventHubConnectionStringProperties = {\n    fullyQualifiedNamespace: (parsedResult.Endpoint.match(\".*://([^/]*)\") || [])[1],\n    endpoint: parsedResult.Endpoint,\n  };\n\n  if (parsedResult.EntityPath) {\n    output.eventHubName = parsedResult.EntityPath;\n  }\n\n  if (parsedResult.SharedAccessSignature) {\n    output.sharedAccessSignature = parsedResult.SharedAccessSignature;\n  }\n\n  if (parsedResult.SharedAccessKey && parsedResult.SharedAccessKeyName) {\n    output.sharedAccessKey = parsedResult.SharedAccessKey;\n    output.sharedAccessKeyName = parsedResult.SharedAccessKeyName;\n  }\n\n  return output;\n}\n\n/**\n * @internal\n */\nfunction validateProperties(\n  endpoint?: string,\n  sharedAccessSignature?: string,\n  sharedAccessKey?: string,\n  sharedAccessKeyName?: string\n): void {\n  if (!endpoint) {\n    throw new Error(\"Connection string should have an Endpoint key.\");\n  }\n\n  if (sharedAccessSignature) {\n    if (sharedAccessKey || sharedAccessKeyName) {\n      throw new Error(\n        \"Connection string cannot have both SharedAccessSignature and SharedAccessKey keys.\"\n      );\n    }\n  } else if (sharedAccessKey && !sharedAccessKeyName) {\n    throw new Error(\"Connection string with SharedAccessKey should have SharedAccessKeyName.\");\n  } else if (!sharedAccessKey && sharedAccessKeyName) {\n    throw new Error(\n      \"Connection string with SharedAccessKeyName should have SharedAccessKey as well.\"\n    );\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { logErrorStackTrace, logger } from \"../logger\";\nimport { ConnectionContext } from \"../connectionContext\";\nimport { isDefined } from \"@azure/core-util\";\nimport { AmqpError, isAmqpError } from \"rhea-promise\";\nimport { isMessagingError, MessagingError, translate } from \"@azure/core-amqp\";\n\n/**\n * @internal\n * Logs and throws Error if the current AMQP connection is closed.\n * @param context - The ConnectionContext associated with the current AMQP connection.\n */\nexport function throwErrorIfConnectionClosed(context: ConnectionContext): void {\n  if (context && context.wasConnectionCloseCalled) {\n    const errorMessage = \"The underlying AMQP connection is closed.\";\n    const error = new Error(errorMessage);\n    logger.warning(`[${context.connectionId}] ${error.name}: ${error.message}`);\n    logErrorStackTrace(error);\n    throw error;\n  }\n}\n\n/**\n * @internal\n * Logs and Throws TypeError if given parameter is undefined or null\n * @param connectionId - Id of the underlying AMQP connection used for logging\n * @param methodName - Name of the method that was passed the parameter\n * @param parameterName - Name of the parameter to check\n * @param parameterValue - Value of the parameter to check\n */\nexport function throwTypeErrorIfParameterMissing(\n  connectionId: string,\n  methodName: string,\n  parameterName: string,\n  parameterValue: unknown\n): void {\n  if (!isDefined(parameterValue)) {\n    const error = new TypeError(\n      `${methodName} called without required argument \"${parameterName}\"`\n    );\n    logger.warning(`[${connectionId}] ${error.name}: ${error.message}`);\n    logErrorStackTrace(error);\n    throw error;\n  }\n}\n\n/**\n * Maps the amqp error conditions to the Error names.\n * @internal\n */\nenum ConditionErrorNameMapper {\n  /**\n   * Indicates that a sequenc enumber was out of order.\n   */\n  \"com.microsoft:out-of-order-sequence\" = \"SequenceOutOfOrderError\",\n  /**\n   * Error is thrown when two or more instances connect to the same partition\n   * with different epoch values.\n   */\n  \"com.microsoft:producer-epoch-stolen\" = \"ProducerDisconnectedError\",\n}\n\n/**\n * @internal\n */\nconst nonRetryableErrors: Set<string> = new Set([\n  \"ProducerDisconnectedError\",\n  \"SequenceOutOfOrderError\",\n]);\n\n/**\n * @internal\n */\nexport function translateError(err: AmqpError | Error): MessagingError | Error {\n  const translatedError = translate(err);\n  // If we're not dealing with a messaging error, or the original error wasn't an AMQP error,\n  // or we have a resolved code on the messaging error, just return the translated error.\n  if (!isMessagingError(translatedError) || !isAmqpError(err) || translatedError.code) {\n    return translatedError;\n  }\n\n  const amqpError = err as AmqpError;\n  const condition = amqpError.condition;\n\n  // If we don't have a condition, we can't map the condition to a code.\n  if (!condition) {\n    return translatedError;\n  }\n\n  // Attempt to resolve codes core-amqp doesn't know about.\n  translatedError.code =\n    ConditionErrorNameMapper[condition as keyof typeof ConditionErrorNameMapper];\n  if (translatedError.code) {\n    translatedError.retryable = !nonRetryableErrors.has(translatedError.code);\n  }\n\n  return translatedError;\n}\n\n/**\n * @internal\n */\nexport const idempotentAlreadyPublished =\n  \"These events have already been successfully published. When idempotent publishing is enabled, events that were acknowledged by the Event Hubs service may not be published again.\";\n\n/**\n * @internal\n */\nexport const idempotentSomeAlreadyPublished =\n  \"1 or more of these events have already been successfully published. When idempotent publishing is enabled, events that were acknowledged by the Event Hubs service may not be published again.\";\n\n/**\n * @internal\n */\nexport function validateProducerPartitionSettings({\n  enableIdempotentRetries,\n  partitionId,\n  partitionKey,\n}: {\n  enableIdempotentRetries?: boolean;\n  partitionId?: string;\n  partitionKey?: string;\n}): void {\n  if (enableIdempotentRetries && (isDefined(partitionKey) || !isDefined(partitionId))) {\n    throw new Error(\n      `The \"partitionId\" must be supplied and \"partitionKey\" must not be provided when the EventHubProducerClient has \"enableIdempotentRetries\" set to true.`\n    );\n  }\n\n  if (isDefined(partitionId) && isDefined(partitionKey)) {\n    throw new Error(\n      `The partitionId (${partitionId}) and partitionKey (${partitionKey}) cannot both be specified.`\n    );\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  Constants,\n  RequestResponseLink,\n  RetryConfig,\n  RetryOperationType,\n  RetryOptions,\n  SendRequestOptions,\n  defaultCancellableLock,\n  isSasTokenProvider,\n  retry,\n  translate,\n} from \"@azure/core-amqp\";\nimport {\n  EventContext,\n  Message,\n  ReceiverEvents,\n  ReceiverOptions,\n  SenderEvents,\n  SenderOptions,\n} from \"rhea-promise\";\nimport {\n  createLogPrefix,\n  logErrorStackTrace,\n  createSimpleLogger,\n  logger,\n  SimpleLogger,\n} from \"./logger\";\nimport { throwErrorIfConnectionClosed, throwTypeErrorIfParameterMissing } from \"./util/error\";\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { AccessToken } from \"@azure/core-auth\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { OperationOptions } from \"./util/operationOptions\";\nimport { toSpanOptions, tracingClient } from \"./diagnostics/tracing\";\nimport { getRetryAttemptTimeoutInMs } from \"./util/retries\";\nimport { TimerLoop } from \"./util/timerLoop\";\nimport { withAuth } from \"./withAuth\";\nimport { getRandomName } from \"./util/utils\";\n\n/**\n * Describes the runtime information of an Event Hub.\n */\nexport interface EventHubProperties {\n  /**\n   * The name of the event hub.\n   */\n  name: string;\n  /**\n   * The date and time the hub was created in UTC.\n   */\n  createdOn: Date;\n  /**\n   * The slice of string partition identifiers.\n   */\n  partitionIds: string[];\n}\n\n/**\n * Describes the runtime information of an EventHub Partition.\n */\nexport interface PartitionProperties {\n  /**\n   * The name of the Event Hub.\n   */\n  eventHubName: string;\n  /**\n   * Identifier of the partition within the Event Hub.\n   */\n  partitionId: string;\n  /**\n   * The starting sequence number of the partition's message log.\n   */\n  beginningSequenceNumber: number;\n  /**\n   * The last sequence number of the partition's message log.\n   */\n  lastEnqueuedSequenceNumber: number;\n  /**\n   * The offset of the last enqueued message in the partition's message log.\n   */\n  lastEnqueuedOffset: number;\n  /**\n   * The time of the last enqueued message in the partition's message log in UTC.\n   */\n  lastEnqueuedOnUtc: Date;\n  /**\n   * Indicates whether the partition is empty.\n   */\n  isEmpty: boolean;\n}\n\n/**\n * @internal\n */\nexport interface ManagementClientOptions {\n  address?: string;\n  audience?: string;\n}\n\n/**\n * @internal\n * Describes the EventHubs Management Client that talks\n * to the $management endpoint over AMQP connection.\n */\nexport class ManagementClient {\n  readonly managementLock: string = getRandomName(Constants.managementRequestKey);\n  /**\n   * The name/path of the entity (hub name) for which the management\n   * request needs to be made.\n   */\n  private readonly entityPath: string;\n  /**\n   * The reply to Guid for the management client.\n   */\n  private readonly replyTo: string = getRandomName();\n  /**\n   * $management sender, receiver on the same session.\n   */\n  private _mgmtReqResLink?: RequestResponseLink;\n  /**\n   * The unique name for the entity (mostly a guid).\n   */\n  private readonly name: string;\n  /**\n   * The address in the following form:\n   * `\"$management\"`.\n   */\n  private readonly address: string;\n  /**\n   * The token audience in the following form:\n   * `\"sb://<your-namespace>.servicebus.windows.net/<event-hub-name>/$management\"`.\n   */\n  private readonly audience: string;\n  /**\n   * Provides relevant information about the amqp connection,\n   * cbs and $management sessions, token provider, sender and receivers.\n   */\n  private readonly _context: ConnectionContext;\n  /**\n   * The authentication loop that keeps the token refreshed.\n   */\n  private authLoop?: TimerLoop;\n  private readonly logger: SimpleLogger;\n\n  /**\n   * Instantiates the management client.\n   * @param context - The connection context.\n   * @param address - The address for the management endpoint. For IotHub it will be\n   * `/messages/events/$management`.\n   */\n  constructor(context: ConnectionContext, { address, audience }: ManagementClientOptions = {}) {\n    this.address = address ?? Constants.management;\n    this.name = this.address;\n    this.audience = audience ?? context.config.getManagementAudience();\n    this._context = context;\n    const logPrefix = createLogPrefix(this._context.connectionId, \"Management\", this.name);\n    this.logger = createSimpleLogger(logger, logPrefix);\n    this.entityPath = context.config.entityPath as string;\n  }\n\n  /**\n   * Gets the security token for the management application properties.\n   * @internal\n   */\n  async getSecurityToken(): Promise<AccessToken | null> {\n    if (isSasTokenProvider(this._context.tokenCredential)) {\n      // the security_token has the $management address removed from the end of the audience\n      // expected audience: sb://fully.qualified.namespace/event-hub-name/$management\n      const audienceParts = this.audience.split(\"/\");\n      // for management links, address should be '$management'\n      if (audienceParts[audienceParts.length - 1] === this.address) {\n        audienceParts.pop();\n      }\n      const audience = audienceParts.join(\"/\");\n      return this._context.tokenCredential.getToken(audience);\n    }\n\n    // aad credentials use the aad scope\n    return this._context.tokenCredential.getToken(Constants.aadEventHubsScope);\n  }\n\n  /**\n   * Provides the eventhub runtime information.\n   */\n  async getEventHubProperties(\n    options: OperationOptions & { retryOptions?: RetryOptions } = {}\n  ): Promise<EventHubProperties> {\n    throwErrorIfConnectionClosed(this._context);\n    return tracingClient.withSpan(\n      \"ManagementClient.getEventHubProperties\",\n      options,\n      async (updatedOptions) => {\n        try {\n          const securityToken = await this.getSecurityToken();\n\n          const request: Message = {\n            body: Buffer.from(JSON.stringify([])),\n            message_id: getRandomName(),\n            reply_to: this.replyTo,\n            application_properties: {\n              operation: Constants.readOperation,\n              name: this.entityPath as string,\n              type: `${Constants.vendorString}:${Constants.eventHub}`,\n              security_token: securityToken?.token,\n            },\n          };\n\n          const info: any = await this._makeManagementRequest(request, {\n            ...updatedOptions,\n            requestName: \"getHubRuntimeInformation\",\n          });\n          const runtimeInfo: EventHubProperties = {\n            name: info.name,\n            createdOn: new Date(info.created_at),\n            partitionIds: info.partition_ids,\n          };\n          logger.verbose(\"the hub runtime info is: %O\", runtimeInfo);\n\n          return runtimeInfo;\n        } catch (error: any) {\n          logger.warning(\n            `an error occurred while getting the hub runtime information: ${error?.name}: ${error?.message}`\n          );\n          logErrorStackTrace(error);\n          throw error;\n        }\n      },\n      toSpanOptions(this._context.config)\n    );\n  }\n\n  /**\n   * Provides information about the specified partition.\n   * @param partitionId - Partition ID for which partition information is required.\n   */\n  async getPartitionProperties(\n    partitionId: string,\n    options: OperationOptions & { retryOptions?: RetryOptions } = {}\n  ): Promise<PartitionProperties> {\n    throwErrorIfConnectionClosed(this._context);\n    throwTypeErrorIfParameterMissing(\n      this._context.connectionId,\n      \"getPartitionProperties\",\n      \"partitionId\",\n      partitionId\n    );\n    partitionId = String(partitionId);\n\n    return tracingClient.withSpan(\n      \"ManagementClient.getPartitionProperties\",\n      options,\n      async (updatedOptions) => {\n        try {\n          const securityToken = await this.getSecurityToken();\n          const request: Message = {\n            body: Buffer.from(JSON.stringify([])),\n            message_id: getRandomName(),\n            reply_to: this.replyTo,\n            application_properties: {\n              operation: Constants.readOperation,\n              name: this.entityPath as string,\n              type: `${Constants.vendorString}:${Constants.partition}`,\n              partition: `${partitionId}`,\n              security_token: securityToken?.token,\n            },\n          };\n\n          const info: any = await this._makeManagementRequest(request, {\n            ...updatedOptions,\n            requestName: \"getPartitionInformation\",\n          });\n\n          const partitionInfo: PartitionProperties = {\n            beginningSequenceNumber: info.begin_sequence_number,\n            eventHubName: info.name,\n            lastEnqueuedOffset: info.last_enqueued_offset,\n            lastEnqueuedOnUtc: new Date(info.last_enqueued_time_utc),\n            lastEnqueuedSequenceNumber: info.last_enqueued_sequence_number,\n            partitionId: info.partition,\n            isEmpty: info.is_partition_empty,\n          };\n          logger.verbose(\"the partition info is: %O.\", partitionInfo);\n          return partitionInfo;\n        } catch (error: any) {\n          logger.warning(\n            `an error occurred while getting the partition information: ${error?.name}: ${error?.message}`\n          );\n          logErrorStackTrace(error);\n          throw error;\n        }\n      },\n      toSpanOptions(this._context.config)\n    );\n  }\n\n  /**\n   * Closes the AMQP management session to the Event Hub for this client,\n   * returning a promise that will be resolved when disconnection is completed.\n   */\n  async close(): Promise<void> {\n    try {\n      // Always stop the auth loop when closing the management link.\n      this.authLoop?.stop();\n      if (this._isMgmtRequestResponseLinkOpen()) {\n        const mgmtLink = this._mgmtReqResLink;\n        this._mgmtReqResLink = undefined;\n        await mgmtLink!.close();\n        logger.info(\"successfully closed the management session.\");\n      }\n    } catch (err: any) {\n      const msg = `an error occurred while closing the management session: ${err?.name}: ${err?.message}`;\n      logger.warning(msg);\n      logErrorStackTrace(err);\n      throw new Error(msg);\n    }\n  }\n\n  private async _init({\n    abortSignal,\n    timeoutInMs,\n  }: {\n    abortSignal: AbortSignalLike | undefined;\n    timeoutInMs: number;\n  }): Promise<void> {\n    const createLink = async () => {\n      const rxopt: ReceiverOptions = {\n        source: { address: this.address },\n        name: this.replyTo,\n        target: { address: this.replyTo },\n        onSessionError: (context: EventContext) => {\n          const ehError = translate(context.session!.error!);\n          logger.verbose(\n            \"an error occurred on the session for request/response links for \" + \"$management: %O\",\n            ehError\n          );\n        },\n      };\n      const sropt: SenderOptions = {\n        target: { address: this.address },\n      };\n      logger.verbose(\n        \"creating sender/receiver links with \" + \"srOpts: %o, receiverOpts: %O.\",\n        sropt,\n        rxopt\n      );\n      this._mgmtReqResLink = await RequestResponseLink.create(\n        this._context.connection,\n        sropt,\n        rxopt,\n        { abortSignal }\n      );\n      this._mgmtReqResLink.sender.on(SenderEvents.senderError, (context: EventContext) => {\n        const ehError = translate(context.sender!.error!);\n        logger.verbose(\"an error occurred on the $management sender link.. %O\", ehError);\n      });\n      this._mgmtReqResLink.receiver.on(ReceiverEvents.receiverError, (context: EventContext) => {\n        const ehError = translate(context.receiver!.error!);\n        logger.verbose(\"an error occurred on the $management receiver link.. %O\", ehError);\n      });\n      logger.verbose(\n        \"created sender '%s' and receiver '%s' links\",\n        this._mgmtReqResLink.sender.name,\n        this._mgmtReqResLink.receiver.name\n      );\n    };\n    try {\n      if (!this._isMgmtRequestResponseLinkOpen()) {\n        // Wait for the connectionContext to be ready to open the link.\n        await this._context.readyToOpenLink();\n        this.authLoop = await withAuth(\n          createLink,\n          this._context,\n          this.audience,\n          timeoutInMs,\n          this.logger,\n          { abortSignal }\n        );\n      }\n    } catch (err) {\n      const translatedError = translate(err);\n      logger.warning(\n        `an error occurred while establishing the links: ${translatedError?.name}: ${translatedError?.message}`\n      );\n      logErrorStackTrace(translatedError);\n      throw translatedError;\n    }\n  }\n\n  /**\n   * Helper method to make the management request\n   * @param request - The AMQP message to send\n   * @param options - The options to use when sending a request over a $management link\n   */\n  private async _makeManagementRequest(\n    request: Message,\n    options: {\n      retryOptions?: RetryOptions;\n      abortSignal?: AbortSignalLike;\n      requestName?: string;\n    } = {}\n  ): Promise<any> {\n    const retryOptions = options.retryOptions || {};\n    try {\n      const abortSignal: AbortSignalLike | undefined = options && options.abortSignal;\n\n      const sendOperationPromise = async (): Promise<Message> => {\n        let count = 0;\n\n        const retryTimeoutInMs = getRetryAttemptTimeoutInMs(options.retryOptions);\n        let timeTakenByInit = 0;\n\n        if (!this._isMgmtRequestResponseLinkOpen()) {\n          logger.verbose(\"acquiring lock to get the management req res link.\");\n\n          const initOperationStartTime = Date.now();\n          try {\n            await defaultCancellableLock.acquire(\n              this.managementLock,\n              () => {\n                const acquireLockEndTime = Date.now();\n                const timeoutInMs =\n                  retryTimeoutInMs - (acquireLockEndTime - initOperationStartTime);\n                return this._init({ abortSignal, timeoutInMs });\n              },\n              { abortSignal, timeoutInMs: retryTimeoutInMs }\n            );\n          } catch (err) {\n            const translatedError = translate(err);\n            logger.warning(\n              \"an error occurred while creating the link: %s\",\n              `${translatedError?.name}: ${translatedError?.message}`\n            );\n            logErrorStackTrace(translatedError);\n            throw translatedError;\n          }\n          timeTakenByInit = Date.now() - initOperationStartTime;\n        }\n\n        const remainingOperationTimeoutInMs = retryTimeoutInMs - timeTakenByInit;\n\n        const sendRequestOptions: SendRequestOptions = {\n          abortSignal: options.abortSignal,\n          requestName: options.requestName,\n          timeoutInMs: remainingOperationTimeoutInMs,\n        };\n\n        count++;\n        if (count !== 1) {\n          // Generate a new message_id every time after the first attempt\n          request.message_id = getRandomName();\n        } else if (!request.message_id) {\n          // Set the message_id in the first attempt only if it is not set\n          request.message_id = getRandomName();\n        }\n\n        return this._mgmtReqResLink!.sendRequest(request, sendRequestOptions);\n      };\n\n      const config: RetryConfig<Message> = Object.defineProperties(\n        {\n          operation: sendOperationPromise,\n          operationType: RetryOperationType.management,\n          abortSignal: abortSignal,\n          retryOptions: retryOptions,\n        },\n        {\n          connectionId: {\n            enumerable: true,\n            get: () => {\n              return this._context.connectionId;\n            },\n          },\n        }\n      ) as RetryConfig<Message>;\n      return (await retry<Message>(config)).body;\n    } catch (err) {\n      const translatedError = translate(err);\n      logger.warning(\n        \"an error occurred during send on management request-response link with address: %s\",\n        `${translatedError?.name}: ${translatedError?.message}`\n      );\n      logErrorStackTrace(translatedError);\n      throw translatedError;\n    }\n  }\n\n  private _isMgmtRequestResponseLinkOpen(): boolean {\n    return this._mgmtReqResLink! && this._mgmtReqResLink!.isOpen();\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/**\n * Parses the host, hostname, and port from an endpoint.\n * @param endpoint - And endpoint to parse.\n * @internal\n */\nexport function parseEndpoint(endpoint: string): { host: string; hostname: string; port?: string } {\n  const hostMatch = endpoint.match(/.*:\\/\\/([^/]*)/);\n  if (!hostMatch) {\n    throw new TypeError(`Invalid endpoint missing host: ${endpoint}`);\n  }\n\n  const [, host] = hostMatch;\n  const [hostname, port] = host.split(\":\");\n\n  return { host, hostname, port };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n/* eslint-disable eqeqeq */\n\nimport { ConnectionConfig } from \"@azure/core-amqp\";\nimport { parseEndpoint } from \"./util/parseEndpoint\";\n\n/**\n * Describes the connection config object that is created after parsing an EventHub connection\n * string. It also provides some convenience methods for getting the address and audience for\n * different entities.\n * @internal\n */\nexport interface EventHubConnectionConfig extends ConnectionConfig {\n  /**\n   * The name/path of the entity (event hub name) to which the\n   * connection needs to happen.\n   */\n  entityPath: string;\n  /**\n   * Provides the EventHub Sender address in one of the following forms based on the input:\n   * - `\"<hubName>\"`\n   * - `\"<hubName>/Partitions/<partitionId>\"`\n   *\n   * @param partitionId - The partitionId in the EventHub to which messages will be sent.\n   */\n  getSenderAddress(partitionId?: string | number): string;\n  /**\n   * Provides the EventHub Sender audience in one of the following forms based on the input:\n   * - `\"sb://<yournamespace>.servicebus.windows.net/<hubName>\"`\n   * - `\"sb://<yournamespace>.servicebus.windows.net/<hubName>/Partitions/<partitionId>\"`\n   *\n   * @param partitionId - The partitionId in the EventHub to which messages will be sent.\n   */\n  getSenderAudience(partitionId?: string | number): string;\n  /**\n   * Provides the EventHub Receiver address:\n   * - `\"<hub-name>/ConsumerGroups/<consumer-group-name>/Partitions/<partition-id>\"`\n   *\n   * @param partitionId - The partitionId in the EventHub from which messages will be received.\n   * @param consumergroup - The consumergoup in the EventHub from which the messages will\n   * be received. Default: `$default`.\n   */\n  getReceiverAddress(partitionId: string | number, consumergroup?: string): string;\n  /**\n   * Provides the EventHub Receiver audience.\n   * - `\"sb://<your-namespace>.servicebus.windows.net/<hub-name>/ConsumerGroups/<consumer-group-name>/Partitions/<partition-id>\"`\n   *\n   * @param partitionId - The partitionId in the EventHub from which messages will be received.\n   * @param consumergroup - The consumergoup in the EventHub from which the messages will\n   * be received. Default: `$default`.\n   */\n  getReceiverAudience(partitionId: string | number, consumergroup?: string): string;\n  /**\n   * Provides the EventHub Management address.\n   * - `\"<hub-name>/$management\"`\n   */\n  getManagementAddress(): string;\n  /**\n   * Provides the EventHub Management audience.\n   * - `\"sb://<your-namespace>.servicebus.windows.net/<hub-name>/$management\"`\n   */\n  getManagementAudience(): string;\n}\n\n/**\n * Describes the connection config object that is created after parsing an EventHub connection\n * string. It also provides some convenience methods for getting the address and audience for\n * different entities.\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/no-redeclare -- renaming constant would be a breaking change.\nexport const EventHubConnectionConfig = {\n  /**\n   * Creates the connection config.\n   * @param connectionString - The connection string for a given service like\n   * EventHub/ServiceBus.\n   * @param path - The name/path of the entity (hub name) to which the\n   * connection needs to happen. This will override the EntityPath in the connectionString\n   * if present.\n   * @returns EventHubConnectionConfig\n   */\n  create(connectionString: string, path?: string): EventHubConnectionConfig {\n    const config = ConnectionConfig.create(connectionString, path);\n    if (!config.entityPath) {\n      throw new TypeError(\n        `Either provide \"path\" or the \"connectionString\": \"${connectionString}\", ` +\n          `must contain EntityPath=\"<path-to-the-entity>\".`\n      );\n    }\n    return EventHubConnectionConfig.createFromConnectionConfig(config);\n  },\n\n  /**\n   * Creates an EventHubConnectionConfig from the provided base ConnectionConfig.\n   * @param config - The base connection config from which the EventHubConnectionConfig needs to be\n   * created.\n   * @returns EventHubConnectionConfig\n   */\n  createFromConnectionConfig(config: ConnectionConfig): EventHubConnectionConfig {\n    ConnectionConfig.validate(config, { isEntityPathRequired: true });\n\n    (config as EventHubConnectionConfig).getManagementAudience = () => {\n      return `${config.endpoint}${config.entityPath}/$management`;\n    };\n    (config as EventHubConnectionConfig).getManagementAddress = () => {\n      return `${config.entityPath}/$management`;\n    };\n\n    (config as EventHubConnectionConfig).getSenderAudience = (partitionId?: string | number) => {\n      if (partitionId != undefined) {\n        return `${config.endpoint}${config.entityPath}/Partitions/${partitionId}`;\n      } else {\n        return `${config.endpoint}${config.entityPath}`;\n      }\n    };\n\n    (config as EventHubConnectionConfig).getSenderAddress = (partitionId?: string | number) => {\n      if (partitionId != undefined) {\n        return `${config.entityPath}/Partitions/${partitionId}`;\n      } else {\n        return `${config.entityPath}`;\n      }\n    };\n\n    (config as EventHubConnectionConfig).getReceiverAudience = (\n      partitionId: string | number,\n      consumergroup?: string\n    ) => {\n      if (!consumergroup) consumergroup = \"$default\";\n      return (\n        `${config.endpoint}${config.entityPath}/ConsumerGroups/${consumergroup}/` +\n        `Partitions/${partitionId}`\n      );\n    };\n\n    (config as EventHubConnectionConfig).getReceiverAddress = (\n      partitionId: string | number,\n      consumergroup?: string\n    ) => {\n      if (!consumergroup) consumergroup = \"$default\";\n      return `${config.entityPath}/ConsumerGroups/${consumergroup}/Partitions/${partitionId}`;\n    };\n    return config as EventHubConnectionConfig;\n  },\n\n  /**\n   * Updates the provided EventHubConnectionConfig to use the custom endpoint address.\n   * @param config - An existing connection configuration to be updated.\n   * @param customEndpointAddress - The custom endpoint address to use.\n   */\n  setCustomEndpointAddress(config: EventHubConnectionConfig, customEndpointAddress: string): void {\n    // The amqpHostname should match the host prior to using the custom endpoint.\n    config.amqpHostname = config.host;\n    const { hostname, port } = parseEndpoint(customEndpointAddress);\n    // Since we specify the port separately, set host to the customEndpointAddress hostname.\n    config.host = hostname;\n    if (port) {\n      config.port = parseInt(port, 10);\n    }\n  },\n\n  /**\n   * Validates the properties of connection config.\n   * @param config - The connection config to be validated.\n   * @returns void\n   */\n  validate(config: EventHubConnectionConfig): void {\n    return ConnectionConfig.validate(config, { isEntityPathRequired: true });\n  },\n};\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport * as os from \"os\";\n\n/**\n * Returns information about the platform this function is being run on.\n * @internal\n */\nexport function getRuntimeInfo(): string {\n  return `NODE-VERSION ${process.version}; ${os.type()} ${os.release()}`;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  NamedKeyCredential,\n  SASCredential,\n  TokenCredential,\n  isNamedKeyCredential,\n  isSASCredential,\n  isTokenCredential,\n} from \"@azure/core-auth\";\n\n/**\n * Typeguard that checks if the input is a credential type the clients accept.\n * @param thing - Any object.\n * @internal\n */\nexport function isCredential(\n  thing: unknown\n): thing is TokenCredential | NamedKeyCredential | SASCredential {\n  return isTokenCredential(thing) || isNamedKeyCredential(thing) || isSASCredential(thing);\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable no-inner-declarations */\n\nimport { Connection, ConnectionEvents, Dictionary, EventContext, OnAmqpEvent } from \"rhea-promise\";\nimport {\n  ConnectionConfig,\n  ConnectionContextBase,\n  Constants,\n  CreateConnectionContextBaseParameters,\n  SasTokenProvider,\n  createSasTokenProvider,\n} from \"@azure/core-amqp\";\nimport {\n  EventHubConnectionStringProperties,\n  parseEventHubConnectionString,\n} from \"./util/connectionStringUtils\";\nimport { ManagementClient, ManagementClientOptions } from \"./managementClient\";\nimport {\n  NamedKeyCredential,\n  SASCredential,\n  TokenCredential,\n  isNamedKeyCredential,\n  isSASCredential,\n} from \"@azure/core-auth\";\nimport { logErrorStackTrace, logger } from \"./logger\";\nimport { EventHubClientOptions } from \"./models/public\";\nimport { EventHubConnectionConfig } from \"./eventhubConnectionConfig\";\nimport { PartitionReceiver } from \"./partitionReceiver\";\nimport { EventHubSender } from \"./eventHubSender\";\nimport { getRuntimeInfo } from \"./util/runtimeInfo\";\nimport { isCredential } from \"./util/typeGuards\";\nimport { packageJsonInfo } from \"./util/constants\";\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { createAbortablePromise } from \"@azure/core-util\";\n\n/**\n * @internal\n * Provides contextual information like the underlying amqp connection, cbs session, management session,\n * tokenProvider, senders, receivers, etc. about the EventHub client.\n */\nexport interface ConnectionContext extends ConnectionContextBase {\n  /**\n   * The EventHub connection config that is created after\n   * parsing the connection string.\n   */\n  readonly config: EventHubConnectionConfig;\n  /**\n   * The credential to be used for Authentication.\n   * Default value: SasTokenProvider.\n   */\n  tokenCredential: SasTokenProvider | TokenCredential;\n  /**\n   * Indicates whether the close() method was\n   * called on theconnection object.\n   */\n  wasConnectionCloseCalled: boolean;\n  /**\n   * A dictionary of the EventHub Receivers associated with this client.\n   */\n  receivers: Dictionary<PartitionReceiver>;\n  /**\n   * A dictionary of the EventHub Senders associated with this client.\n   */\n  senders: Dictionary<EventHubSender>;\n  /**\n   * A reference to the management session ($management endpoint) on\n   * the underlying amqp connection for the EventHub Client.\n   */\n  managementSession?: ManagementClient;\n  /**\n   * Function returning a promise that resolves once the connectionContext is ready to open an AMQP link.\n   * ConnectionContext will be ready to open an AMQP link when:\n   * - The AMQP connection is already open on both sides.\n   * - The AMQP connection has been closed or disconnected. In this case, a new AMQP connection is expected\n   * to be created first.\n   * An AMQP link cannot be opened if the AMQP connection\n   * is in the process of closing or disconnecting.\n   */\n  readyToOpenLink(options?: { abortSignal?: AbortSignalLike }): Promise<void>;\n  /**\n   * Closes all AMQP links, sessions and connection.\n   */\n  close(): Promise<void>;\n}\n\n/**\n * Describes the members on the ConnectionContext that are only\n * used by it internally.\n * @internal\n */\nexport interface ConnectionContextInternalMembers extends ConnectionContext {\n  /**\n   * Indicates whether the connection is in the process of closing.\n   * When this returns `true`, a `disconnected` event will be received\n   * after the connection is closed.\n   *\n   */\n  isConnectionClosing(): boolean;\n  /**\n   * Resolves once the context's connection emits a `disconnected` event.\n   */\n  waitForDisconnectedEvent(options?: { abortSignal?: AbortSignalLike }): Promise<void>;\n  /**\n   * Resolves once the connection has finished being reset.\n   * Connections are reset as part of reacting to a `disconnected` event.\n   */\n  waitForConnectionReset(): Promise<void>;\n}\n\n/**\n * @internal\n */\nexport interface ConnectionContextOptions extends EventHubClientOptions {\n  managementSessionAddress?: string;\n  managementSessionAudience?: string;\n}\n\n/**\n * Helper type to get the names of all the functions on an object.\n */\ntype FunctionPropertyNames<T> = { [K in keyof T]: T[K] extends Function ? K : never }[keyof T]; // eslint-disable-line @typescript-eslint/ban-types\n/**\n * Helper type to get the types of all the functions on an object.\n */\ntype FunctionProperties<T> = Pick<T, FunctionPropertyNames<T>>;\n/**\n * Helper type to get the types of all the functions on ConnectionContext\n * and the internal methods from ConnectionContextInternalMembers.\n * Note that this excludes the functions that ConnectionContext inherits.\n * Each function also has its `this` type set as `ConnectionContext`.\n */\ntype ConnectionContextMethods = Omit<\n  FunctionProperties<ConnectionContextInternalMembers>,\n  FunctionPropertyNames<ConnectionContextBase>\n> &\n  ThisType<ConnectionContextInternalMembers>;\n\n/**\n * @internal\n */\nexport namespace ConnectionContext {\n  /**\n   * The user agent string for the EventHubs client.\n   * See guideline at https://github.com/Azure/azure-sdk/blob/main/docs/design/Telemetry.mdk\n   */\n  const userAgent: string = `azsdk-js-azureeventhubs/${\n    packageJsonInfo.version\n  } (${getRuntimeInfo()})`;\n\n  export function getUserAgent(options: ConnectionContextOptions): string {\n    const finalUserAgent = options.userAgent ? `${userAgent},${options.userAgent}` : userAgent;\n    if (finalUserAgent.length > Constants.maxUserAgentLength) {\n      throw new Error(\n        `The user-agent string cannot be more than ${Constants.maxUserAgentLength} characters in length.` +\n          `The given user-agent string is: ${finalUserAgent} with length: ${finalUserAgent.length}`\n      );\n    }\n    return finalUserAgent;\n  }\n\n  export function create(\n    config: EventHubConnectionConfig,\n    tokenCredential: SasTokenProvider | TokenCredential,\n    options?: ConnectionContextOptions\n  ): ConnectionContext {\n    if (!options) options = {};\n\n    config.webSocket = options.webSocketOptions && options.webSocketOptions.webSocket;\n    config.webSocketEndpointPath = \"$servicebus/websocket\";\n    config.webSocketConstructorOptions =\n      options.webSocketOptions && options.webSocketOptions.webSocketConstructorOptions;\n\n    const parameters: CreateConnectionContextBaseParameters = {\n      config: config,\n      // re-enabling this will be a post-GA discussion.\n      // dataTransformer: options.dataTransformer,\n      isEntityPathRequired: true,\n      connectionProperties: {\n        product: \"MSJSClient\",\n        userAgent: getUserAgent(options),\n        version: packageJsonInfo.version,\n      },\n    };\n    // Let us create the base context and then add EventHub specific ConnectionContext properties.\n    const connectionContext = ConnectionContextBase.create(parameters) as ConnectionContext;\n    connectionContext.tokenCredential = tokenCredential;\n    connectionContext.wasConnectionCloseCalled = false;\n    connectionContext.senders = {};\n    connectionContext.receivers = {};\n    const mOptions: ManagementClientOptions = {\n      address: options.managementSessionAddress,\n      audience: options.managementSessionAudience,\n    };\n    connectionContext.managementSession = new ManagementClient(connectionContext, mOptions);\n\n    let waitForConnectionRefreshResolve: () => void;\n    let waitForConnectionRefreshPromise: Promise<void> | undefined;\n\n    Object.assign<ConnectionContext, ConnectionContextMethods>(connectionContext, {\n      isConnectionClosing() {\n        // When the connection is not open, but the remote end is open,\n        // then the rhea connection is in the process of terminating.\n        return Boolean(!this.connection.isOpen() && this.connection.isRemoteOpen());\n      },\n      async readyToOpenLink(optionsArg?: { abortSignal?: AbortSignalLike }) {\n        // Check that the connection isn't in the process of closing.\n        // This can happen when the idle timeout has been reached but\n        // the underlying socket is waiting to be destroyed.\n        if (this.isConnectionClosing()) {\n          // Wait for the disconnected event that indicates the underlying socket has closed.\n          await this.waitForDisconnectedEvent(optionsArg);\n        }\n\n        // Wait for the connection to be reset.\n        await this.waitForConnectionReset();\n      },\n      waitForDisconnectedEvent(optionsArg?: { abortSignal?: AbortSignalLike }) {\n        return createAbortablePromise((resolve) => {\n          logger.verbose(\n            `[${this.connectionId}] Attempting to reinitialize connection` +\n              ` but the connection is in the process of closing.` +\n              ` Waiting for the disconnect event before continuing.`\n          );\n          this.connection.once(ConnectionEvents.disconnected, resolve);\n        }, optionsArg);\n      },\n      waitForConnectionReset() {\n        // Check if the connection is currently in the process of disconnecting.\n        if (waitForConnectionRefreshPromise) {\n          return waitForConnectionRefreshPromise;\n        }\n        return Promise.resolve();\n      },\n      async close() {\n        try {\n          if (this.connection.isOpen()) {\n            // Close all the senders.\n            await Promise.all(\n              Object.keys(connectionContext.senders).map((name) =>\n                connectionContext.senders[name]?.close().catch(() => {\n                  /* error already logged, swallow it here */\n                })\n              )\n            );\n            // Close all the receivers.\n            await Promise.all(\n              Object.keys(connectionContext.receivers).map((name) =>\n                connectionContext.receivers[name]?.close().catch(() => {\n                  /* error already logged, swallow it here */\n                })\n              )\n            );\n            // Close the cbs session;\n            await this.cbsSession.close();\n            // Close the management session\n            await this.managementSession?.close();\n            await this.connection.close();\n            this.wasConnectionCloseCalled = true;\n            logger.info(\"Closed the amqp connection '%s' on the client.\", this.connectionId);\n          }\n        } catch (err: any) {\n          const errorDescription =\n            err instanceof Error ? `${err.name}: ${err.message}` : JSON.stringify(err);\n          logger.warning(\n            `An error occurred while closing the connection \"${this.connectionId}\":\\n${errorDescription}`\n          );\n          logErrorStackTrace(err);\n          throw err;\n        }\n      },\n    });\n\n    // Define listeners to be added to the connection object for\n    // \"connection_open\" and \"connection_error\" events.\n    const onConnectionOpen: OnAmqpEvent = () => {\n      connectionContext.wasConnectionCloseCalled = false;\n      logger.verbose(\n        \"[%s] setting 'wasConnectionCloseCalled' property of connection context to %s.\",\n        connectionContext.connection.id,\n        connectionContext.wasConnectionCloseCalled\n      );\n    };\n\n    const onDisconnected: OnAmqpEvent = async (context: EventContext) => {\n      if (waitForConnectionRefreshPromise) {\n        return;\n      }\n      waitForConnectionRefreshPromise = new Promise((resolve) => {\n        waitForConnectionRefreshResolve = resolve;\n      });\n      try {\n        logger.verbose(\n          \"[%s] 'disconnected' event occurred on the amqp connection.\",\n          connectionContext.connection.id\n        );\n\n        if (context.connection && context.connection.error) {\n          logger.verbose(\n            \"[%s] Accompanying error on the context.connection: %O\",\n            connectionContext.connection.id,\n            context.connection && context.connection.error\n          );\n        }\n        if (context.error) {\n          logger.verbose(\n            \"[%s] Accompanying error on the context: %O\",\n            connectionContext.connection.id,\n            context.error\n          );\n        }\n        const state: Readonly<{\n          wasConnectionCloseCalled: boolean;\n          numSenders: number;\n          numReceivers: number;\n        }> = {\n          wasConnectionCloseCalled: connectionContext.wasConnectionCloseCalled,\n          numSenders: Object.keys(connectionContext.senders).length,\n          numReceivers: Object.keys(connectionContext.receivers).length,\n        };\n        logger.verbose(\n          \"[%s] Closing all open senders and receivers in the state: %O\",\n          connectionContext.connection.id,\n          state\n        );\n\n        // Clear internal map maintained by rhea to avoid reconnecting of old links once the\n        // connection is back up.\n        connectionContext.connection.removeAllSessions();\n\n        // Close the cbs session to ensure all the event handlers are released.\n        await connectionContext.cbsSession?.close().catch(() => {\n          /* error already logged, swallow it here */\n        });\n        // Close the management session to ensure all the event handlers are released.\n        await connectionContext.managementSession?.close().catch(() => {\n          /* error already logged, swallow it here */\n        });\n\n        // Close all senders and receivers to ensure clean up of timers & other resources.\n        if (state.numSenders || state.numReceivers) {\n          await Promise.all(\n            Object.keys(connectionContext.senders).map((name) =>\n              connectionContext.senders[name]?.close().catch(() => {\n                /* error already logged, swallow it here */\n              })\n            )\n          );\n\n          await Promise.all(\n            Object.keys(connectionContext.receivers).map((name) =>\n              connectionContext.receivers[name]?.close().catch(() => {\n                /* error already logged, swallow it here */\n              })\n            )\n          );\n        }\n      } catch (err: any) {\n        logger.verbose(\n          `[${connectionContext.connectionId}] An error occurred while closing the connection in 'disconnected'. %O`,\n          err\n        );\n      }\n\n      try {\n        await refreshConnection(connectionContext);\n      } catch (err: any) {\n        logger.verbose(\n          `[${connectionContext.connectionId}] An error occurred while refreshing the connection in 'disconnected'. %O`,\n          err\n        );\n      } finally {\n        waitForConnectionRefreshResolve();\n        waitForConnectionRefreshPromise = undefined;\n      }\n    };\n\n    const protocolError: OnAmqpEvent = async (context: EventContext) => {\n      logger.verbose(\n        \"[%s] 'protocol_error' event occurred on the amqp connection.\",\n        connectionContext.connection.id\n      );\n\n      if (context.connection && context.connection.error) {\n        logger.verbose(\n          \"[%s] Accompanying error on the context.connection: %O\",\n          connectionContext.connection.id,\n          context.connection && context.connection.error\n        );\n      }\n      if (context.error) {\n        logger.verbose(\n          \"[%s] Accompanying error on the context: %O\",\n          connectionContext.connection.id,\n          context.error\n        );\n      }\n    };\n\n    const error: OnAmqpEvent = async (context: EventContext) => {\n      logger.verbose(\n        \"[%s] 'error' event occurred on the amqp connection.\",\n        connectionContext.connection.id\n      );\n\n      if (context.connection && context.connection.error) {\n        logger.verbose(\n          \"[%s] Accompanying error on the context.connection: %O\",\n          connectionContext.connection.id,\n          context.connection && context.connection.error\n        );\n      }\n      if (context.error) {\n        logger.verbose(\n          \"[%s] Accompanying error on the context: %O\",\n          connectionContext.connection.id,\n          context.error\n        );\n      }\n    };\n\n    function addConnectionListeners(connection: Connection): void {\n      // Add listeners on the connection object.\n      connection.on(ConnectionEvents.connectionOpen, onConnectionOpen);\n      connection.on(ConnectionEvents.disconnected, onDisconnected);\n      connection.on(ConnectionEvents.protocolError, protocolError);\n      connection.on(ConnectionEvents.error, error);\n    }\n\n    function cleanConnectionContext(context: ConnectionContext): Promise<void> {\n      // Remove listeners from the connection object.\n      context.connection.removeListener(ConnectionEvents.connectionOpen, onConnectionOpen);\n      context.connection.removeListener(ConnectionEvents.disconnected, onDisconnected);\n      context.connection.removeListener(ConnectionEvents.protocolError, protocolError);\n      context.connection.removeListener(ConnectionEvents.error, error);\n      // Close the connection\n      return context.connection.close();\n    }\n\n    async function refreshConnection(context: ConnectionContext): Promise<void> {\n      const originalConnectionId = context.connectionId;\n      try {\n        await cleanConnectionContext(context);\n      } catch (err: any) {\n        logger.verbose(\n          `[${context.connectionId}] There was an error closing the connection before reconnecting: %O`,\n          err\n        );\n      }\n\n      // Create a new connection, id, locks, and cbs client.\n      context.refreshConnection();\n      addConnectionListeners(context.connection);\n      logger.verbose(\n        `The connection \"${originalConnectionId}\" has been updated to \"${context.connectionId}\".`\n      );\n    }\n\n    addConnectionListeners(connectionContext.connection);\n\n    logger.verbose(\"[%s] Created connection context successfully.\", connectionContext.connectionId);\n    return connectionContext;\n  }\n}\n\n/**\n * Helper method to create a ConnectionContext from the input passed to either\n * EventHubProducerClient or EventHubConsumerClient constructors\n *\n * @internal\n */\nexport function createConnectionContext(\n  hostOrConnectionString: string,\n  eventHubNameOrOptions?: string | EventHubClientOptions,\n  credentialOrOptions?:\n    | TokenCredential\n    | NamedKeyCredential\n    | SASCredential\n    | EventHubClientOptions,\n  options?: EventHubClientOptions\n): ConnectionContext {\n  let connectionString;\n  let config;\n  let credential: TokenCredential | SasTokenProvider;\n  hostOrConnectionString = String(hostOrConnectionString);\n\n  if (!isCredential(credentialOrOptions)) {\n    const parsedCS = parseEventHubConnectionString(hostOrConnectionString);\n    if (\n      !(\n        parsedCS.eventHubName ||\n        (typeof eventHubNameOrOptions === \"string\" && eventHubNameOrOptions)\n      )\n    ) {\n      throw new TypeError(\n        `Either provide \"eventHubName\" or the \"connectionString\": \"${hostOrConnectionString}\", ` +\n          `must contain \"EntityPath=<your-event-hub-name>\".`\n      );\n    }\n    if (\n      parsedCS.eventHubName &&\n      typeof eventHubNameOrOptions === \"string\" &&\n      eventHubNameOrOptions &&\n      parsedCS.eventHubName !== eventHubNameOrOptions\n    ) {\n      throw new TypeError(\n        `The entity path \"${parsedCS.eventHubName}\" in connectionString: \"${hostOrConnectionString}\" ` +\n          `doesn't match with eventHubName: \"${eventHubNameOrOptions}\".`\n      );\n    }\n    connectionString = hostOrConnectionString;\n    if (typeof eventHubNameOrOptions !== \"string\") {\n      // connectionstring and/or options were passed to constructor\n      config = EventHubConnectionConfig.create(connectionString);\n      options = eventHubNameOrOptions;\n    } else {\n      // connectionstring, eventHubName and/or options were passed to constructor\n      const eventHubName = eventHubNameOrOptions;\n      config = EventHubConnectionConfig.create(connectionString, eventHubName);\n      options = credentialOrOptions;\n    }\n\n    const parsed = parseEventHubConnectionString(connectionString) as Required<\n      | Pick<EventHubConnectionStringProperties, \"sharedAccessKey\" | \"sharedAccessKeyName\">\n      | Pick<EventHubConnectionStringProperties, \"sharedAccessSignature\">\n    >;\n    // Since connectionString was passed, create a TokenProvider.\n    credential = createSasTokenProvider(parsed);\n  } else {\n    // host, eventHubName, a TokenCredential and/or options were passed to constructor\n    const eventHubName = eventHubNameOrOptions;\n    let host = hostOrConnectionString;\n    if (isNamedKeyCredential(credentialOrOptions) || isSASCredential(credentialOrOptions)) {\n      credential = createSasTokenProvider(credentialOrOptions);\n    } else {\n      credential = credentialOrOptions;\n    }\n    if (!eventHubName) {\n      throw new TypeError(`\"eventHubName\" is missing`);\n    }\n\n    if (!host.endsWith(\"/\")) host += \"/\";\n    connectionString = `Endpoint=sb://${host};SharedAccessKeyName=defaultKeyName;SharedAccessKey=defaultKeyValue;EntityPath=${eventHubName}`;\n    config = EventHubConnectionConfig.create(connectionString);\n  }\n\n  if (options?.customEndpointAddress) {\n    EventHubConnectionConfig.setCustomEndpointAddress(config, options.customEndpointAddress);\n  }\n\n  ConnectionConfig.validate(config);\n\n  return ConnectionContext.create(config, credential, options);\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { PartitionOwnership } from \"../eventProcessor\";\nimport { logger } from \"../logger\";\n\n/**\n * Determines which partitions to claim as part of load balancing.\n * @internal\n */\nexport interface LoadBalancingStrategy {\n  /**\n   * Implements load balancing by taking into account current ownership and\n   * the full set of partitions in the Event Hub.\n   * @param ourOwnerId - The id we should assume is _our_ id when checking for ownership.\n   * @param claimedPartitionOwnershipMap - The current claimed ownerships for partitions.\n   * @param partitionIds - Partitions to assign owners to.\n   * @returns Partition ids to claim.\n   */\n  getPartitionsToClaim(\n    ownerId: string,\n    claimedPartitionOwnershipMap: Map<string, PartitionOwnership>,\n    partitionIds: string[]\n  ): string[];\n}\n\n/**\n * Counts of the EventProcessors that currently own partitions.\n * @internal\n */\ninterface EventProcessorCounts {\n  /**\n   * The # of EventProcessors that only own the required # of\n   * partitions.\n   */\n  haveRequiredPartitions: number;\n  /**\n   * The # of EventProcessors that currently own the required #\n   * of partitions + 1 additional (ie, handling the case where\n   * the number of partitions is not evenly divisible by the # of\n   * EventProcessors).\n   */\n  haveAdditionalPartition: number;\n  /**\n   * EventProcessors which have more than the required or even required + 1\n   * number of partitions. These will eventually be downsized by other\n   * EventProcessors as they acquire their required number of partitions.\n   */\n  haveTooManyPartitions: number;\n}\n\n/**\n * This method will create a new map of partition id and PartitionOwnership containing only those partitions\n * that are actively owned.\n * All entries in the original map that haven't been modified for a duration of time greater than the allowed\n * inactivity time limit are assumed to be owned by dead event processors.\n * These will not be included in the map returned by this method.\n *\n * @param partitionOwnershipMap - The existing PartitionOwnerships mapped by partition.\n * @param expirationIntervalInMs - The length of time a PartitionOwnership claim is valid.\n */\nfunction getActivePartitionOwnerships(\n  partitionOwnershipMap: Map<string, PartitionOwnership>,\n  expirationIntervalInMs: number\n): Map<string, PartitionOwnership> {\n  const activePartitionOwnershipMap: Map<string, PartitionOwnership> = new Map();\n  partitionOwnershipMap.forEach((partitionOwnership: PartitionOwnership, partitionId: string) => {\n    // If lastModifiedtimeInMs is missing, assume it is inactive.\n    if (\n      typeof partitionOwnership.lastModifiedTimeInMs === \"undefined\" ||\n      partitionOwnership.lastModifiedTimeInMs === null\n    ) {\n      return;\n    }\n\n    const timeSincePartitionClaimed = Date.now() - partitionOwnership.lastModifiedTimeInMs;\n    if (timeSincePartitionClaimed < expirationIntervalInMs && partitionOwnership.ownerId) {\n      activePartitionOwnershipMap.set(partitionId, partitionOwnership);\n    }\n  });\n\n  return activePartitionOwnershipMap;\n}\n\n/**\n * Calculates the minimum number of partitions each EventProcessor should own,\n * and the number of EventProcessors that should have an extra partition assigned.\n * @param ownerToOwnershipMap - The current ownerships for partitions.\n * @param partitionIds - The full list of the Event Hub's partition ids.\n * @internal\n */\nfunction calculateBalancedLoadCounts(\n  ownerToOwnershipMap: Map<string, PartitionOwnership[]>,\n  partitionIds: string[]\n): { minPartitionsPerOwner: number; requiredNumberOfOwnersWithExtraPartition: number } {\n  // Calculate the minimum number of partitions every EventProcessor should own when the load\n  // is evenly distributed.\n  const minPartitionsPerOwner = Math.floor(partitionIds.length / ownerToOwnershipMap.size);\n\n  // If the number of partitions in the Event Hub is not evenly divisible by the number of active\n  // EventProcesrrors, some EventProcessors may own 1 partition in addition to the minimum when the\n  // load is balanced.\n  // Calculate the number of EventProcessors that can own an additional partition.\n  const requiredNumberOfOwnersWithExtraPartition = partitionIds.length % ownerToOwnershipMap.size;\n\n  return {\n    minPartitionsPerOwner,\n    requiredNumberOfOwnersWithExtraPartition,\n  };\n}\n\n/**\n * Counts the EventProcessors and tallies them by type.\n *\n * To be in balance we need to make sure that each EventProcessor is only consuming\n * their fair share.\n *\n * When the partitions are divvied up we will sometimes end up with some EventProcessors\n * that will have 1 more partition than others.\n * This can happen if the number of partitions is not evenly divisible by the number of EventProcessors.\n *\n * So this function largely exists to support isLoadBalanced() and\n * shouldOwnMorePartitions(), both of which depend on knowing if our current list\n * of EventProcessors is actually in the proper state.\n *\n * @param minPartitionsPerOwner - The number of required partitions per EventProcessor.\n * @param ownerToOwnershipMap - The current ownerships for partitions.\n * @internal\n */\nfunction getEventProcessorCounts(\n  minPartitionsPerOwner: number,\n  ownerToOwnershipMap: Map<string, PartitionOwnership[]>\n): EventProcessorCounts {\n  const counts: EventProcessorCounts = {\n    haveRequiredPartitions: 0,\n    haveAdditionalPartition: 0,\n    haveTooManyPartitions: 0,\n  };\n\n  for (const ownershipList of ownerToOwnershipMap.values()) {\n    const numberOfPartitions = ownershipList.length;\n\n    // there are basically three kinds of partition counts\n    // for a processor:\n\n    if (numberOfPartitions === minPartitionsPerOwner) {\n      // 1. Has _exactly_ the required number of partitions\n      counts.haveRequiredPartitions++;\n    } else if (numberOfPartitions === minPartitionsPerOwner + 1) {\n      // 2. Has the required number plus one extra (correct in cases)\n      // where the # of partitions is not evenly divisible by the\n      // number of processors.\n      counts.haveAdditionalPartition++;\n    } else if (numberOfPartitions > minPartitionsPerOwner + 1) {\n      // 3. has more than the possible # of partitions required\n      counts.haveTooManyPartitions++;\n    }\n  }\n\n  return counts;\n}\n\n/**\n * Validates that we are currently in a balanced state - all EventProcessors own the\n * minimum required number of partitions (and additional partitions, if the # of partitions\n * is not evenly divisible by the # of EventProcessors).\n *\n * @param requiredNumberOfOwnersWithExtraPartition - The # of EventProcessors that process an additional partition, in addition to the required minimum.\n * @param totalExpectedProcessors - The total # of EventProcessors we expect.\n * @param eventProcessorCounts - EventProcessor counts, grouped by criteria.\n * @internal\n */\nfunction isLoadBalanced(\n  requiredNumberOfOwnersWithExtraPartition: number,\n  totalExpectedEventProcessors: number,\n  { haveAdditionalPartition, haveRequiredPartitions }: EventProcessorCounts\n): boolean {\n  return (\n    haveAdditionalPartition === requiredNumberOfOwnersWithExtraPartition &&\n    haveRequiredPartitions + haveAdditionalPartition === totalExpectedEventProcessors\n  );\n}\n\n/**\n * Determines the number of new partitions to claim for this particular processor.\n *\n * @param minRequired - The minimum required number of partitions.\n * @param requiredNumberOfOwnersWithExtraPartition - The current number of processors that should have an additional partition.\n * @param numPartitionsOwnedByUs - The number of partitions we currently own.\n * @param eventProcessorCounts - Processors, grouped by criteria.\n * @internal\n */\nfunction getNumberOfPartitionsToClaim(\n  minRequiredPartitionCount: number,\n  requiredNumberOfOwnersWithExtraPartition: number,\n  numPartitionsOwnedByUs: number,\n  { haveAdditionalPartition, haveTooManyPartitions }: EventProcessorCounts\n): number {\n  let actualRequiredPartitionCount = minRequiredPartitionCount;\n\n  if (\n    requiredNumberOfOwnersWithExtraPartition > 0 &&\n    // Eventually the `haveTooManyPartitions` will decay into `haveAdditionalPartition`\n    // EventProcessors as partitions are balanced to consumers that aren't at par.\n    // We can consider them to be `haveAdditionalPartition` EventProcessors for our purposes.\n    haveAdditionalPartition + haveTooManyPartitions < requiredNumberOfOwnersWithExtraPartition\n  ) {\n    // Overall we don't have enough EventProcessors that are taking on an additional partition\n    // so we should attempt to.\n    actualRequiredPartitionCount = minRequiredPartitionCount + 1;\n  }\n  return actualRequiredPartitionCount - numPartitionsOwnedByUs;\n}\n\n/**\n * Determines which partitions can be stolen from other owners while maintaining\n * a balanced state.\n * @param numberOfPartitionsToClaim - The number of partitions the owner needs to claim to reach a balanced state.\n * @param minPartitionsPerOwner - The minimum number of partitions each owner needs for the partition load to be balanced.\n * @param requiredNumberOfOwnersWithExtraPartition - The number of owners that should have 1 extra partition.\n * @param ourOwnerId - The id of _our_ owner.\n * @param ownerToOwnershipMap - The current ownerships for partitions.\n * @internal\n */\nfunction findPartitionsToSteal(\n  numberOfPartitionsToClaim: number,\n  minPartitionsPerOwner: number,\n  requiredNumberOfOwnersWithExtraPartition: number,\n  ourOwnerId: string,\n  ownerToOwnershipMap: Map<string, PartitionOwnership[]>\n): string[] {\n  const partitionsToSteal: string[] = [];\n  // Create a list of PartitionOwnership lists that we can steal from.\n  const listOfPartitionOwnerships: Array<PartitionOwnership[]> = [];\n  ownerToOwnershipMap.forEach((partitionOwnerships, ownerId) => {\n    if (ownerId === ourOwnerId || partitionOwnerships.length <= minPartitionsPerOwner) return;\n    listOfPartitionOwnerships.push(partitionOwnerships);\n  });\n\n  // Sort the list in descending order based on the length of each element.\n  listOfPartitionOwnerships.sort((a, b) => {\n    if (a.length > b.length) return -1;\n    if (a.length < b.length) return 1;\n    return 0;\n  });\n\n  // Attempt to steal partitions from EventProcessors that have the most partitions 1st,\n  // then work our way down.\n  let ownersEncounteredWithExtraPartitions = 0;\n  let currentPartitionOwnershipList = listOfPartitionOwnerships.shift();\n  while (numberOfPartitionsToClaim > 0 && currentPartitionOwnershipList) {\n    let ownersExpectedPartitionCount = minPartitionsPerOwner;\n    // Determine if the current owner should be allowed to have an extra partition.\n    if (ownersEncounteredWithExtraPartitions < requiredNumberOfOwnersWithExtraPartition) {\n      ownersExpectedPartitionCount++;\n    }\n    ownersEncounteredWithExtraPartitions++;\n\n    let numberAvailableToSteal =\n      currentPartitionOwnershipList.length - ownersExpectedPartitionCount;\n    // Claim as many random partitions as possible.\n    while (Math.min(numberOfPartitionsToClaim, numberAvailableToSteal)) {\n      const indexToClaim = Math.floor(Math.random() * currentPartitionOwnershipList.length);\n      partitionsToSteal.push(currentPartitionOwnershipList.splice(indexToClaim, 1)[0].partitionId);\n      numberOfPartitionsToClaim--;\n      numberAvailableToSteal--;\n    }\n\n    // Move on to the next list of PartitionOwnership.\n    currentPartitionOwnershipList = listOfPartitionOwnerships.shift();\n  }\n\n  return partitionsToSteal;\n}\n\n/**\n * Identifies all of the partitions that can be claimed by the specified owner for\n * that owner to reach a balanced state.\n * @param OwnerId - The id we should assume is _our_ id when checking for ownership.\n * @param claimedPartitionOwnershipMap - The current claimed ownerships for partitions.\n * @param partitionIds - Partitions to assign owners to.\n * @param expirationIntervalInMs - The length of time a partition claim is valid.\n * @returns Partition ids that may be claimed.\n * @internal\n */\nexport function listAvailablePartitions(\n  ownerId: string,\n  claimedPartitionOwnershipMap: Map<string, PartitionOwnership>,\n  partitionIds: string[],\n  expirationIntervalInMs: number\n): string[] {\n  if (!partitionIds.length) {\n    return [];\n  }\n\n  // Collect only the PartitionOwnership that have been updated within the expiration interval.\n  // Any PartitionOwnership that has been updated outside the expiration interval can be claimed.\n  const activePartitionOwnershipMap = getActivePartitionOwnerships(\n    claimedPartitionOwnershipMap,\n    expirationIntervalInMs\n  );\n  logger.verbose(\n    `[${ownerId}] Number of active ownership records: ${activePartitionOwnershipMap.size}.`\n  );\n\n  if (activePartitionOwnershipMap.size === 0) {\n    // All partitions in this Event Hub are available to claim.\n    return partitionIds;\n  }\n\n  // Map ownerIds to the partitions they own so that we can determine how many each owner has.\n  const ownerToOwnershipMap = new Map<string, PartitionOwnership[]>();\n  for (const activeOwnership of activePartitionOwnershipMap.values()) {\n    const partitionOwnershipList = ownerToOwnershipMap.get(activeOwnership.ownerId) || [];\n\n    partitionOwnershipList.push(activeOwnership);\n    ownerToOwnershipMap.set(activeOwnership.ownerId, partitionOwnershipList);\n  }\n\n  // Add the current EventProcessor to the map of owners to ownerships if it doesn't exist.\n  if (!ownerToOwnershipMap.has(ownerId)) {\n    ownerToOwnershipMap.set(ownerId, []);\n  }\n\n  logger.info(`[${ownerId}] Number of active event processors: ${ownerToOwnershipMap.size}.`);\n\n  const { minPartitionsPerOwner, requiredNumberOfOwnersWithExtraPartition } =\n    calculateBalancedLoadCounts(ownerToOwnershipMap, partitionIds);\n\n  logger.verbose(\n    `[${ownerId}] Expected minimum number of partitions per event processor: ${minPartitionsPerOwner},` +\n      `expected number of event processors with additional partition: ${requiredNumberOfOwnersWithExtraPartition}.`\n  );\n\n  // Get some stats representing the current state the world with regards to how balanced the\n  // partitions are across EventProcessors.\n  const eventProcessorCounts = getEventProcessorCounts(minPartitionsPerOwner, ownerToOwnershipMap);\n\n  if (\n    isLoadBalanced(\n      requiredNumberOfOwnersWithExtraPartition,\n      ownerToOwnershipMap.size,\n      eventProcessorCounts\n    )\n  ) {\n    // When the partitions are evenly distributed, no change required.\n    return [];\n  }\n\n  let numberOfPartitionsToClaim = getNumberOfPartitionsToClaim(\n    minPartitionsPerOwner,\n    requiredNumberOfOwnersWithExtraPartition,\n    ownerToOwnershipMap.get(ownerId)!.length,\n    eventProcessorCounts\n  );\n\n  if (numberOfPartitionsToClaim <= 0) {\n    return [];\n  }\n\n  const partitionsToClaim: string[] = [];\n  const unclaimedPartitionIds = partitionIds.filter((id) => !activePartitionOwnershipMap.has(id));\n\n  // Prioritize getting unclaimed partitions first.\n  while (Math.min(numberOfPartitionsToClaim, unclaimedPartitionIds.length)) {\n    const indexToClaim = Math.floor(Math.random() * unclaimedPartitionIds.length);\n    partitionsToClaim.push(unclaimedPartitionIds.splice(indexToClaim, 1)[0]);\n    numberOfPartitionsToClaim--;\n  }\n\n  if (numberOfPartitionsToClaim === 0) {\n    return partitionsToClaim;\n  }\n\n  // Find partitions that can be stolen from other EventProcessors.\n  const partitionsToSteal = findPartitionsToSteal(\n    numberOfPartitionsToClaim,\n    minPartitionsPerOwner,\n    requiredNumberOfOwnersWithExtraPartition,\n    ownerId,\n    ownerToOwnershipMap\n  );\n\n  return partitionsToClaim.concat(partitionsToSteal);\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { LoadBalancingStrategy, listAvailablePartitions } from \"./loadBalancingStrategy\";\nimport { PartitionOwnership } from \"../eventProcessor\";\n\n/**\n * The BalancedLoadBalancerStrategy is meant to be used when the user\n * wants to reach a load balanced state with less partition 'thrashing'.\n *\n * Partition thrashing - where a partition changes owners - is minimized\n * by only returning a single partition to claim at a time.\n * This minimizes the number of times a partition should need to be stolen.\n * @internal\n */\nexport class BalancedLoadBalancingStrategy implements LoadBalancingStrategy {\n  /**\n   * Creates an instance of BalancedLoadBalancingStrategy.\n   *\n   * @param _partitionOwnershipExpirationIntervalInMs - The length of time a partition claim is valid.\n   */\n  constructor(private readonly _partitionOwnershipExpirationIntervalInMs: number) {}\n\n  /**\n   * Implements load balancing by taking into account current ownership and\n   * the full set of partitions in the Event Hub.\n   * @param ourOwnerId - The id we should assume is _our_ id when checking for ownership.\n   * @param claimedPartitionOwnershipMap - The current claimed ownerships for partitions.\n   * @param partitionIds - Partitions to assign owners to.\n   * @returns Partition ids to claim.\n   */\n  public getPartitionsToClaim(\n    ourOwnerId: string,\n    claimedPartitionOwnershipMap: Map<string, PartitionOwnership>,\n    partitionIds: string[]\n  ): string[] {\n    const claimablePartitions = listAvailablePartitions(\n      ourOwnerId,\n      claimedPartitionOwnershipMap,\n      partitionIds,\n      this._partitionOwnershipExpirationIntervalInMs\n    );\n\n    if (!claimablePartitions.length) {\n      return [];\n    }\n\n    const randomIndex = Math.floor(Math.random() * claimablePartitions.length);\n    return [claimablePartitions[randomIndex]];\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { LoadBalancingStrategy, listAvailablePartitions } from \"./loadBalancingStrategy\";\nimport { PartitionOwnership } from \"../eventProcessor\";\n\n/**\n * @internal\n */\nexport class GreedyLoadBalancingStrategy implements LoadBalancingStrategy {\n  /**\n   * Creates an instance of GreedyLoadBalancingStrategy.\n   *\n   * @param _partitionOwnershipExpirationIntervalInMs - The length of time a partition claim is valid.\n   */\n  constructor(private readonly _partitionOwnershipExpirationIntervalInMs: number) {}\n\n  /**\n   * Implements load balancing by taking into account current ownership and\n   * the new set of partitions to add.\n   * @param ourOwnerId - The id we should assume is _our_ id when checking for ownership.\n   * @param claimedPartitionOwnershipMap - The current claimed ownerships for partitions.\n   * @param partitionIds - Partitions to assign owners to.\n   * @returns Partition ids to claim.\n   */\n  public getPartitionsToClaim(\n    ourOwnerId: string,\n    claimedPartitionOwnershipMap: Map<string, PartitionOwnership>,\n    partitionIds: string[]\n  ): string[] {\n    return listAvailablePartitions(\n      ourOwnerId,\n      claimedPartitionOwnershipMap,\n      partitionIds,\n      this._partitionOwnershipExpirationIntervalInMs\n    );\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { CheckpointStore, PartitionOwnership } from \"./eventProcessor\";\nimport { Checkpoint } from \"./partitionProcessor\";\nimport { throwTypeErrorIfParameterMissing } from \"./util/error\";\nimport { getRandomName } from \"./util/utils\";\n\n/**\n * The `EventProcessor` relies on a `CheckpointStore` to store checkpoints and handle partition\n * ownerships. `InMemoryCheckpointStore` is simple partition manager that stores checkpoints and\n * partition ownerships in memory of your program.\n *\n * You can use the `InMemoryCheckpointStore` to get started with using the `EventProcessor`.\n * But in production, you should choose an implementation of the `CheckpointStore` interface that will\n * store the checkpoints and partition ownerships to a durable store instead.\n *\n * @internal\n */\nexport class InMemoryCheckpointStore implements CheckpointStore {\n  private _partitionOwnershipMap: Map<string, PartitionOwnership> = new Map();\n  private _committedCheckpoints: Map<string, Map<string, Checkpoint>> = new Map();\n\n  /**\n   * Get the list of all existing partition ownership from the underlying data store. Could return empty\n   * results if there are is no existing ownership information.\n   *\n   * @param fullyQualifiedNamespace - The fully qualified Event Hubs namespace. This is likely to be similar to\n   * <yournamespace>.servicebus.windows.net.\n   * @param eventHubName - The event hub name.\n   * @param consumerGroup - The consumer group name.\n   * @returns Partition ownership details of all the partitions that have/had an owner..\n   */\n  async listOwnership(\n    _fullyQualifiedNamespace: string,\n    _eventHubName: string,\n    _consumerGroup: string\n  ): Promise<PartitionOwnership[]> {\n    const ownerships = [];\n\n    for (const value of this._partitionOwnershipMap.values()) {\n      ownerships.push({ ...value });\n    }\n\n    return ownerships;\n  }\n\n  /**\n   * Claim ownership of a list of partitions. This will return the list of partitions that were owned\n   * successfully.\n   *\n   * @param partitionOwnership - The list of partition ownership this instance is claiming to own.\n   * @returns A list partitions this instance successfully claimed ownership.\n   */\n  async claimOwnership(partitionOwnership: PartitionOwnership[]): Promise<PartitionOwnership[]> {\n    const claimedOwnerships = [];\n\n    for (const ownership of partitionOwnership) {\n      if (\n        !this._partitionOwnershipMap.has(ownership.partitionId) ||\n        this._partitionOwnershipMap.get(ownership.partitionId)!.etag === ownership.etag\n      ) {\n        const date = new Date();\n\n        const newOwnership = {\n          ...ownership,\n          etag: getRandomName(),\n          lastModifiedTimeInMs: date.getTime(),\n        };\n\n        this._partitionOwnershipMap.set(newOwnership.partitionId, newOwnership);\n        claimedOwnerships.push(newOwnership);\n      }\n    }\n    return claimedOwnerships;\n  }\n\n  /**\n   * Updates the checkpoint in the data store for a partition.\n   *\n   * @param checkpoint - The checkpoint.\n   */\n  async updateCheckpoint(checkpoint: Checkpoint): Promise<void> {\n    throwTypeErrorIfParameterMissing(\n      \"\",\n      \"updateCheckpoint\",\n      \"sequenceNumber\",\n      checkpoint.sequenceNumber\n    );\n    throwTypeErrorIfParameterMissing(\"\", \"updateCheckpoint\", \"offset\", checkpoint.offset);\n\n    checkpoint = { ...checkpoint };\n\n    const partitionOwnership = this._partitionOwnershipMap.get(checkpoint.partitionId);\n    if (partitionOwnership) {\n      partitionOwnership.etag = getRandomName();\n\n      const key = `${checkpoint.fullyQualifiedNamespace}:${checkpoint.eventHubName}:${checkpoint.consumerGroup}`;\n      let partitionMap = this._committedCheckpoints.get(key);\n\n      if (partitionMap == null) {\n        partitionMap = new Map();\n        this._committedCheckpoints.set(key, partitionMap);\n      }\n\n      partitionMap.set(checkpoint.partitionId, checkpoint);\n    }\n  }\n\n  async listCheckpoints(\n    fullyQualifiedNamespace: string,\n    eventHubName: string,\n    consumerGroup: string\n  ): Promise<Checkpoint[]> {\n    const key = `${fullyQualifiedNamespace}:${eventHubName}:${consumerGroup}`;\n\n    const partitionMap = this._committedCheckpoints.get(key);\n\n    if (partitionMap == null) {\n      return [];\n    }\n\n    const checkpoints = [];\n\n    for (const value of partitionMap.values()) {\n      checkpoints.push({ ...value });\n    }\n\n    return checkpoints;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/**\n * Used by EventHubConsumerClient to prevent accidentally spinning up multiple\n * subscriptions against the same set of partitions.\n *\n * This is needed now that EventHubConsumerClient only uses a single CheckpointStore\n * instance - otherwise users will see unpredictable results as their event processor\n * continually steals/overwrites checkpointing and ownership with itself.\n *\n * @internal\n */\nexport class PartitionGate {\n  private _partitions = new Set<string>();\n\n  /**\n   * Adds a partition, throwing an Error if there is a conflict with partitions (including \"all\")\n   * that are already added.\n   *\n   * @param partitionId - A partition ID or the constant \"all\"\n   */\n  add(partitionId: string | \"all\"): void {\n    if (\n      (partitionId === \"all\" && this._partitions.size > 0) ||\n      this._partitions.has(partitionId) ||\n      this._partitions.has(\"all\")\n    ) {\n      throw new Error(`Partition already has a subscriber.`);\n    }\n\n    this._partitions.add(partitionId);\n  }\n\n  /**\n   * Removes a partition\n   *\n   * @param partitionId - A partition ID or the constant \"all\"\n   */\n  remove(partitionId: string | \"all\"): void {\n    this._partitions.delete(partitionId);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { LoadBalancingStrategy } from \"./loadBalancingStrategy\";\nimport { PartitionOwnership } from \"../eventProcessor\";\n\n/**\n * The UnbalancedLoadBalancingStrategy does no actual load balancing.\n * It is intended to be used when you want to avoid load balancing\n * and consume a set of partitions.\n * @internal\n */\nexport class UnbalancedLoadBalancingStrategy implements LoadBalancingStrategy {\n  /**\n   * Implements load balancing by taking into account current ownership and\n   * the full set of partitions in the Event Hub.\n   * @param _ourOwnerId - The id we should assume is _our_ id when checking for ownership.\n   * @param _claimedPartitionOwnershipMap - The current claimed ownerships for partitions.\n   * @param partitionIds - Partitions to assign owners to.\n   * @returns Partition ids to claim.\n   */\n  public getPartitionsToClaim(\n    _ourOwnerId: string,\n    _claimedPartitionOwnershipMap: Map<string, PartitionOwnership>,\n    partitionIds: string[]\n  ): string[] {\n    return partitionIds;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { CheckpointStore, EventProcessor, FullEventProcessorOptions } from \"./eventProcessor\";\nimport { ConnectionContext, createConnectionContext } from \"./connectionContext\";\nimport {\n  EventHubConsumerClientOptions,\n  GetEventHubPropertiesOptions,\n  GetPartitionIdsOptions,\n  GetPartitionPropertiesOptions,\n  LoadBalancingOptions,\n} from \"./models/public\";\nimport { EventHubProperties, PartitionProperties } from \"./managementClient\";\nimport { NamedKeyCredential, SASCredential, TokenCredential } from \"@azure/core-auth\";\nimport {\n  SubscribeOptions,\n  Subscription,\n  SubscriptionEventHandlers,\n} from \"./eventHubConsumerClientModels\";\nimport { BalancedLoadBalancingStrategy } from \"./loadBalancerStrategies/balancedStrategy\";\nimport { Constants } from \"@azure/core-amqp\";\nimport { GreedyLoadBalancingStrategy } from \"./loadBalancerStrategies/greedyStrategy\";\nimport { InMemoryCheckpointStore } from \"./inMemoryCheckpointStore\";\nimport { LoadBalancingStrategy } from \"./loadBalancerStrategies/loadBalancingStrategy\";\nimport { PartitionGate } from \"./impl/partitionGate\";\nimport { UnbalancedLoadBalancingStrategy } from \"./loadBalancerStrategies/unbalancedStrategy\";\nimport { isCredential } from \"./util/typeGuards\";\nimport { logger } from \"./logger\";\nimport { validateEventPositions } from \"./eventPosition\";\nimport { getRandomName } from \"./util/utils\";\n\nconst defaultConsumerClientOptions: Required<\n  Pick<FullEventProcessorOptions, \"maxWaitTimeInSeconds\" | \"maxBatchSize\">\n> = {\n  // to support our current \"process single event only\" workflow we'll also purposefully\n  // only request a single event at a time.\n  maxBatchSize: 1,\n  maxWaitTimeInSeconds: 60,\n};\n\n/**\n * The `EventHubConsumerClient` class is used to consume events from an Event Hub.\n *\n * There are multiple ways to create an `EventHubConsumerClient`\n * - Use the connection string from the SAS policy created for your Event Hub instance.\n * - Use the connection string from the SAS policy created for your Event Hub namespace,\n * and the name of the Event Hub instance\n * - Use the full namespace like `<yournamespace>.servicebus.windows.net`, and a credentials object.\n *\n * Optionally, you can also pass:\n * - An options bag to configure the retry policy or proxy settings.\n * - A checkpoint store that is used by the client to read checkpoints to determine the position from where it should\n * resume receiving events when your application gets restarted. The checkpoint store is also used by the client\n * to load balance multiple instances of your application.\n */\nexport class EventHubConsumerClient {\n  /**\n   * Describes the amqp connection context for the client.\n   */\n  private _context: ConnectionContext;\n  /**\n   * The options passed by the user when creating the EventHubClient instance.\n   */\n  private _clientOptions: EventHubConsumerClientOptions;\n  private _partitionGate = new PartitionGate();\n  private _id = getRandomName();\n\n  /**\n   * The Subscriptions that were spawned by calling `subscribe()`.\n   * Subscriptions that have been stopped by the user will not\n   * be present in this set.\n   */\n  private _subscriptions = new Set<Subscription>();\n\n  /**\n   * The name of the default consumer group in the Event Hubs service.\n   */\n  static defaultConsumerGroupName: string = Constants.defaultConsumerGroup;\n\n  private _checkpointStore: CheckpointStore;\n  private _userChoseCheckpointStore: boolean;\n\n  /**\n   * Options for configuring load balancing.\n   */\n  private readonly _loadBalancingOptions: Required<LoadBalancingOptions>;\n\n  /**\n   * @readonly\n   * The name of the Event Hub instance for which this client is created.\n   */\n  get eventHubName(): string {\n    return this._context.config.entityPath;\n  }\n\n  /**\n   * @readonly\n   * The fully qualified namespace of the Event Hub instance for which this client is created.\n   * This is likely to be similar to <yournamespace>.servicebus.windows.net.\n   */\n  get fullyQualifiedNamespace(): string {\n    return this._context.config.host;\n  }\n\n  /**\n   * The `EventHubConsumerClient` class is used to consume events from an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param consumerGroup - The name of the consumer group from which you want to process events.\n   * @param connectionString - The connection string to use for connecting to the Event Hub instance.\n   * It is expected that the shared key properties and the Event Hub path are contained in this connection string.\n   * e.g. 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key;EntityPath=my-event-hub-name'.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(\n    consumerGroup: string,\n    connectionString: string,\n    options?: EventHubConsumerClientOptions\n  ); // #1\n  /**\n   * The `EventHubConsumerClient` class is used to consume events from an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param consumerGroup - The name of the consumer group from which you want to process events.\n   * @param connectionString - The connection string to use for connecting to the Event Hub instance.\n   * It is expected that the shared key properties and the Event Hub path are contained in this connection string.\n   * e.g. 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key;EntityPath=my-event-hub-name'.\n   * @param checkpointStore - A checkpoint store that is used by the client to read checkpoints to determine\n   * the position from where it should resume receiving events when your application gets restarted.\n   * It is also used by the client to load balance multiple instances of your application.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(\n    consumerGroup: string,\n    connectionString: string,\n    checkpointStore: CheckpointStore,\n    options?: EventHubConsumerClientOptions\n  ); // #1.1\n  /**\n   * The `EventHubConsumerClient` class is used to consume events from an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param consumerGroup - The name of the consumer group from which you want to process events.\n   * @param connectionString - The connection string to use for connecting to the Event Hubs namespace.\n   * It is expected that the shared key properties are contained in this connection string, but not the Event Hub path,\n   * e.g. 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key;'.\n   * @param eventHubName - The name of the specific Event Hub to connect the client to.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(\n    consumerGroup: string,\n    connectionString: string,\n    eventHubName: string,\n    options?: EventHubConsumerClientOptions\n  ); // #2\n  /**\n   * The `EventHubConsumerClient` class is used to consume events from an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param consumerGroup - The name of the consumer group from which you want to process events.\n   * @param connectionString - The connection string to use for connecting to the Event Hubs namespace.\n   * It is expected that the shared key properties are contained in this connection string, but not the Event Hub path,\n   * e.g. 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key;'.\n   * @param eventHubName - The name of the specific Event Hub to connect the client to.\n   * @param checkpointStore - A checkpoint store that is used by the client to read checkpoints to determine\n   * the position from where it should resume receiving events when your application gets restarted.\n   * It is also used by the client to load balance multiple instances of your application.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(\n    consumerGroup: string,\n    connectionString: string,\n    eventHubName: string,\n    checkpointStore: CheckpointStore,\n    options?: EventHubConsumerClientOptions\n  ); // #2.1\n  /**\n   * The `EventHubConsumerClient` class is used to consume events from an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param consumerGroup - The name of the consumer group from which you want to process events.\n   * @param fullyQualifiedNamespace - The full namespace which is likely to be similar to\n   * <yournamespace>.servicebus.windows.net\n   * @param eventHubName - The name of the specific Event Hub to connect the client to.\n   * @param credential - An credential object used by the client to get the token to authenticate the connection\n   * with the Azure Event Hubs service.\n   * See &commat;azure/identity for creating credentials that support AAD auth.\n   * Use the `AzureNamedKeyCredential` from &commat;azure/core-auth if you want to pass in a `SharedAccessKeyName`\n   * and `SharedAccessKey` without using a connection string. These fields map to the `name` and `key` field respectively\n   * in `AzureNamedKeyCredential`.\n   * Use the `AzureSASCredential` from &commat;azure/core-auth if you want to pass in a `SharedAccessSignature`\n   * without using a connection string. This field maps to `signature` in `AzureSASCredential`.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(\n    consumerGroup: string,\n    fullyQualifiedNamespace: string,\n    eventHubName: string,\n    credential: TokenCredential | NamedKeyCredential | SASCredential,\n    options?: EventHubConsumerClientOptions\n  ); // #3\n  /**\n   * The `EventHubConsumerClient` class is used to consume events from an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param consumerGroup - The name of the consumer group from which you want to process events.\n   * @param fullyQualifiedNamespace - The full namespace which is likely to be similar to\n   * <yournamespace>.servicebus.windows.net\n   * @param eventHubName - The name of the specific Event Hub to connect the client to.\n   * @param credential - An credential object used by the client to get the token to authenticate the connection\n   * with the Azure Event Hubs service.\n   * See &commat;azure/identity for creating credentials that support AAD auth.\n   * Use the `AzureNamedKeyCredential` from &commat;azure/core-auth if you want to pass in a `SharedAccessKeyName`\n   * and `SharedAccessKey` without using a connection string. These fields map to the `name` and `key` field respectively\n   * in `AzureNamedKeyCredential`.\n   * Use the `AzureSASCredential` from &commat;azure/core-auth if you want to pass in a `SharedAccessSignature`\n   * without using a connection string. This field maps to `signature` in `AzureSASCredential`.\n   * @param checkpointStore - A checkpoint store that is used by the client to read checkpoints to determine\n   * the position from where it should resume receiving events when your application gets restarted.\n   * It is also used by the client to load balance multiple instances of your application.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(\n    consumerGroup: string,\n    fullyQualifiedNamespace: string,\n    eventHubName: string,\n    credential: TokenCredential | NamedKeyCredential | SASCredential,\n    checkpointStore: CheckpointStore,\n    options?: EventHubConsumerClientOptions\n  ); // #3.1\n  constructor(\n    private _consumerGroup: string,\n    connectionStringOrFullyQualifiedNamespace2: string,\n    checkpointStoreOrEventHubNameOrOptions3?:\n      | CheckpointStore\n      | EventHubConsumerClientOptions\n      | string,\n    checkpointStoreOrCredentialOrOptions4?:\n      | CheckpointStore\n      | EventHubConsumerClientOptions\n      | TokenCredential\n      | NamedKeyCredential\n      | SASCredential,\n    checkpointStoreOrOptions5?: CheckpointStore | EventHubConsumerClientOptions,\n    options6?: EventHubConsumerClientOptions\n  ) {\n    if (isCredential(checkpointStoreOrCredentialOrOptions4)) {\n      // #3 or 3.1\n      logger.info(\"Creating EventHubConsumerClient with TokenCredential.\");\n\n      if (isCheckpointStore(checkpointStoreOrOptions5)) {\n        // 3.1\n        this._checkpointStore = checkpointStoreOrOptions5;\n        this._userChoseCheckpointStore = true;\n        this._clientOptions = options6 || {};\n      } else {\n        this._checkpointStore = new InMemoryCheckpointStore();\n        this._userChoseCheckpointStore = false;\n        this._clientOptions = checkpointStoreOrOptions5 || {};\n      }\n\n      this._context = createConnectionContext(\n        connectionStringOrFullyQualifiedNamespace2,\n        checkpointStoreOrEventHubNameOrOptions3 as string,\n        checkpointStoreOrCredentialOrOptions4,\n        this._clientOptions\n      );\n    } else if (typeof checkpointStoreOrEventHubNameOrOptions3 === \"string\") {\n      // #2 or 2.1\n      logger.info(\"Creating EventHubConsumerClient with connection string and event hub name.\");\n\n      if (isCheckpointStore(checkpointStoreOrCredentialOrOptions4)) {\n        // 2.1\n        this._checkpointStore = checkpointStoreOrCredentialOrOptions4;\n        this._userChoseCheckpointStore = true;\n        this._clientOptions = (checkpointStoreOrOptions5 as EventHubConsumerClientOptions) || {};\n      } else {\n        // 2\n        this._checkpointStore = new InMemoryCheckpointStore();\n        this._userChoseCheckpointStore = false;\n        this._clientOptions = checkpointStoreOrCredentialOrOptions4 || {};\n      }\n\n      this._context = createConnectionContext(\n        connectionStringOrFullyQualifiedNamespace2,\n        checkpointStoreOrEventHubNameOrOptions3,\n        this._clientOptions\n      );\n    } else {\n      // #1 or 1.1\n      logger.info(\"Creating EventHubConsumerClient with connection string.\");\n\n      if (isCheckpointStore(checkpointStoreOrEventHubNameOrOptions3)) {\n        // 1.1\n        this._checkpointStore = checkpointStoreOrEventHubNameOrOptions3;\n        this._userChoseCheckpointStore = true;\n        this._clientOptions =\n          (checkpointStoreOrCredentialOrOptions4 as EventHubConsumerClientOptions) || {};\n      } else {\n        // 1\n        this._checkpointStore = new InMemoryCheckpointStore();\n        this._userChoseCheckpointStore = false;\n        this._clientOptions =\n          (checkpointStoreOrEventHubNameOrOptions3 as EventHubConsumerClientOptions) || {};\n      }\n\n      this._context = createConnectionContext(\n        connectionStringOrFullyQualifiedNamespace2,\n        this._clientOptions\n      );\n    }\n    this._loadBalancingOptions = {\n      // default options\n      strategy: \"balanced\",\n      updateIntervalInMs: 10000,\n      partitionOwnershipExpirationIntervalInMs: 60000,\n      // options supplied by user\n      ...this._clientOptions?.loadBalancingOptions,\n    };\n  }\n\n  /**\n   * Closes the AMQP connection to the Event Hub instance,\n   * returning a promise that will be resolved when disconnection is completed.\n   * @returns Promise<void>\n   * @throws Error if the underlying connection encounters an error while closing.\n   */\n  async close(): Promise<void> {\n    // Stop all the actively running subscriptions.\n    const activeSubscriptions = Array.from(this._subscriptions);\n    await Promise.all(\n      activeSubscriptions.map((subscription) => {\n        return subscription.close();\n      })\n    );\n    // Close the connection via the connection context.\n    return this._context.close();\n  }\n\n  /**\n   * Provides the id for each partition associated with the Event Hub.\n   * @param options - The set of options to apply to the operation call.\n   * @returns A promise that resolves with an Array of strings representing the id for\n   * each partition associated with the Event Hub.\n   * @throws Error if the underlying connection has been closed, create a new EventHubConsumerClient.\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   */\n  getPartitionIds(options: GetPartitionIdsOptions = {}): Promise<Array<string>> {\n    return this._context\n      .managementSession!.getEventHubProperties({\n        ...options,\n        retryOptions: this._clientOptions.retryOptions,\n      })\n      .then((eventHubProperties) => {\n        return eventHubProperties.partitionIds;\n      });\n  }\n\n  /**\n   * Provides information about the state of the specified partition.\n   * @param partitionId - The id of the partition for which information is required.\n   * @param options - The set of options to apply to the operation call.\n   * @returns A promise that resolves with information about the state of the partition .\n   * @throws Error if the underlying connection has been closed, create a new EventHubConsumerClient.\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   */\n  getPartitionProperties(\n    partitionId: string,\n    options: GetPartitionPropertiesOptions = {}\n  ): Promise<PartitionProperties> {\n    return this._context.managementSession!.getPartitionProperties(partitionId, {\n      ...options,\n      retryOptions: this._clientOptions.retryOptions,\n    });\n  }\n\n  /**\n   * Provides the Event Hub runtime information.\n   * @param options - The set of options to apply to the operation call.\n   * @returns A promise that resolves with information about the Event Hub instance.\n   * @throws Error if the underlying connection has been closed, create a new EventHubConsumerClient.\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   */\n  getEventHubProperties(options: GetEventHubPropertiesOptions = {}): Promise<EventHubProperties> {\n    return this._context.managementSession!.getEventHubProperties({\n      ...options,\n      retryOptions: this._clientOptions.retryOptions,\n    });\n  }\n\n  /**\n   * Subscribe to events from all partitions.\n   *\n   * If checkpoint store is provided to the `EventHubConsumerClient` and there are multiple\n   * instances of your application, then each instance will subscribe to a subset of the\n   * partitions such that the load is balanced amongst them.\n   *\n   * Call close() on the returned object to stop receiving events.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new EventHubConsumerClient(consumerGroup, connectionString, eventHubName);\n   * const subscription = client.subscribe(\n   *  {\n   *    processEvents: (events, context) => { console.log(\"Received event count: \", events.length) },\n   *    processError: (err, context) => { console.log(\"Error: \", err) }\n   *  },\n   *  { startPosition: earliestEventPosition }\n   * );\n   * ```\n   *\n   * @param handlers - Handlers for the lifecycle of the subscription - subscription initialization\n   *                 per partition, receiving events, handling errors and the closing\n   *                 of a subscription per partition.\n   * @param options - Configures the way events are received.\n   * Most common are `maxBatchSize` and `maxWaitTimeInSeconds` that control the flow of\n   * events to the handler provided to receive events as well as the start position. For example,\n   * `{ maxBatchSize: 20, maxWaitTimeInSeconds: 120, startPosition: { sequenceNumber: 123 } }`\n   */\n  subscribe(handlers: SubscriptionEventHandlers, options?: SubscribeOptions): Subscription; // #1\n  /**\n   * Subscribe to events from a single partition.\n   * Call close() on the returned object to stop receiving events.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new EventHubConsumerClient(consumerGroup, connectionString, eventHubName);\n   * const subscription = client.subscribe(\n   *  partitionId,\n   *  {\n   *    processEvents: (events, context) => { console.log(\"Received event count: \", events.length) },\n   *    processError: (err, context) => { console.log(\"Error: \", err) }\n   *  },\n   *  { startPosition: earliestEventPosition }\n   * );\n   * ```\n   *\n   * @param partitionId - The id of the partition to subscribe to.\n   * @param handlers - Handlers for the lifecycle of the subscription - subscription initialization\n   *                 of the partition, receiving events, handling errors and the closing\n   *                 of a subscription to the partition.\n   * @param options - Configures the way events are received.\n   * Most common are `maxBatchSize` and `maxWaitTimeInSeconds` that control the flow of\n   * events to the handler provided to receive events as well as the start position. For example,\n   * `{ maxBatchSize: 20, maxWaitTimeInSeconds: 120, startPosition: { sequenceNumber: 123 } }`\n   */\n\n  subscribe(\n    partitionId: string,\n    handlers: SubscriptionEventHandlers,\n    options?: SubscribeOptions\n  ): Subscription; // #2\n  subscribe(\n    handlersOrPartitionId1?: SubscriptionEventHandlers | string,\n    optionsOrHandlers2?: SubscribeOptions | SubscriptionEventHandlers,\n    possibleOptions3?: SubscribeOptions\n  ): Subscription {\n    let eventProcessor: EventProcessor;\n    let targetedPartitionId: string;\n\n    if (isSubscriptionEventHandlers(handlersOrPartitionId1)) {\n      // #1: subscribe overload - read from all partitions\n      const options = optionsOrHandlers2 as SubscribeOptions | undefined;\n      if (options && options.startPosition) {\n        validateEventPositions(options.startPosition);\n      }\n      ({ targetedPartitionId, eventProcessor } = this.createEventProcessorForAllPartitions(\n        handlersOrPartitionId1,\n        options\n      ));\n    } else if (isSubscriptionEventHandlers(optionsOrHandlers2)) {\n      // #2: subscribe overload (read from specific partition IDs), don't coordinate\n      const options = possibleOptions3 as SubscribeOptions | undefined;\n      if (options && options.startPosition) {\n        validateEventPositions(options.startPosition);\n      }\n      ({ targetedPartitionId, eventProcessor } = this.createEventProcessorForSinglePartition(\n        // cast to string as downstream code expects partitionId to be string, but JS users could have given us anything.\n        // we don't validate the user input and instead rely on service throwing errors if any\n        String(handlersOrPartitionId1),\n        optionsOrHandlers2,\n        possibleOptions3\n      ));\n    } else {\n      throw new TypeError(\"Unhandled subscribe() overload\");\n    }\n\n    eventProcessor.start();\n\n    const subscription = {\n      get isRunning() {\n        return eventProcessor.isRunning();\n      },\n      close: () => {\n        this._partitionGate.remove(targetedPartitionId);\n        this._subscriptions.delete(subscription);\n        return eventProcessor.stop();\n      },\n    };\n    this._subscriptions.add(subscription);\n    return subscription;\n  }\n\n  /**\n   * Gets the LoadBalancing strategy that should be used based on what the user provided.\n   */\n  private _getLoadBalancingStrategy(): LoadBalancingStrategy {\n    if (!this._userChoseCheckpointStore) {\n      // The default behavior when a checkpointstore isn't provided\n      // is to always grab all the partitions.\n      return new UnbalancedLoadBalancingStrategy();\n    }\n\n    const partitionOwnershipExpirationIntervalInMs =\n      this._loadBalancingOptions.partitionOwnershipExpirationIntervalInMs;\n    if (this._loadBalancingOptions?.strategy === \"greedy\") {\n      return new GreedyLoadBalancingStrategy(partitionOwnershipExpirationIntervalInMs);\n    }\n\n    // The default behavior when a checkpointstore is provided is\n    // to grab one partition at a time.\n    return new BalancedLoadBalancingStrategy(partitionOwnershipExpirationIntervalInMs);\n  }\n\n  private createEventProcessorForAllPartitions(\n    subscriptionEventHandlers: SubscriptionEventHandlers,\n    options?: SubscribeOptions\n  ): { targetedPartitionId: string; eventProcessor: EventProcessor } {\n    this._partitionGate.add(\"all\");\n\n    if (this._userChoseCheckpointStore) {\n      logger.verbose(\n        \"EventHubConsumerClient subscribing to all partitions, using a checkpoint store.\"\n      );\n    } else {\n      logger.verbose(\"EventHubConsumerClient subscribing to all partitions, no checkpoint store.\");\n    }\n\n    const loadBalancingStrategy = this._getLoadBalancingStrategy();\n    const eventProcessor = this._createEventProcessor(\n      this._context,\n      subscriptionEventHandlers,\n      this._checkpointStore,\n      {\n        ...defaultConsumerClientOptions,\n        ...(options as SubscribeOptions),\n        ownerLevel: getOwnerLevel(options, this._userChoseCheckpointStore),\n        // make it so all the event processors process work with the same overarching owner ID\n        // this allows the EventHubConsumer to unify all the work for any processors that it spawns\n        ownerId: this._id,\n        retryOptions: this._clientOptions.retryOptions,\n        loadBalancingStrategy,\n        loopIntervalInMs: this._loadBalancingOptions.updateIntervalInMs,\n      }\n    );\n\n    return { targetedPartitionId: \"all\", eventProcessor };\n  }\n\n  private createEventProcessorForSinglePartition(\n    partitionId: string,\n    eventHandlers: SubscriptionEventHandlers,\n    options?: SubscribeOptions\n  ): { targetedPartitionId: string; eventProcessor: EventProcessor } {\n    this._partitionGate.add(partitionId);\n\n    const subscribeOptions = options as SubscribeOptions | undefined;\n\n    if (this._userChoseCheckpointStore) {\n      logger.verbose(\n        `EventHubConsumerClient subscribing to specific partition (${partitionId}), using a checkpoint store.`\n      );\n    } else {\n      logger.verbose(\n        `EventHubConsumerClient subscribing to specific partition (${partitionId}), no checkpoint store.`\n      );\n    }\n\n    const eventProcessor = this._createEventProcessor(\n      this._context,\n      eventHandlers,\n      this._checkpointStore,\n      {\n        ...defaultConsumerClientOptions,\n        ...options,\n        processingTarget: partitionId,\n        ownerLevel: getOwnerLevel(subscribeOptions, this._userChoseCheckpointStore),\n        retryOptions: this._clientOptions.retryOptions,\n        loadBalancingStrategy: new UnbalancedLoadBalancingStrategy(),\n        loopIntervalInMs: this._loadBalancingOptions.updateIntervalInMs ?? 10000,\n      }\n    );\n\n    return { targetedPartitionId: partitionId, eventProcessor };\n  }\n\n  private _createEventProcessor(\n    connectionContext: ConnectionContext,\n    subscriptionEventHandlers: SubscriptionEventHandlers,\n    checkpointStore: CheckpointStore,\n    options: FullEventProcessorOptions\n  ): EventProcessor {\n    return new EventProcessor(\n      this._consumerGroup,\n      connectionContext,\n      subscriptionEventHandlers,\n      checkpointStore,\n      options\n    );\n  }\n}\n\n/**\n * @internal\n */\nexport function isCheckpointStore(possible: CheckpointStore | any): possible is CheckpointStore {\n  if (!possible) {\n    return false;\n  }\n\n  const checkpointStore = possible as CheckpointStore;\n\n  return (\n    typeof checkpointStore.claimOwnership === \"function\" &&\n    typeof checkpointStore.listCheckpoints === \"function\" &&\n    typeof checkpointStore.listOwnership === \"function\" &&\n    typeof checkpointStore.updateCheckpoint === \"function\"\n  );\n}\n\n/**\n * @internal\n */\nfunction isSubscriptionEventHandlers(\n  possible: any | SubscriptionEventHandlers\n): possible is SubscriptionEventHandlers {\n  return typeof (possible as SubscriptionEventHandlers).processEvents === \"function\";\n}\n\nfunction getOwnerLevel(\n  options: SubscribeOptions | undefined,\n  userChoseCheckpointStore: boolean\n): number | undefined {\n  if (options && options.ownerLevel) {\n    return options.ownerLevel;\n  }\n\n  if (userChoseCheckpointStore) {\n    return 0;\n  } else {\n    return undefined;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AmqpAnnotatedMessage } from \"@azure/core-amqp\";\nimport { EventData, populateIdempotentMessageAnnotations, toRheaMessage } from \"./eventData\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { MessageAnnotations, message, Message as RheaMessage } from \"rhea-promise\";\nimport { isDefined, isObjectWithProperties } from \"@azure/core-util\";\nimport { OperationTracingOptions, TracingContext } from \"@azure/core-tracing\";\nimport { instrumentEventData } from \"./diagnostics/instrumentEventData\";\nimport { throwTypeErrorIfParameterMissing } from \"./util/error\";\nimport { PartitionPublishingProperties } from \"./models/private\";\n\n/**\n * The amount of bytes to reserve as overhead for a small message.\n */\nconst smallMessageOverhead = 5;\n/**\n * The amount of bytes to reserve as overhead for a large message.\n */\nconst largeMessageOverhead = 8;\n/**\n * The maximum number of bytes that a message may be to be considered small.\n */\nconst smallMessageMaxBytes = 255;\n\n/**\n * Checks if the provided eventDataBatch is an instance of `EventDataBatch`.\n * @param eventDataBatch - The instance of `EventDataBatch` to verify.\n * @internal\n */\nexport function isEventDataBatch(eventDataBatch: unknown): eventDataBatch is EventDataBatch {\n  return (\n    isObjectWithProperties(eventDataBatch, [\"count\", \"sizeInBytes\", \"tryAdd\"]) &&\n    typeof eventDataBatch.tryAdd === \"function\" &&\n    typeof eventDataBatch.count === \"number\" &&\n    typeof eventDataBatch.sizeInBytes === \"number\"\n  );\n}\n\n/**\n * Options to configure the behavior of the `tryAdd` method on the `EventDataBatch` class.\n */\nexport interface TryAddOptions {\n  /**\n   * The options to use when creating Spans for tracing.\n   */\n  tracingOptions?: OperationTracingOptions;\n}\n\n/**\n * An interface representing a batch of events which can be used to send events to Event Hub.\n *\n * To create the batch, use the `createBatch()` method on the `EventHubProducerClient`.\n * To send the batch, use the `sendBatch()` method on the same client.\n * To fill the batch, use the `tryAdd()` method on the batch itself.\n *\n */\nexport interface EventDataBatch {\n  /**\n   * A value that is hashed and used by the Azure Event Hubs service to determine the partition to\n   * which the events are sent. Use the `createBatch()` method on the `EventHubProducerClient` to\n   * set the partitionKey.\n   * @readonly\n   * @internal\n   */\n  readonly partitionKey?: string;\n\n  /**\n   * Id of the partition to which the batch of events are sent. Use the `createBatch()` method on\n   * the `EventHubProducerClient` to set the partitionId.\n   * @readonly\n   * @internal\n   */\n  readonly partitionId?: string;\n\n  /**\n   * Size of the batch in bytes after the events added to it have been encoded into a single AMQP\n   * message.\n   * @readonly\n   */\n  readonly sizeInBytes: number;\n\n  /**\n   * Number of events added to the batch.\n   * @readonly\n   */\n  readonly count: number;\n\n  /**\n   * The maximum size of the batch, in bytes. The `tryAdd` function on the batch will return `false`\n   * if the event being added causes the size of the batch to exceed this limit. Use the `createBatch()` method on\n   * the `EventHubProducerClient` to set the maxSizeInBytes.\n   * @readonly\n   */\n  readonly maxSizeInBytes: number;\n\n  /**\n   * Adds an event to the batch if permitted by the batch's size limit.\n   * **NOTE**: Always remember to check the return value of this method, before calling it again\n   * for the next event.\n   *\n   * @param eventData -  An individual event data object or AmqpAnnotatedMessage.\n   * @returns A boolean value indicating if the event data has been added to the batch or not.\n   */\n  tryAdd(eventData: EventData | AmqpAnnotatedMessage, options?: TryAddOptions): boolean;\n}\n\n/**\n * An internal class representing a batch of events which can be used to send events to Event Hub.\n *\n * @internal\n */\nexport class EventDataBatchImpl implements EventDataBatch {\n  /**\n   * Describes the amqp connection context for the Client.\n   */\n  private _context: ConnectionContext;\n  /**\n   * The Id of the partition to which the batch is expected to be sent to.\n   * Specifying this will throw an error if the batch was created using a `paritionKey`.\n   */\n  private _partitionId?: string;\n  /**\n   * A value that is hashed to produce a partition assignment.\n   * It guarantees that messages with the same partitionKey end up in the same partition.\n   * Specifying this will throw an error if the batch was created using a `paritionId`.\n   */\n  private _partitionKey?: string;\n  /**\n   * The maximum size allowed for the batch.\n   */\n  private _maxSizeInBytes: number;\n  /**\n   * Current size of the batch in bytes.\n   */\n  private _sizeInBytes: number;\n  /**\n   * Encoded amqp messages.\n   */\n  private _encodedMessages: Buffer[] = [];\n  /**\n   * Number of events in the batch.\n   */\n  private _count: number;\n  /**\n   * List of 'message' span contexts.\n   */\n  private _spanContexts: TracingContext[] = [];\n  /**\n   * The message annotations to apply on the batch envelope.\n   * This will reflect the message annotations on the first event\n   * that was added to the batch.\n   * A common annotation is the partition key.\n   */\n  private _batchAnnotations?: MessageAnnotations;\n  /**\n   * Indicates that the batch should be treated as idempotent.\n   */\n  private _isIdempotent: boolean;\n  /**\n   * The sequence number assigned to the first event in the batch while\n   * the batch is being sent to the service.\n   */\n  private _pendingStartingSequenceNumber?: number;\n  /**\n   * The publishing sequence number assigned to the first event in the batch at the time\n   * the batch was successfully published.\n   * If the producer was not configured to apply sequence numbering or if the batch\n   * has not yet been successfully published, the value will be `undefined`.\n   */\n  private _startingPublishSequenceNumber?: number;\n\n  /**\n   * EventDataBatch should not be constructed using `new EventDataBatch()`\n   * Use the `createBatch()` method on your `EventHubProducer` instead.\n   * @internal\n   */\n  constructor(\n    context: ConnectionContext,\n    maxSizeInBytes: number,\n    isIdempotent: boolean,\n    partitionKey?: string,\n    partitionId?: string\n  ) {\n    this._context = context;\n    this._maxSizeInBytes = maxSizeInBytes;\n    this._isIdempotent = isIdempotent;\n    this._partitionKey = isDefined(partitionKey) ? String(partitionKey) : partitionKey;\n    this._partitionId = isDefined(partitionId) ? String(partitionId) : partitionId;\n    this._sizeInBytes = 0;\n    this._count = 0;\n  }\n\n  /**\n   * The maximum size of the batch, in bytes.\n   * @readonly\n   */\n  get maxSizeInBytes(): number {\n    return this._maxSizeInBytes;\n  }\n\n  /**\n   * The partitionKey set during `EventDataBatch` creation. This value is hashed to\n   * produce a partition assignment when the producer is created without a `partitionId`\n   * @readonly\n   */\n  get partitionKey(): string | undefined {\n    return this._partitionKey;\n  }\n\n  /**\n   * The partitionId set during `EventDataBatch` creation.\n   * If this value is set then partitionKey can not be set.\n   * @readonly\n   */\n  get partitionId(): string | undefined {\n    return this._partitionId;\n  }\n\n  /**\n   * Size of the `EventDataBatch` instance after the events added to it have been\n   * encoded into a single AMQP message.\n   * @readonly\n   */\n  get sizeInBytes(): number {\n    return this._sizeInBytes;\n  }\n\n  /**\n   * Number of events in the `EventDataBatch` instance.\n   * @readonly\n   */\n  get count(): number {\n    return this._count;\n  }\n\n  /**\n   * The publishing sequence number assigned to the first event in the batch at the time\n   * the batch was successfully published.\n   * If the producer was not configured to apply sequence numbering or if the batch\n   * has not yet been successfully published, the value will be `undefined`.\n   */\n  get startingPublishedSequenceNumber(): number | undefined {\n    return this._startingPublishSequenceNumber;\n  }\n\n  /**\n   * Gets the \"message\" span contexts that were created when adding events to the batch.\n   * @internal\n   */\n  get _messageSpanContexts(): TracingContext[] {\n    return this._spanContexts;\n  }\n\n  /**\n   * Generates an AMQP message that contains the provided encoded events and annotations.\n   * @param encodedEvents - The already encoded events to include in the AMQP batch.\n   * @param annotations - The message annotations to set on the batch.\n   * @param publishingProps - Idempotent publishing properties used to decorate the events in the batch while sending.\n   */\n  private _generateBatch(\n    encodedEvents: Buffer[],\n    annotations: MessageAnnotations | undefined,\n    publishingProps?: PartitionPublishingProperties\n  ): Buffer {\n    if (this._isIdempotent && publishingProps) {\n      // We need to decode the encoded events, add the idempotent annotations, and re-encode them.\n      // We can't lazily encode the events because we rely on `message.encode` to capture the\n      // byte length of anything not in `event.body`.\n      // Events can't be decorated ahead of time because the publishing properties aren't known\n      // until the events are being sent to the service.\n      const decodedEvents = encodedEvents.map(message.decode) as unknown as RheaMessage[];\n      const decoratedEvents = this._decorateRheaMessagesWithPublishingProps(\n        decodedEvents,\n        publishingProps\n      );\n      encodedEvents = decoratedEvents.map(message.encode);\n    }\n\n    const batchEnvelope: RheaMessage = {\n      body: message.data_sections(encodedEvents),\n    };\n    if (annotations) {\n      batchEnvelope.message_annotations = annotations;\n    }\n    return message.encode(batchEnvelope);\n  }\n\n  /**\n   * Uses the publishingProps to add idempotent properties as message annotations to rhea messages.\n   */\n  private _decorateRheaMessagesWithPublishingProps(\n    events: RheaMessage[],\n    publishingProps: PartitionPublishingProperties\n  ): RheaMessage[] {\n    if (!this._isIdempotent) {\n      return events;\n    }\n\n    const { lastPublishedSequenceNumber = 0, ownerLevel, producerGroupId } = publishingProps;\n    const startingSequenceNumber = lastPublishedSequenceNumber + 1;\n    for (let i = 0; i < events.length; i++) {\n      const event = events[i];\n      populateIdempotentMessageAnnotations(event, {\n        isIdempotentPublishingEnabled: this._isIdempotent,\n        ownerLevel,\n        producerGroupId,\n        publishSequenceNumber: startingSequenceNumber + i,\n      });\n    }\n\n    this._pendingStartingSequenceNumber = startingSequenceNumber;\n    return events;\n  }\n\n  /**\n   * Annotates a rhea message with placeholder idempotent properties if the batch is idempotent.\n   * This is necessary so that we can accurately calculate the size of the batch while adding events.\n   * Placeholder values are used because real values won't be known until we attempt to send the batch.\n   */\n  private _decorateRheaMessageWithPlaceholderIdempotencyProps(event: RheaMessage): RheaMessage {\n    if (!this._isIdempotent) {\n      return event;\n    }\n\n    if (!event.message_annotations) {\n      event.message_annotations = {};\n    }\n\n    // Set placeholder values for these annotations.\n    populateIdempotentMessageAnnotations(event, {\n      isIdempotentPublishingEnabled: this._isIdempotent,\n      ownerLevel: 0,\n      publishSequenceNumber: 0,\n      producerGroupId: 0,\n    });\n\n    return event;\n  }\n\n  /**\n   * Generates the single AMQP message which is the result of encoding all the events\n   * added into the `EventDataBatch` instance.\n   *\n   * This is not meant for the user to use directly.\n   *\n   * When the `EventDataBatch` instance is passed to the `send()` method on the `EventHubProducer`,\n   * this single batched AMQP message is what gets sent over the wire to the service.\n   * @readonly\n   */\n  _generateMessage(publishingProps?: PartitionPublishingProperties): Buffer {\n    return this._generateBatch(this._encodedMessages, this._batchAnnotations, publishingProps);\n  }\n\n  /**\n   * Sets startingPublishSequenceNumber to the pending publish sequence number.\n   */\n  _commitPublish(): void {\n    this._startingPublishSequenceNumber = this._pendingStartingSequenceNumber;\n  }\n\n  /**\n   * Tries to add an event data to the batch if permitted by the batch's size limit.\n   * **NOTE**: Always remember to check the return value of this method, before calling it again\n   * for the next event.\n   *\n   * @param eventData -  An individual event data object.\n   * @returns A boolean value indicating if the event data has been added to the batch or not.\n   */\n  public tryAdd(eventData: EventData | AmqpAnnotatedMessage, options: TryAddOptions = {}): boolean {\n    throwTypeErrorIfParameterMissing(this._context.connectionId, \"tryAdd\", \"eventData\", eventData);\n\n    const { entityPath, host } = this._context.config;\n    const { event: instrumentedEvent, spanContext } = instrumentEventData(\n      eventData,\n      options,\n      entityPath,\n      host\n    );\n\n    // Convert EventData to RheaMessage.\n    const amqpMessage = toRheaMessage(instrumentedEvent, this._partitionKey);\n    const originalAnnotations = amqpMessage.message_annotations && {\n      ...amqpMessage.message_annotations,\n    };\n    this._decorateRheaMessageWithPlaceholderIdempotencyProps(amqpMessage);\n    const encodedMessage = message.encode(amqpMessage);\n\n    let currentSize = this._sizeInBytes;\n    // The first time an event is added, we need to calculate\n    // the overhead of creating an AMQP batch, including the\n    // message_annotations that are taken from the 1st message.\n    if (this.count === 0) {\n      if (originalAnnotations) {\n        this._batchAnnotations = originalAnnotations;\n      }\n\n      // Figure out the overhead of creating a batch by generating an empty batch\n      // with the expected batch annotations.\n      currentSize += this._generateBatch([], this._batchAnnotations).length;\n    }\n\n    const messageSize = encodedMessage.length;\n    const messageOverhead =\n      messageSize <= smallMessageMaxBytes ? smallMessageOverhead : largeMessageOverhead;\n    currentSize += messageSize + messageOverhead;\n\n    // Check if the size of the batch exceeds the maximum allowed size\n    // once we add the new event to it.\n    if (currentSize > this._maxSizeInBytes) {\n      return false;\n    }\n\n    // The event will fit in the batch, so it is now safe to store it.\n    this._encodedMessages.push(encodedMessage);\n    if (spanContext) {\n      this._spanContexts.push(spanContext);\n    }\n\n    this._sizeInBytes = currentSize;\n    this._count++;\n    return true;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  AmqpError,\n  AwaitableSender,\n  AwaitableSenderOptions,\n  EventContext,\n  OnAmqpEvent,\n  Message as RheaMessage,\n  message,\n  types,\n} from \"rhea-promise\";\nimport {\n  ErrorNameConditionMapper,\n  RetryConfig,\n  RetryOperationType,\n  RetryOptions,\n  defaultCancellableLock,\n  delay,\n  retry,\n  translate,\n} from \"@azure/core-amqp\";\nimport {\n  EventData,\n  EventDataInternal,\n  populateIdempotentMessageAnnotations,\n  toRheaMessage,\n} from \"./eventData\";\nimport { EventDataBatch, EventDataBatchImpl, isEventDataBatch } from \"./eventDataBatch\";\nimport {\n  createLogPrefix,\n  logErrorStackTrace,\n  createSimpleLogger,\n  logger,\n  SimpleLogger,\n} from \"./logger\";\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { EventHubProducerOptions, IdempotentLinkProperties } from \"./models/private\";\nimport { SendOptions } from \"./models/public\";\nimport { PartitionPublishingOptions, PartitionPublishingProperties } from \"./models/private\";\nimport { getRetryAttemptTimeoutInMs } from \"./util/retries\";\nimport {\n  idempotentProducerAmqpPropertyNames,\n  PENDING_PUBLISH_SEQ_NUM_SYMBOL,\n} from \"./util/constants\";\nimport { isDefined } from \"@azure/core-util\";\nimport { translateError } from \"./util/error\";\nimport { TimerLoop } from \"./util/timerLoop\";\nimport { withAuth } from \"./withAuth\";\nimport { getRandomName } from \"./util/utils\";\n\n/**\n * @internal\n */\nexport interface EventHubSenderOptions {\n  /**\n   * Indicates whether or not the sender should enable idempotent publishing to Event Hub partitions.\n   */\n  enableIdempotentProducer: boolean;\n  /**\n   * The EventHub partition id to which the sender wants to send the event data.\n   */\n  partitionId?: string;\n  /**\n   * The set of options that can be specified to influence publishing behavior\n   * specific to a partition.\n   */\n  partitionPublishingOptions?: PartitionPublishingOptions;\n}\n\n/**\n * Describes the EventHubSender that will send event data to EventHub.\n * @internal\n */\nexport class EventHubSender {\n  /**\n   * The unique lock name per connection that is used to acquire the\n   * lock for establishing a sender link by an entity on that connection.\n   */\n  private readonly senderLock: string = getRandomName(\"sender\");\n  /**\n   * The handler function to handle errors that happen on the\n   * underlying sender.\n   */\n  private readonly _onAmqpError: OnAmqpEvent;\n  /**\n   * The handler function to handle \"sender_close\" event\n   * that happens on the underlying sender.\n   */\n  private readonly _onAmqpClose: OnAmqpEvent;\n  /**\n   * The message handler that will be set as the handler on\n   * the underlying rhea sender's session for the \"session_error\" event.\n   */\n  private _onSessionError: OnAmqpEvent;\n  /**\n   * The message handler that will be set as the handler on\n   * the underlying rhea sender's session for the \"session_close\" event.\n   */\n  private _onSessionClose: OnAmqpEvent;\n  /**\n   * The AMQP sender link.\n   */\n  private _sender?: AwaitableSender;\n  /**\n   * The partition ID.\n   */\n  private readonly partitionId?: string;\n  /**\n   * Indicates whether the sender is configured for idempotent publishing.\n   */\n  private _isIdempotentProducer: boolean;\n  /**\n   * Indicates whether the sender has an in-flight send while idempotent\n   * publishing is enabled.\n   */\n  private _hasPendingSend?: boolean;\n  /**\n   * A local copy of the PartitionPublishingProperties that can be mutated to\n   * keep track of the lastSequenceNumber used.\n   */\n  private _localPublishingProperties?: PartitionPublishingProperties;\n  /**\n   * The user-provided set of options that can be specified to influence\n   * publishing behavior specific to a partition.\n   */\n  private _userProvidedPublishingOptions?: PartitionPublishingOptions;\n  /**\n   * Indicates whether the link is in the process of connecting\n   * (establishing) itself. Default value: `false`.\n   */\n  private isConnecting: boolean = false;\n  /**\n   * The unique name for the entity (mostly a guid).\n   */\n  private readonly name: string;\n  /**\n   * The address in the following form:\n   * - `\"<hubName>\"`\n   * - `\"<hubName>/Partitions/<partitionId>\"`.\n   */\n  private readonly address: string;\n  /**\n   * The token audience in the following form:\n   * - `\"sb://<yournamespace>.servicebus.windows.net/<hubName>\"`\n   * - `\"sb://<yournamespace>.servicebus.windows.net/<hubName>/Partitions/<partitionId>\"`.\n   */\n  private readonly audience: string;\n  /**\n   * Provides relevant information about the amqp connection,\n   * cbs and $management sessions, token provider, sender and receivers.\n   */\n  private readonly _context: ConnectionContext;\n  /**\n   * The auth loop.\n   */\n  private authLoop?: TimerLoop;\n  /**\n   * The logger.\n   */\n  private readonly logger: SimpleLogger;\n\n  /**\n   * Creates a new EventHubSender instance.\n   * @param context - The connection context.\n   * @param options - Options used to configure the EventHubSender.\n   */\n  constructor(\n    context: ConnectionContext,\n    { partitionId, enableIdempotentProducer, partitionPublishingOptions }: EventHubSenderOptions\n  ) {\n    this.address = context.config.getSenderAddress(partitionId);\n    this.name = this.address;\n    this.audience = context.config.getSenderAudience(partitionId);\n    this._context = context;\n    this.partitionId = partitionId;\n    this._isIdempotentProducer = enableIdempotentProducer;\n    this._userProvidedPublishingOptions = partitionPublishingOptions;\n    const logPrefix = createLogPrefix(this._context.connectionId, \"Sender\", this.name);\n    this.logger = createSimpleLogger(logger, logPrefix);\n\n    this._onAmqpError = (eventContext: EventContext) => {\n      const senderError = eventContext.sender && eventContext.sender.error;\n      this.logger.verbose(\n        \"'sender_error' event occurred. The associated error is: %O\",\n        senderError\n      );\n      // TODO: Consider rejecting promise in trySendBatch() or createBatch()\n    };\n\n    this._onSessionError = (eventContext: EventContext) => {\n      const sessionError = eventContext.session && eventContext.session.error;\n      this.logger.verbose(\n        \"'session_error' event occurred. The associated error is: %O\",\n        sessionError\n      );\n      // TODO: Consider rejecting promise in trySendBatch() or createBatch()\n    };\n\n    this._onAmqpClose = async (eventContext: EventContext) => {\n      const sender = this._sender || eventContext.sender!;\n      this.logger.verbose(\n        \"'sender_close' event occurred. Value for isItselfClosed on the receiver is: '%s' \" +\n          \"Value for isConnecting on the session is: '%s'.\",\n        sender?.isItselfClosed().toString(),\n        this.isConnecting\n      );\n      if (sender && !this.isConnecting) {\n        // Call close to clean up timers & other resources\n        await sender.close().catch((err) => {\n          this.logger.verbose(\"error when closing after 'sender_close' event: %O\", err);\n        });\n      }\n    };\n\n    this._onSessionClose = async (eventContext: EventContext) => {\n      const sender = this._sender || eventContext.sender!;\n      this.logger.verbose(\n        \"'session_close' event occurred. Value for isSessionItselfClosed on the session is: '%s' \" +\n          \"Value for isConnecting on the session is: '%s'.\",\n        sender?.isSessionItselfClosed().toString(),\n        this.isConnecting\n      );\n      if (sender && !this.isConnecting) {\n        // Call close to clean up timers & other resources\n        await sender.close().catch((err) => {\n          this.logger.verbose(\"error when closing after 'session_close' event: %O\", err);\n        });\n      }\n    };\n  }\n\n  /**\n   * Deletes the sender from the context. Clears the token renewal timer. Closes the sender link.\n   */\n  async close(): Promise<void> {\n    try {\n      if (this._sender) {\n        this.logger.info(\"closing\");\n        const senderLink = this._sender;\n        this._deleteFromCache();\n        await senderLink.close();\n        this.authLoop?.stop();\n        this.logger.verbose(\"closed.\");\n      }\n    } catch (err: any) {\n      const msg = `an error occurred while closing: ${err?.name}: ${err?.message}`;\n      this.logger.warning(msg);\n      logErrorStackTrace(err);\n      throw err;\n    }\n  }\n\n  /**\n   * Determines whether the AMQP sender link is open. If open then returns true else returns false.\n   * @returns boolean\n   */\n  isOpen(): boolean {\n    const result = Boolean(this._sender && this._sender.isOpen());\n    this.logger.verbose(\"is open? -> %s\", result);\n    return result;\n  }\n  /**\n   * Returns maximum message size on the AMQP sender link.\n   * @param abortSignal - An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   * @returns Promise<number>\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   */\n  async getMaxMessageSize(\n    options: {\n      retryOptions?: RetryOptions;\n      abortSignal?: AbortSignalLike;\n    } = {}\n  ): Promise<number> {\n    const sender = await this._getLink(options);\n\n    return sender.maxMessageSize;\n  }\n\n  /**\n   * Get the information about the state of publishing for a partition as observed by the `EventHubSender`.\n   * This data can always be read, but will only be populated with information relevant to the active features\n   * for the producer client.\n   */\n  async getPartitionPublishingProperties(\n    options: {\n      retryOptions?: RetryOptions;\n      abortSignal?: AbortSignalLike;\n    } = {}\n  ): Promise<PartitionPublishingProperties> {\n    if (this._localPublishingProperties) {\n      // Send a copy of the properties so it can't be mutated downstream.\n      return { ...this._localPublishingProperties };\n    }\n\n    const properties: PartitionPublishingProperties = {\n      isIdempotentPublishingEnabled: this._isIdempotentProducer,\n      partitionId: this.partitionId ?? \"\",\n    };\n\n    if (this._isIdempotentProducer) {\n      this._sender = await this._getLink(options);\n      // await this._createLinkIfNotOpen(options);\n      if (!this._sender) {\n        // createLinkIfNotOpen should throw if `this._sender` can't be created, but just in case it gets\n        // deleted while setting up token refreshing, make sure it exists.\n        throw new Error(\n          `Failed to retrieve partition publishing properties for partition \"${this.partitionId}\".`\n        );\n      }\n\n      const {\n        [idempotentProducerAmqpPropertyNames.epoch]: ownerLevel,\n        [idempotentProducerAmqpPropertyNames.producerId]: producerGroupId,\n        [idempotentProducerAmqpPropertyNames.producerSequenceNumber]: lastPublishedSequenceNumber,\n      } = this._sender.properties ?? {};\n\n      properties.ownerLevel = parseInt(ownerLevel, 10);\n      properties.producerGroupId = parseInt(producerGroupId, 10);\n      properties.lastPublishedSequenceNumber = parseInt(lastPublishedSequenceNumber, 10);\n    }\n\n    this._localPublishingProperties = properties;\n\n    // Send a copy of the properties so it can't be mutated downstream.\n    return { ...properties };\n  }\n\n  /**\n   * Send a batch of EventData to the EventHub. The \"message_annotations\",\n   * \"application_properties\" and \"properties\" of the first message will be set as that\n   * of the envelope (batch message).\n   * @param events -  An array of EventData objects to be sent in a Batch message.\n   * @param options - Options to control the way the events are batched along with request options\n   */\n  async send(\n    events: EventData[] | EventDataBatch,\n    options?: SendOptions &\n      EventHubProducerOptions & { tracingProperties?: Array<EventData[\"properties\"]> }\n  ): Promise<void> {\n    try {\n      this.logger.info(\"trying to send EventData[].\");\n      if (this._isIdempotentProducer && this._hasPendingSend) {\n        throw new Error(\n          `There can only be 1 \"sendBatch\" call in-flight per partition while \"enableIdempotentRetries\" is set to true.`\n        );\n      }\n\n      const eventCount = isEventDataBatch(events) ? events.count : events.length;\n      if (eventCount === 0) {\n        this.logger.info(`no events were passed to sendBatch.`);\n        return;\n      }\n\n      if (this._isIdempotentProducer) {\n        this._hasPendingSend = true;\n      }\n\n      this.logger.info(\"sending encoded batch message.\");\n      await this._trySendBatch(events, options);\n      if (this._isIdempotentProducer) {\n        commitIdempotentSequenceNumbers(events);\n        if (this._localPublishingProperties) {\n          const { lastPublishedSequenceNumber = 0 } = this._localPublishingProperties;\n          // Increment the lastPublishedSequenceNumber based on the number of events published.\n          this._localPublishingProperties.lastPublishedSequenceNumber =\n            lastPublishedSequenceNumber + eventCount;\n        }\n      }\n      return;\n    } catch (err: any) {\n      rollbackIdempotentSequenceNumbers(events);\n      this.logger.warning(\n        `an error occurred while sending the batch message ${err?.name}: ${err?.message}`\n      );\n      logErrorStackTrace(err);\n      throw err;\n    } finally {\n      if (this._isIdempotentProducer) {\n        this._hasPendingSend = false;\n      }\n    }\n  }\n\n  /**\n   * @param sender - The rhea sender that contains the idempotent producer properties.\n   */\n  private _populateLocalPublishingProperties(sender: AwaitableSender): void {\n    const {\n      [idempotentProducerAmqpPropertyNames.epoch]: ownerLevel,\n      [idempotentProducerAmqpPropertyNames.producerId]: producerGroupId,\n      [idempotentProducerAmqpPropertyNames.producerSequenceNumber]: lastPublishedSequenceNumber,\n    } = sender.properties ?? {};\n\n    this._localPublishingProperties = {\n      isIdempotentPublishingEnabled: this._isIdempotentProducer,\n      partitionId: this.partitionId ?? \"\",\n      lastPublishedSequenceNumber,\n      ownerLevel,\n      producerGroupId,\n    };\n  }\n\n  private _deleteFromCache(): void {\n    this._sender = undefined;\n    delete this._context.senders[this.name];\n    this.logger.verbose(\"deleted from the client cache.\");\n  }\n\n  private _createSenderOptions(): AwaitableSenderOptions {\n    const srOptions: AwaitableSenderOptions = {\n      name: this.name,\n      target: {\n        address: this.address,\n      },\n      onError: this._onAmqpError,\n      onClose: this._onAmqpClose,\n      onSessionError: this._onSessionError,\n      onSessionClose: this._onSessionClose,\n    };\n\n    if (this._isIdempotentProducer) {\n      srOptions.desired_capabilities = idempotentProducerAmqpPropertyNames.capability;\n      const idempotentProperties = generateIdempotentLinkProperties(\n        this._userProvidedPublishingOptions,\n        this._localPublishingProperties\n      );\n      srOptions.properties = idempotentProperties;\n    }\n    this.logger.verbose(\"being created with options: %O\", srOptions);\n    return srOptions;\n  }\n\n  /**\n   * Tries to send the message to EventHub if there is enough credit to send them\n   * and the circular buffer has available space to settle the message after sending them.\n   *\n   * We have implemented a synchronous send over here in the sense that we shall be waiting\n   * for the message to be accepted or rejected and accordingly resolve or reject the promise.\n   * @param rheaMessage - The message to be sent to EventHub.\n   * @returns Promise<void>\n   */\n  private async _trySendBatch(\n    events: EventData[] | EventDataBatch,\n    options: SendOptions &\n      EventHubProducerOptions & {\n        /**\n         * Tracing properties that are associated with EventData.\n         */\n        tracingProperties?: Array<EventData[\"properties\"]>;\n      } = {}\n  ): Promise<void> {\n    const abortSignal: AbortSignalLike | undefined = options.abortSignal;\n    const retryOptions = options.retryOptions || {};\n    const timeoutInMs = getRetryAttemptTimeoutInMs(retryOptions);\n    retryOptions.timeoutInMs = timeoutInMs;\n\n    const sendEventPromise = async (): Promise<void> => {\n      const initStartTime = Date.now();\n      // TODO: (jeremymeng) A or B\n      // variant A:\n      const sender = await this._getLink(options);\n      // variant B\n      // await this._createLinkIfNotOpen(options);\n      const publishingProps = await this.getPartitionPublishingProperties(options);\n      const timeTakenByInit = Date.now() - initStartTime;\n\n      this.logger.verbose(\n        \"credit: %d available: %d\",\n        sender.credit,\n        sender.session.outgoing.available()\n      );\n\n      let waitTimeForSendable = 1000;\n      if (!sender.sendable() && timeoutInMs - timeTakenByInit > waitTimeForSendable) {\n        this.logger.verbose(\"waiting for 1 second for sender to become sendable\");\n\n        await delay(waitTimeForSendable);\n\n        this.logger.verbose(\n          \"after waiting for a second, credit: %d available: %d\",\n          sender.credit,\n          sender.session?.outgoing?.available()\n        );\n      } else {\n        waitTimeForSendable = 0;\n      }\n\n      if (!sender.sendable()) {\n        // let us retry to send the message after some time.\n        const msg = `cannot send the message right now. Please try later.`;\n        this.logger.warning(msg);\n        const amqpError: AmqpError = {\n          condition: ErrorNameConditionMapper.SenderBusyError,\n          description: msg,\n        };\n        throw translate(amqpError);\n      }\n\n      if (timeoutInMs <= timeTakenByInit + waitTimeForSendable) {\n        const desc: string =\n          `was not able to send the message right now, due ` + `to operation timeout.`;\n        this.logger.warning(desc);\n        const e: AmqpError = {\n          condition: ErrorNameConditionMapper.ServiceUnavailableError,\n          description: desc,\n        };\n        throw translate(e);\n      }\n\n      try {\n        const encodedMessage = transformEventsForSend(events, publishingProps, options);\n        const delivery = await sender.send(encodedMessage, {\n          format: 0x80013700,\n          timeoutInSeconds: (timeoutInMs - timeTakenByInit - waitTimeForSendable) / 1000,\n          abortSignal,\n        });\n        this.logger.info(\"sent message with delivery id: %d\", delivery.id);\n      } catch (err: any) {\n        const error = err.innerError || err;\n        const translatedError = translateError(error);\n        throw translatedError;\n      }\n    };\n\n    const config: RetryConfig<void> = {\n      operation: sendEventPromise,\n      connectionId: this._context.connectionId,\n      operationType: RetryOperationType.sendMessage,\n      abortSignal: abortSignal,\n      retryOptions: retryOptions,\n    };\n\n    try {\n      await retry<void>(config);\n    } catch (err: any) {\n      const translatedError = translate(err);\n      this.logger.warning(\n        \"an error occurred while sending the message %s\",\n        `${translatedError?.name}: ${translatedError?.message}`\n      );\n      logErrorStackTrace(translatedError);\n      throw translatedError;\n    }\n  }\n\n  private async _getLink(\n    options: {\n      retryOptions?: RetryOptions;\n      abortSignal?: AbortSignalLike;\n    } = {}\n  ): Promise<AwaitableSender> {\n    if (this.isOpen() && this._sender) {\n      return this._sender;\n    }\n    const retryOptions = options.retryOptions || {};\n    const timeoutInMs = getRetryAttemptTimeoutInMs(retryOptions);\n    retryOptions.timeoutInMs = timeoutInMs;\n    const senderOptions = this._createSenderOptions();\n\n    const startTime = Date.now();\n    const createLinkPromise = async (): Promise<AwaitableSender> => {\n      return defaultCancellableLock.acquire(\n        this.senderLock,\n        () => {\n          const taskStartTime = Date.now();\n          const taskTimeoutInMs = timeoutInMs - (taskStartTime - startTime);\n          return this._init({\n            ...senderOptions,\n            abortSignal: options.abortSignal,\n            timeoutInMs: taskTimeoutInMs,\n          });\n        },\n        { abortSignal: options.abortSignal, timeoutInMs: timeoutInMs }\n      );\n    };\n\n    const config: RetryConfig<AwaitableSender> = {\n      operation: createLinkPromise,\n      connectionId: this._context.connectionId,\n      operationType: RetryOperationType.senderLink,\n      abortSignal: options.abortSignal,\n      retryOptions: retryOptions,\n    };\n\n    try {\n      return await retry<AwaitableSender>(config);\n    } catch (err: any) {\n      const translatedError = translate(err);\n      this.logger.warning(\n        \"an error occurred while creating: %s\",\n        `${translatedError?.name}: ${translatedError?.message}`\n      );\n      logErrorStackTrace(translatedError);\n      throw translatedError;\n    }\n  }\n\n  /**\n   * Initializes the sender session on the connection.\n   * Should only be called from _createLinkIfNotOpen\n   */\n  private async _init(\n    options: AwaitableSenderOptions & {\n      abortSignal: AbortSignalLike | undefined;\n      timeoutInMs: number;\n    }\n  ): Promise<AwaitableSender> {\n    const createSender = async () => {\n      this.logger.verbose(\"trying to be created...\");\n\n      const sender = await this._context.connection.createAwaitableSender(options);\n      this._sender = sender;\n      this._populateLocalPublishingProperties(this._sender);\n      this.isConnecting = false;\n      this.logger.verbose(\"created with options: %O\", options);\n\n      // It is possible for someone to close the sender and then start it again.\n      // Thus make sure that the sender is present in the client cache.\n      if (!this._context.senders[this.name]) this._context.senders[this.name] = this;\n    };\n    try {\n      if (!this.isOpen() || !this._sender) {\n        await this._context.readyToOpenLink();\n        this.authLoop = await withAuth(\n          createSender,\n          this._context,\n          this.audience,\n          options.timeoutInMs,\n          this.logger,\n          { abortSignal: options.abortSignal }\n        );\n        // it is guaranteed to be defined at this point, otherwise, an error would\n        // have been thrown.\n        return this._sender!;\n      } else {\n        this.logger.verbose(\"is open -> %s. Hence not reconnecting.\", this.isOpen());\n        return this._sender;\n      }\n    } catch (err) {\n      const translatedError = translate(err);\n      this.logger.warning(\n        \"an error occurred while being created: %s\",\n        `${translatedError?.name}: ${translatedError?.message}`\n      );\n      logErrorStackTrace(translatedError);\n      throw translatedError;\n    }\n  }\n\n  /**\n   * Creates a new sender to the given event hub, and optionally to a given partition if it is\n   * not present in the context or returns the one present in the context.\n   * @hidden\n   * @param options - Options used to configure the EventHubSender.\n   */\n  static create(context: ConnectionContext, options: EventHubSenderOptions): EventHubSender {\n    const ehSender: EventHubSender = new EventHubSender(context, options);\n    if (!context.senders[ehSender.name]) {\n      context.senders[ehSender.name] = ehSender;\n    }\n    return context.senders[ehSender.name];\n  }\n}\n\n/**\n * Generates the link properties for an indemopotent sender given\n * based on the user-provided and locally-cached publishing options.\n *\n * Note: The set of idempotent properties a user specifies at EventHubProducerClient instantiation-time\n * is slightly different than what the service returns and the EventHubSender keeps track of locally.\n *\n * The difference is that the user specifies the `startingSequenceNumber`, whereas the local options\n * (those returned by getPartitionPublishingProperties) specifies `lastPublishedSequenceNumber`.\n *\n * These _can_ be the same, but the user is technically free to set any `startingSequenceNumber` they want.\n * @internal\n */\nexport function generateIdempotentLinkProperties(\n  userProvidedPublishingOptions: PartitionPublishingOptions | undefined,\n  localPublishingOptions: PartitionPublishingProperties | undefined\n): IdempotentLinkProperties | Record<string, never> {\n  let ownerLevel: number | undefined;\n  let producerGroupId: number | undefined;\n  let sequenceNumber: number | undefined;\n\n  // Prefer local publishing options since this is the up-to-date state of the sender.\n  // Only use user-provided publishing options the first time we create the link.\n  if (localPublishingOptions) {\n    ownerLevel = localPublishingOptions.ownerLevel;\n    producerGroupId = localPublishingOptions.producerGroupId;\n    sequenceNumber = localPublishingOptions.lastPublishedSequenceNumber;\n  } else if (userProvidedPublishingOptions) {\n    ownerLevel = userProvidedPublishingOptions.ownerLevel;\n    producerGroupId = userProvidedPublishingOptions.producerGroupId;\n    sequenceNumber = userProvidedPublishingOptions.startingSequenceNumber;\n  } else {\n    // If we don't have any properties at all, send an empty object.\n    // This will cause the service to generate a new producer-id for our client.\n    return {};\n  }\n\n  // The service requires that if ANY_ of these properties are defined,\n  // they _ALL_ have to be defined.\n  // If we don't have one of the required values, use `null` and the\n  // service will provide it.\n  const idempotentLinkProperties: IdempotentLinkProperties = {\n    [idempotentProducerAmqpPropertyNames.epoch]: isDefined(ownerLevel)\n      ? types.wrap_short(ownerLevel)\n      : null,\n    [idempotentProducerAmqpPropertyNames.producerId]: isDefined(producerGroupId)\n      ? types.wrap_long(producerGroupId)\n      : null,\n    [idempotentProducerAmqpPropertyNames.producerSequenceNumber]: isDefined(sequenceNumber)\n      ? types.wrap_int(sequenceNumber)\n      : null,\n  };\n\n  return idempotentLinkProperties;\n}\n\n/**\n * Encodes a list or batch of events into a single binary message that can be sent to the service.\n *\n * Prior to encoding, any special properties not specified by the user, such as tracing or idempotent\n * properties, are assigned to the list or batch of events as needed.\n *\n * @internal\n * @param events - Events to transform for sending to the service.\n * @param publishingProps - Describes the current publishing state for the partition.\n * @param options - Options used to configure this function.\n */\nexport function transformEventsForSend(\n  events: EventData[] | EventDataBatch,\n  publishingProps: PartitionPublishingProperties,\n  options: SendOptions & {\n    /**\n     * A list containing the `Diagnostic-Id` tracing property that is associated with each EventData.\n     * The index of tracingProperties corresponds to the same index in `events` when `events` is EventData[].\n     */\n    tracingProperties?: Array<EventData[\"properties\"]>;\n  } = {}\n): Buffer {\n  if (isEventDataBatch(events)) {\n    return (events as EventDataBatchImpl)._generateMessage(publishingProps);\n  } else {\n    const eventCount = events.length;\n    // convert events to rhea messages\n    const rheaMessages: RheaMessage[] = [];\n    const tracingProperties = options.tracingProperties ?? [];\n    for (let i = 0; i < eventCount; i++) {\n      const originalEvent = events[i];\n      const tracingProperty = tracingProperties[i];\n      // Create a copy of the user's event so we can add the tracing property.\n      const event: EventData = {\n        ...originalEvent,\n        properties: { ...originalEvent.properties, ...tracingProperty },\n      };\n      const rheaMessage = toRheaMessage(event, options.partitionKey);\n\n      // populate idempotent message annotations\n      const { lastPublishedSequenceNumber = 0 } = publishingProps;\n      const startingSequenceNumber = lastPublishedSequenceNumber + 1;\n      const pendingPublishSequenceNumber = startingSequenceNumber + i;\n      populateIdempotentMessageAnnotations(rheaMessage, {\n        ...publishingProps,\n        publishSequenceNumber: pendingPublishSequenceNumber,\n      });\n\n      if (publishingProps.isIdempotentPublishingEnabled) {\n        // Set pending seq number on user's event.\n        (originalEvent as EventDataInternal)[PENDING_PUBLISH_SEQ_NUM_SYMBOL] =\n          pendingPublishSequenceNumber;\n      }\n\n      rheaMessages.push(rheaMessage);\n    }\n\n    // Encode every amqp message and then convert every encoded message to amqp data section\n    const batchMessage: RheaMessage = {\n      body: message.data_sections(rheaMessages.map(message.encode)),\n    };\n\n    // Set message_annotations of the first message as\n    // that of the envelope (batch message).\n    if (rheaMessages[0].message_annotations) {\n      batchMessage.message_annotations = { ...rheaMessages[0].message_annotations };\n    }\n\n    // Finally encode the envelope (batch message).\n    return message.encode(batchMessage);\n  }\n}\n\n/**\n * Commits the pending publish sequence number events.\n * EventDataBatch exposes this as `startingPublishSequenceNumber`,\n * EventData not in a batch exposes this as `publishedSequenceNumber`.\n */\nfunction commitIdempotentSequenceNumbers(\n  events: Omit<EventDataInternal, \"getRawAmqpMessage\">[] | EventDataBatch\n): void {\n  if (isEventDataBatch(events)) {\n    (events as EventDataBatchImpl)._commitPublish();\n  } else {\n    // For each event, set the `publishedSequenceNumber` equal to the sequence number\n    // we set when we attempted to send the events to the service.\n    for (const event of events) {\n      event._publishedSequenceNumber = event[PENDING_PUBLISH_SEQ_NUM_SYMBOL];\n      delete event[PENDING_PUBLISH_SEQ_NUM_SYMBOL];\n    }\n  }\n}\n\n/**\n * Rolls back any pending publish sequence number in the events.\n */\nfunction rollbackIdempotentSequenceNumbers(\n  events: Omit<EventDataInternal, \"getRawAmqpMessage\">[] | EventDataBatch\n): void {\n  if (isEventDataBatch(events)) {\n    /* No action required. */\n  } else {\n    for (const event of events) {\n      delete event[PENDING_PUBLISH_SEQ_NUM_SYMBOL];\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { ConnectionContext, createConnectionContext } from \"./connectionContext\";\nimport {\n  CreateBatchOptions,\n  EventHubClientOptions,\n  GetEventHubPropertiesOptions,\n  GetPartitionIdsOptions,\n  GetPartitionPropertiesOptions,\n  SendBatchOptions,\n} from \"./models/public\";\nimport { PartitionPublishingOptions, PartitionPublishingProperties } from \"./models/private\";\nimport { EventDataBatch, EventDataBatchImpl, isEventDataBatch } from \"./eventDataBatch\";\nimport { EventHubProperties, PartitionProperties } from \"./managementClient\";\nimport { TracingContext, TracingSpanLink } from \"@azure/core-tracing\";\nimport { NamedKeyCredential, SASCredential, TokenCredential } from \"@azure/core-auth\";\nimport { isDefined } from \"@azure/core-util\";\nimport { isCredential } from \"./util/typeGuards\";\nimport { logErrorStackTrace, logger } from \"./logger\";\nimport {\n  idempotentAlreadyPublished,\n  idempotentSomeAlreadyPublished,\n  throwErrorIfConnectionClosed,\n  throwTypeErrorIfParameterMissing,\n  validateProducerPartitionSettings,\n} from \"./util/error\";\nimport { AmqpAnnotatedMessage } from \"@azure/core-amqp\";\nimport { EventData, EventDataInternal } from \"./eventData\";\nimport { EventHubSender } from \"./eventHubSender\";\nimport { OperationOptions } from \"./util/operationOptions\";\nimport { toSpanOptions, tracingClient } from \"./diagnostics/tracing\";\nimport { instrumentEventData } from \"./diagnostics/instrumentEventData\";\n\n/**\n * The `EventHubProducerClient` class is used to send events to an Event Hub.\n *\n * There are multiple ways to create an `EventHubProducerClient`\n * - Use the connection string from the SAS policy created for your Event Hub instance.\n * - Use the connection string from the SAS policy created for your Event Hub namespace,\n * and the name of the Event Hub instance\n * - Use the full namespace like `<yournamespace>.servicebus.windows.net`, and a credentials object.\n *\n * Optionally, you can also pass an options bag to configure the retry policy or proxy settings.\n *\n */\nexport class EventHubProducerClient {\n  /**\n   * Describes the amqp connection context for the client.\n   */\n  private _context: ConnectionContext;\n\n  /**\n   * The options passed by the user when creating the EventHubClient instance.\n   */\n  private _clientOptions: EventHubClientOptions;\n  /**\n   * Map of partitionId to senders\n   */\n  private _sendersMap: Map<string, EventHubSender>;\n  /**\n   * Indicates whether or not the EventHubProducerClient should enable idempotent publishing to Event Hub partitions.\n   * If enabled, the producer will only be able to publish directly to partitions;\n   * it will not be able to publish to the Event Hubs gateway for automatic partition routing\n   * nor will it be able to use a partition key.\n   * Default: false\n   */\n  private _enableIdempotentRetries?: boolean;\n  /**\n   * The set of options that can be specified to influence publishing behavior specific to the configured Event Hub partition.\n   * These options are not necessary in the majority of scenarios and are intended for use with specialized scenarios,\n   * such as when recovering the state used for idempotent publishing.\n   */\n  private _partitionOptions?: Record<string, PartitionPublishingOptions>;\n  /**\n   * @readonly\n   * The name of the Event Hub instance for which this client is created.\n   */\n  get eventHubName(): string {\n    return this._context.config.entityPath;\n  }\n\n  /**\n   * @readonly\n   * The fully qualified namespace of the Event Hub instance for which this client is created.\n   * This is likely to be similar to <yournamespace>.servicebus.windows.net.\n   */\n  get fullyQualifiedNamespace(): string {\n    return this._context.config.host;\n  }\n\n  /**\n   * The `EventHubProducerClient` class is used to send events to an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param connectionString - The connection string to use for connecting to the Event Hub instance.\n   * It is expected that the shared key properties and the Event Hub path are contained in this connection string.\n   * e.g. 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key;EntityPath=my-event-hub-name'.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(connectionString: string, options?: EventHubClientOptions); // eslint-disable-line @azure/azure-sdk/ts-naming-options\n  /**\n   * The `EventHubProducerClient` class is used to send events to an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param connectionString - The connection string to use for connecting to the Event Hubs namespace.\n   * It is expected that the shared key properties are contained in this connection string, but not the Event Hub path,\n   * e.g. 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key;'.\n   * @param eventHubName - The name of the specific Event Hub to connect the client to.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(connectionString: string, eventHubName: string, options?: EventHubClientOptions); // eslint-disable-line @azure/azure-sdk/ts-naming-options\n  /**\n   * The `EventHubProducerClient` class is used to send events to an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param fullyQualifiedNamespace - The full namespace which is likely to be similar to\n   * <yournamespace>.servicebus.windows.net\n   * @param eventHubName - The name of the specific Event Hub to connect the client to.\n   * @param credential - An credential object used by the client to get the token to authenticate the connection\n   * with the Azure Event Hubs service.\n   * See &commat;azure/identity for creating credentials that support AAD auth.\n   * Use the `AzureNamedKeyCredential` from &commat;azure/core-auth if you want to pass in a `SharedAccessKeyName`\n   * and `SharedAccessKey` without using a connection string. These fields map to the `name` and `key` field respectively\n   * in `AzureNamedKeyCredential`.\n   * Use the `AzureSASCredential` from &commat;azure/core-auth if you want to pass in a `SharedAccessSignature`\n   * without using a connection string. This field maps to `signature` in `AzureSASCredential`.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(\n    fullyQualifiedNamespace: string,\n    eventHubName: string,\n    credential: TokenCredential | NamedKeyCredential | SASCredential,\n    options?: EventHubClientOptions // eslint-disable-line @azure/azure-sdk/ts-naming-options\n  );\n  constructor(\n    fullyQualifiedNamespaceOrConnectionString1: string,\n    eventHubNameOrOptions2?: string | EventHubClientOptions,\n    credentialOrOptions3?:\n      | TokenCredential\n      | NamedKeyCredential\n      | SASCredential\n      | EventHubClientOptions,\n    options4?: EventHubClientOptions // eslint-disable-line @azure/azure-sdk/ts-naming-options\n  ) {\n    this._context = createConnectionContext(\n      fullyQualifiedNamespaceOrConnectionString1,\n      eventHubNameOrOptions2,\n      credentialOrOptions3,\n      options4\n    );\n    if (typeof eventHubNameOrOptions2 !== \"string\") {\n      this._clientOptions = eventHubNameOrOptions2 || {};\n    } else if (!isCredential(credentialOrOptions3)) {\n      this._clientOptions = credentialOrOptions3 || {};\n    } else {\n      this._clientOptions = options4 || {};\n    }\n\n    this._sendersMap = new Map();\n  }\n\n  /**\n   * Creates an instance of `EventDataBatch` to which one can add events until the maximum supported size is reached.\n   * The batch can be passed to the {@link sendBatch} method of the `EventHubProducerClient` to be sent to Azure Event Hubs.\n   *\n   * Events with different values for partitionKey or partitionId will need to be put into different batches.\n   * To simplify such batch management across partitions or to have the client automatically batch events\n   * and send them in specific intervals, use `EventHubBufferedProducerClient` instead.\n   *\n   * The below example assumes you have an array of events at hand to be batched safely.\n   * If you have events coming in one by one, `EventHubBufferedProducerClient` is recommended instead\n   * for effecient management of batches.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new EventHubProducerClient(connectionString);\n   * let batch = await client.createBatch();\n   * for (let i = 0; i < messages.length; i++) {\n   *  if (!batch.tryAdd(messages[i])) {\n   *    await client.sendBatch(batch);\n   *    batch = await client.createBatch();\n   *    if (!batch.tryAdd(messages[i])) {\n   *      throw new Error(\"Message too big to fit\")\n   *    }\n   *    if (i === messages.length - 1) {\n   *      await client.sendBatch(batch);\n   *    }\n   *   }\n   * }\n   * ```\n   *\n   * @param options -  Configures the behavior of the batch.\n   * - `partitionKey`  : A value that is hashed and used by the Azure Event Hubs service to determine the partition to which\n   * the events need to be sent.\n   * - `partitionId`   : Id of the partition to which the batch of events need to be sent.\n   * - `maxSizeInBytes`: The upper limit for the size of batch. The `tryAdd` function will return `false` after this limit is reached.\n   * - `abortSignal`   : A signal the request to cancel the operation.\n   * @returns Promise<EventDataBatch>\n   * @throws Error if both `partitionId` and `partitionKey` are set in the options.\n   * @throws Error if the underlying connection has been closed, create a new EventHubProducerClient.\n   * @throws AbortError if the operation is cancelled via the abortSignal in the options.\n   */\n  async createBatch(options: CreateBatchOptions = {}): Promise<EventDataBatch> {\n    throwErrorIfConnectionClosed(this._context);\n\n    const partitionId = isDefined(options.partitionId) ? String(options.partitionId) : undefined;\n\n    validateProducerPartitionSettings({\n      enableIdempotentRetries: this._enableIdempotentRetries,\n      partitionId,\n      partitionKey: options.partitionKey,\n    });\n\n    let sender = this._sendersMap.get(partitionId || \"\");\n    if (!sender) {\n      const partitionPublishingOptions = isDefined(partitionId)\n        ? this._partitionOptions?.[partitionId]\n        : undefined;\n      sender = EventHubSender.create(this._context, {\n        enableIdempotentProducer: Boolean(this._enableIdempotentRetries),\n        partitionId,\n        partitionPublishingOptions,\n      });\n      this._sendersMap.set(partitionId || \"\", sender);\n    }\n\n    let maxMessageSize = await sender.getMaxMessageSize({\n      retryOptions: this._clientOptions.retryOptions,\n      abortSignal: options.abortSignal,\n    });\n\n    if (options.maxSizeInBytes) {\n      if (options.maxSizeInBytes > maxMessageSize) {\n        const error = new Error(\n          `Max message size (${options.maxSizeInBytes} bytes) is greater than maximum message size (${maxMessageSize} bytes) on the AMQP sender link.`\n        );\n        logger.warning(`[${this._context.connectionId}] ${error.message}`);\n        logErrorStackTrace(error);\n        throw error;\n      }\n      maxMessageSize = options.maxSizeInBytes;\n    }\n    return new EventDataBatchImpl(\n      this._context,\n      maxMessageSize,\n      Boolean(this._enableIdempotentRetries),\n      options.partitionKey,\n      partitionId\n    );\n  }\n\n  /**\n   * Get the information about the state of publishing for a partition as observed by the `EventHubProducerClient`.\n   * This data can always be read, but will only be populated with information relevant to the active features\n   * for the producer client.\n   *\n   * @param partitionId - Id of the partition from which to retrieve publishing properties.\n   * @param options - The set of options to apply to the operation call.\n   * - `abortSignal`  : A signal the request to cancel the send operation.\n   * @returns Promise<void>\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   */\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore this is called in EventHubBufferedProducerClient via cast-to-any workaround\n  private async getPartitionPublishingProperties(\n    partitionId: string,\n    options: OperationOptions = {}\n  ): Promise<PartitionPublishingProperties> {\n    if (!isDefined(partitionId)) {\n      throw new TypeError(\n        `getPartitionPublishingProperties called without required argument \"partitionId\"`\n      );\n    }\n\n    if (typeof partitionId === \"number\") {\n      partitionId = String(partitionId);\n    }\n\n    let sender = this._sendersMap.get(partitionId);\n    if (!sender) {\n      sender = EventHubSender.create(this._context, {\n        enableIdempotentProducer: Boolean(this._enableIdempotentRetries),\n        partitionId,\n        partitionPublishingOptions: this._partitionOptions?.[partitionId],\n      });\n      this._sendersMap.set(partitionId, sender);\n    }\n\n    return sender.getPartitionPublishingProperties(options);\n  }\n\n  /**\n   * Sends an array of events as a batch to the associated Event Hub.\n   *\n   * Azure Event Hubs has a limit on the size of the batch that can be sent which if exceeded\n   * will result in an error with code `MessageTooLargeError`.\n   * To safely send within batch size limits, use `EventHubProducerClient.createBatch()` or\n   * `EventHubBufferedProducerClient` instead.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new EventHubProducerClient(connectionString);\n   * await client.sendBatch(messages);\n   * ```\n   *\n   * @param batch - An array of {@link EventData} or `AmqpAnnotatedMessage`.\n   * @param options - A set of options that can be specified to influence the way in which\n   * events are sent to the associated Event Hub.\n   * - `abortSignal`  : A signal the request to cancel the send operation.\n   * - `partitionId`  : The partition this batch will be sent to. If set, `partitionKey` can not be set.\n   * - `partitionKey` : A value that is hashed to produce a partition assignment. If set, `partitionId` can not be set.\n   *\n   * @returns Promise<void>\n   * @throws MessageTooLargeError if all the events in the input array cannot be fit into a batch.\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   * @throws MessagingError if an error is encountered while sending a message.\n   * @throws Error if the underlying connection or sender has been closed.\n   */\n  async sendBatch(\n    batch: EventData[] | AmqpAnnotatedMessage[],\n    options?: SendBatchOptions\n  ): Promise<void>;\n  /**\n   * Sends a batch of events created using `EventHubProducerClient.createBatch()` to the associated Event Hub.\n   *\n   * Events with different values for partitionKey or partitionId will need to be put into different batches.\n   * To simplify such batch management across partitions or to have the client automatically batch events\n   * and send them in specific intervals, use `EventHubBufferedProducerClient` instead.\n   *\n   * The below example assumes you have an array of events at hand to be batched safely.\n   * If you have events coming in one by one, `EventHubBufferedProducerClient` is recommended instead\n   * for effecient management of batches.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new EventHubProducerClient(connectionString);\n   * let batch = await client.createBatch();\n   * for (let i = 0; i < messages.length; i++) {\n   *  if (!batch.tryAdd(messages[i])) {\n   *    await client.sendBatch(batch);\n   *    batch = await client.createBatch();\n   *    if (!batch.tryAdd(messages[i])) {\n   *      throw new Error(\"Message too big to fit\")\n   *    }\n   *    if (i === messages.length - 1) {\n   *      await client.sendBatch(batch);\n   *    }\n   *   }\n   * }\n   * ```\n   * @param batch - A batch of events that you can create using the {@link createBatch} method.\n   * @param options - A set of options that can be specified to influence the way in which\n   * events are sent to the associated Event Hub.\n   * - `abortSignal`  : A signal the request to cancel the send operation.\n   *\n   * @returns Promise<void>\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   * @throws MessagingError if an error is encountered while sending a message.\n   * @throws Error if the underlying connection or sender has been closed.\n   */\n  async sendBatch(batch: EventDataBatch, options?: OperationOptions): Promise<void>; // eslint-disable-line @azure/azure-sdk/ts-naming-options\n  async sendBatch(\n    batch: EventDataBatch | EventData[],\n    options: SendBatchOptions | OperationOptions = {}\n  ): Promise<void> {\n    throwErrorIfConnectionClosed(this._context);\n    throwTypeErrorIfParameterMissing(this._context.connectionId, \"sendBatch\", \"batch\", batch);\n\n    let partitionId: string | undefined;\n    let partitionKey: string | undefined;\n\n    // Holds an EventData properties object containing tracing properties.\n    // This lets us avoid cloning batch when it is EventData[], which is\n    // important as the idempotent EventHubSender needs to decorate the\n    // original EventData passed through.\n    const eventDataTracingProperties: Array<EventData[\"properties\"]> = [];\n\n    // link message span contexts\n    let spanContextsToLink: TracingContext[] = [];\n\n    if (isEventDataBatch(batch)) {\n      if (\n        this._enableIdempotentRetries &&\n        isDefined((batch as EventDataBatchImpl).startingPublishedSequenceNumber)\n      ) {\n        throw new Error(idempotentAlreadyPublished);\n      }\n      const partitionAssignment = extractPartitionAssignmentFromBatch(batch, options);\n      partitionId = partitionAssignment.partitionId;\n      partitionKey = partitionAssignment.partitionKey;\n      spanContextsToLink = (batch as EventDataBatchImpl)._messageSpanContexts;\n    } else {\n      if (!Array.isArray(batch)) {\n        batch = [batch];\n      }\n      if (batch.some((event) => isDefined((event as EventDataInternal)._publishedSequenceNumber))) {\n        throw new Error(idempotentSomeAlreadyPublished);\n      }\n      const partitionAssignment = extractPartitionAssignmentFromOptions(options);\n      partitionId = partitionAssignment.partitionId;\n      partitionKey = partitionAssignment.partitionKey;\n\n      for (let i = 0; i < batch.length; i++) {\n        batch[i] = instrumentEventData(\n          batch[i],\n          options,\n          this._context.config.entityPath,\n          this._context.config.host,\n          \"publish\"\n        ).event;\n        eventDataTracingProperties[i] = batch[i].properties;\n      }\n    }\n\n    validateProducerPartitionSettings({\n      enableIdempotentRetries: this._enableIdempotentRetries,\n      partitionId,\n      partitionKey,\n    });\n\n    return tracingClient.withSpan(\n      `${EventHubProducerClient.name}.${this.sendBatch.name}`,\n      options,\n      (updatedOptions) => {\n        let sender = this._sendersMap.get(partitionId || \"\");\n        if (!sender) {\n          const partitionPublishingOptions = isDefined(partitionId)\n            ? this._partitionOptions?.[partitionId]\n            : undefined;\n          sender = EventHubSender.create(this._context, {\n            enableIdempotentProducer: Boolean(this._enableIdempotentRetries),\n            partitionId,\n            partitionPublishingOptions,\n          });\n          this._sendersMap.set(partitionId || \"\", sender);\n        }\n\n        return sender.send(batch, {\n          ...updatedOptions,\n          partitionId,\n          partitionKey,\n          retryOptions: this._clientOptions.retryOptions,\n        });\n      },\n      {\n        spanLinks: spanContextsToLink.map<TracingSpanLink>((tracingContext) => {\n          return { tracingContext };\n        }),\n        ...toSpanOptions(this._context.config, \"publish\", \"client\"),\n      }\n    );\n  }\n\n  /**\n   * Closes the AMQP connection to the Event Hub instance,\n   * returning a promise that will be resolved when disconnection is completed.\n   * @returns Promise<void>\n   * @throws Error if the underlying connection encounters an error while closing.\n   */\n  async close(): Promise<void> {\n    await this._context.close();\n\n    for (const pair of this._sendersMap) {\n      await pair[1].close();\n    }\n    this._sendersMap.clear();\n  }\n\n  /**\n   * Provides the Event Hub runtime information.\n   * @param options - The set of options to apply to the operation call.\n   * @returns A promise that resolves with information about the Event Hub instance.\n   * @throws Error if the underlying connection has been closed, create a new EventHubProducerClient.\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   */\n  getEventHubProperties(options: GetEventHubPropertiesOptions = {}): Promise<EventHubProperties> {\n    return this._context.managementSession!.getEventHubProperties({\n      ...options,\n      retryOptions: this._clientOptions.retryOptions,\n    });\n  }\n\n  /**\n   * Provides the id for each partition associated with the Event Hub.\n   * @param options - The set of options to apply to the operation call.\n   * @returns A promise that resolves with an Array of strings representing the id for\n   * each partition associated with the Event Hub.\n   * @throws Error if the underlying connection has been closed, create a new EventHubProducerClient.\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   */\n  getPartitionIds(options: GetPartitionIdsOptions = {}): Promise<Array<string>> {\n    return this._context\n      .managementSession!.getEventHubProperties({\n        ...options,\n        retryOptions: this._clientOptions.retryOptions,\n      })\n      .then((eventHubProperties) => {\n        return eventHubProperties.partitionIds;\n      });\n  }\n\n  /**\n   * Provides information about the state of the specified partition.\n   * @param partitionId - The id of the partition for which information is required.\n   * @param options - The set of options to apply to the operation call.\n   * @returns A promise that resolves with information about the state of the partition .\n   * @throws Error if the underlying connection has been closed, create a new EventHubProducerClient.\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   */\n  getPartitionProperties(\n    partitionId: string,\n    options: GetPartitionPropertiesOptions = {}\n  ): Promise<PartitionProperties> {\n    return this._context.managementSession!.getPartitionProperties(partitionId, {\n      ...options,\n      retryOptions: this._clientOptions.retryOptions,\n    });\n  }\n}\n\n/**\n * @internal\n */\nfunction extractPartitionAssignmentFromOptions(options: SendBatchOptions = {}): {\n  partitionKey?: string;\n  partitionId?: string;\n} {\n  const result: ReturnType<typeof extractPartitionAssignmentFromOptions> = {};\n  const { partitionId, partitionKey } = options;\n\n  if (isDefined(partitionId)) {\n    result.partitionId = String(partitionId);\n  }\n  if (isDefined(partitionKey)) {\n    result.partitionKey = String(partitionKey);\n  }\n\n  return result;\n}\n\n/**\n * @internal\n */\nfunction extractPartitionAssignmentFromBatch(\n  batch: EventDataBatch,\n  options: SendBatchOptions\n): { partitionKey?: string; partitionId?: string } {\n  const result: ReturnType<typeof extractPartitionAssignmentFromBatch> = {};\n  const partitionId = batch.partitionId;\n  const partitionKey = batch.partitionKey;\n\n  const { partitionId: unexpectedPartitionId, partitionKey: unexpectedPartitionKey } =\n    extractPartitionAssignmentFromOptions(options);\n  if (unexpectedPartitionKey && partitionKey !== unexpectedPartitionKey) {\n    throw new Error(\n      `The partitionKey (${unexpectedPartitionKey}) set on sendBatch does not match the partitionKey (${partitionKey}) set when creating the batch.`\n    );\n  }\n  if (unexpectedPartitionId && unexpectedPartitionId !== partitionId) {\n    throw new Error(\n      `The partitionId (${unexpectedPartitionId}) set on sendBatch does not match the partitionId (${partitionId}) set when creating the batch.`\n    );\n  }\n\n  if (isDefined(partitionId)) {\n    result.partitionId = String(partitionId);\n  }\n  if (isDefined(partitionKey)) {\n    result.partitionKey = String(partitionKey);\n  }\n\n  return result;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/**\n * `AwaitableQueue` stores items in the order that they are received.\n *\n * This differs from ordinary Queues in that `shift` returns a Promise for a value.\n * This allows a consumer of the queue to request an item that the queue does not yet have.\n *\n * @internal\n */\nexport class AwaitableQueue<T> {\n  private readonly _items: T[];\n\n  private readonly _resolvers: Array<(value: T) => void> = [];\n\n  constructor() {\n    this._items = [];\n  }\n\n  public size(): number {\n    return this._items.length;\n  }\n\n  /**\n   * Returns a Promise that will resolve with the next item in the queue.\n   */\n  public shift(): Promise<T> {\n    const item = this._items.shift();\n    if (typeof item !== \"undefined\") {\n      return Promise.resolve(item);\n    }\n\n    return new Promise<T>((resolve) => this._resolvers.push(resolve));\n  }\n\n  /**\n   * Appends new item to the queue.\n   */\n  public push(item: T): void {\n    if (!this._resolveNextItem(item)) {\n      this._items.push(item);\n    }\n  }\n\n  private _resolveNextItem(item: T) {\n    const resolver = this._resolvers.shift();\n    if (!resolver) {\n      return false;\n    }\n\n    resolver(item);\n    return true;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/**\n * @internal\n * Returns a promise and the promise's resolve and reject methods.\n */\nexport function getPromiseParts<T = unknown>(): {\n  promise: Promise<T>;\n  resolve: (value: T) => void;\n  reject: (reason: Error) => void;\n} {\n  let resolver: (value: T) => void;\n  let rejector: (reason?: any) => void;\n  const promise = new Promise<T>((resolve, reject) => {\n    resolver = resolve;\n    rejector = reject;\n  });\n  return {\n    promise,\n    resolve: resolver!,\n    reject: rejector!,\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AmqpAnnotatedMessage, delay } from \"@azure/core-amqp\";\nimport {\n  EventData,\n  EventDataBatch,\n  EventHubBufferedProducerClientOptions,\n  EventHubProducerClient,\n  OperationOptions,\n} from \"./index\";\nimport { isDefined, isObjectWithProperties } from \"@azure/core-util\";\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { AwaitableQueue } from \"./impl/awaitableQueue\";\nimport { getPromiseParts } from \"./util/getPromiseParts\";\nimport { logger } from \"./logger\";\n\nexport interface BatchingPartitionChannelProps {\n  loopAbortSignal: AbortSignalLike;\n  maxBufferSize: number;\n  maxWaitTimeInMs: number;\n  partitionId: string;\n  producer: EventHubProducerClient;\n  /**\n   * The handler to call once a batch has successfully published.\n   */\n  onSendEventsSuccessHandler?: EventHubBufferedProducerClientOptions[\"onSendEventsSuccessHandler\"];\n  /**\n   * The handler to call when a batch fails to publish.\n   */\n  onSendEventsErrorHandler: EventHubBufferedProducerClientOptions[\"onSendEventsErrorHandler\"];\n}\n\n/**\n * The `BatchingPartitionChannel` is responsible for accepting enqueued events\n * and optimally batching and sending them to an Event Hub.\n * @internal\n */\nexport class BatchingPartitionChannel {\n  private _eventQueue = new AwaitableQueue<EventData | AmqpAnnotatedMessage>();\n  private _batchedEvents: Array<EventData | AmqpAnnotatedMessage> = [];\n  private _bufferCount: number = 0;\n  private _readyQueue: Array<{\n    resolve: (value: void) => void;\n    reject: (reason?: any) => void;\n  }> = [];\n  private _flushState:\n    | { isFlushing: false }\n    | { isFlushing: true; currentPromise: Promise<void>; resolve: () => void } = {\n    isFlushing: false,\n  };\n  private _isRunning: boolean = false;\n  private _lastBatchCreationTime: number = 0;\n  private _loopAbortSignal: AbortSignalLike;\n  private _maxBufferSize: number;\n  private _maxWaitTimeInMs: number;\n  private _onSendEventsErrorHandler: EventHubBufferedProducerClientOptions[\"onSendEventsErrorHandler\"];\n  private _onSendEventsSuccessHandler?: EventHubBufferedProducerClientOptions[\"onSendEventsSuccessHandler\"];\n\n  private _partitionId: string;\n  private _producer: EventHubProducerClient;\n\n  constructor({\n    loopAbortSignal,\n    maxBufferSize,\n    maxWaitTimeInMs,\n    onSendEventsErrorHandler,\n    onSendEventsSuccessHandler,\n    partitionId,\n    producer,\n  }: BatchingPartitionChannelProps) {\n    this._loopAbortSignal = loopAbortSignal;\n    this._maxBufferSize = maxBufferSize;\n    this._maxWaitTimeInMs = maxWaitTimeInMs;\n    this._onSendEventsErrorHandler = onSendEventsErrorHandler;\n    this._onSendEventsSuccessHandler = onSendEventsSuccessHandler;\n    this._partitionId = partitionId;\n    this._producer = producer;\n  }\n\n  getCurrentBufferedCount(): number {\n    return this._bufferCount;\n  }\n\n  async enqueueEvent(event: EventData | AmqpAnnotatedMessage): Promise<void> {\n    await this._ready();\n    this._eventQueue.push(event);\n    this._bufferCount++;\n\n    if (!this._isRunning) {\n      this._isRunning = true;\n      this._startPublishLoop().catch((e) => {\n        logger.error(\n          `The following error occured during batch creation or sending: ${JSON.stringify(\n            e,\n            undefined,\n            \"  \"\n          )}`\n        );\n      });\n    }\n  }\n\n  /**\n   * Sets the flush state so that no new events can be enqueued until\n   * all the currently buffered events are sent to the Event Hub.\n   *\n   * Returns a promise that resolves once flushing is complete.\n   */\n  async flush(_options: OperationOptions = {}): Promise<void> {\n    const state = this._flushState;\n    if (state.isFlushing) {\n      return state.currentPromise;\n    }\n\n    if (this.getCurrentBufferedCount() === 0) {\n      return Promise.resolve();\n    }\n\n    const { promise, resolve } = getPromiseParts<void>();\n    this._flushState = { isFlushing: true, currentPromise: promise, resolve };\n\n    return promise;\n  }\n\n  /**\n   * Returns a promise that resolves once there is room for events to be added\n   * to the buffer.\n   */\n  private _ready(): Promise<void> {\n    const currentBufferedCount = this.getCurrentBufferedCount();\n\n    // If the buffer isn't full and we don't have any pending `ready()` calls,\n    // then it's safe to return right away.\n    if (\n      currentBufferedCount < this._maxBufferSize &&\n      !this._readyQueue.length &&\n      !this._flushState.isFlushing\n    ) {\n      return Promise.resolve();\n    }\n\n    const { promise: readyPromise, reject, resolve } = getPromiseParts<void>();\n    this._readyQueue.push({ resolve, reject });\n\n    return readyPromise;\n  }\n\n  /**\n   * Starts the loop that creates batches and sends them to the Event Hub.\n   *\n   * The loop will run until the `_loopAbortSignal` is aborted.\n   */\n  private async _startPublishLoop() {\n    let batch: EventDataBatch | undefined;\n    let futureEvent = this._eventQueue.shift();\n    // `eventToAddToBatch` is used to keep track of an event that has been removed\n    // from the queue, but has not yet been added to a batch.\n    // This prevents losing an event if a `sendBatch` or `createBatch` call fails\n    // before the event is added to a batch.\n    let eventToAddToBatch: EventData | AmqpAnnotatedMessage | undefined;\n    while (!this._loopAbortSignal.aborted) {\n      try {\n        if (!isDefined(batch)) {\n          batch = await this._createBatch();\n        }\n        const timeSinceLastBatchCreation = Date.now() - this._lastBatchCreationTime;\n        const maximumTimeToWaitForEvent = batch.count\n          ? Math.max(this._maxWaitTimeInMs - timeSinceLastBatchCreation, 0)\n          : this._maxWaitTimeInMs;\n\n        const event =\n          eventToAddToBatch ??\n          (await Promise.race([futureEvent, delay<void>(maximumTimeToWaitForEvent)]));\n\n        if (!event) {\n          // We didn't receive an event within the allotted time.\n          // Send the existing batch if it has events in it.\n          if (batch.count) {\n            await this._producer.sendBatch(batch);\n            this._reportSuccess();\n            batch = await this._createBatch();\n          }\n          continue;\n        } else if (!eventToAddToBatch) {\n          eventToAddToBatch = event;\n          // We received an event, so get a promise for the next one.\n          futureEvent = this._eventQueue.shift();\n        }\n\n        const didAdd = batch.tryAdd(event);\n        if (didAdd) {\n          // This event will definitely make it to one of the user-provided handlers\n          // since it was added to a batch.\n          // Store it so we can return it in a handler later.\n          this._batchedEvents.push(event);\n          // Clear reference to existing event since it has been added to the batch.\n          eventToAddToBatch = undefined;\n        }\n\n        if (didAdd && batch.count >= this._maxBufferSize) {\n          // Whenever batch.count exceeds the max count of buffered events, send the batch.\n          await this._producer.sendBatch(batch);\n          this._reportSuccess();\n          batch = await this._createBatch();\n        } else if (!didAdd && batch.count) {\n          // If the event wasn't able to be added and the current batch isn't empty,\n          // attempt to send the current batch and add the event to a new batch.\n          await this._producer.sendBatch(batch);\n          this._reportSuccess();\n          batch = await this._createBatch();\n        }\n\n        if (!didAdd && !batch.tryAdd(event)) {\n          // TODO: Report MaxMesageSizeExceeded error. Mimic service's error.\n          this._reportFailure(new Error(\"Placeholder for max message size exceeded\"), event);\n        } else if (!didAdd) {\n          // Handles the case where the event _was_ successfull added to the new batch.\n          this._batchedEvents.push(event);\n        }\n        // Clear reference to existing event since it has been added to the batch.\n        eventToAddToBatch = undefined;\n      } catch (err: any) {\n        if (!isObjectWithProperties(err, [\"name\"]) || err.name !== \"AbortError\") {\n          this._reportFailure(err);\n          batch = undefined;\n          this._batchedEvents = [];\n        }\n      }\n    }\n  }\n\n  /**\n   * Helper method that returns an `EventDataBatch`.\n   * This also has the side effects of\n   *  - keeping track of batch creation time: needed for maxWaitTime calculations.\n   *  - clearing reference to batched events.\n   *  - incrementing the readiness: creating a new batch indicates the buffer\n   *    should have room, so we can resolve some pending `ready()` calls.\n   */\n  private async _createBatch(): Promise<EventDataBatch> {\n    this._lastBatchCreationTime = Date.now();\n    this._batchedEvents = [];\n    const batch = await this._producer.createBatch({\n      partitionId: this._partitionId,\n    });\n    this._incrementReadiness();\n    return batch;\n  }\n\n  /**\n   * This method will resolve as many pending `ready()` calls as it can\n   * based on how much space remains in the buffer.\n   *\n   * If the channel is currently flushing, this is a no-op. This prevents\n   * `enqueueEvent` calls from adding the event to the buffer until flushing\n   * completes.\n   */\n  private _incrementReadiness() {\n    if (this._flushState.isFlushing) {\n      return;\n    }\n    const currentBufferedCount = this.getCurrentBufferedCount();\n    const num = Math.min(this._maxBufferSize - currentBufferedCount, this._readyQueue.length);\n    for (let i = 0; i < num; i++) {\n      this._readyQueue.shift()?.resolve();\n    }\n  }\n\n  /**\n   * Calls the user-provided `onSendEventsSuccessHandler` with the events\n   * that were successfully sent.\n   */\n  private _reportSuccess() {\n    this._bufferCount = this._bufferCount - this._batchedEvents.length;\n    this._updateFlushState();\n    try {\n      this._onSendEventsSuccessHandler?.({\n        events: this._batchedEvents,\n        partitionId: this._partitionId,\n      });\n    } catch (e: unknown) {\n      logger.error(\n        `The following error occurred in the onSendEventsSuccessHandler: ${JSON.stringify(\n          e,\n          undefined,\n          \"  \"\n        )}`\n      );\n    }\n  }\n\n  /**\n   * Calls the user-provided `onSendEventsErrorHandler` with an error and the events\n   * that were not successfully sent.\n   */\n  private _reportFailure(err: any, event?: EventData | AmqpAnnotatedMessage) {\n    this._bufferCount = this._bufferCount - (event ? 1 : this._batchedEvents.length);\n    this._updateFlushState();\n    try {\n      this._onSendEventsErrorHandler({\n        error: err,\n        events: event ? [event] : this._batchedEvents,\n        partitionId: this._partitionId,\n      });\n    } catch (e: unknown) {\n      logger.error(\n        `The following error occurred in the onSendEventsErrorHandler: ${JSON.stringify(\n          e,\n          undefined,\n          \"  \"\n        )}`\n      );\n    }\n  }\n\n  /**\n   * Updates the channel's flush state once the size of the\n   * event buffer has decreased to 0.\n   */\n  private _updateFlushState() {\n    const state = this._flushState;\n    if (!state.isFlushing || this.getCurrentBufferedCount() !== 0) {\n      return;\n    }\n\n    state.resolve();\n\n    this._flushState = { isFlushing: false };\n    this._incrementReadiness();\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/* eslint-disable no-fallthrough */\n\nexport function mapPartitionKeyToId(partitionKey: string, partitionCount: number): number {\n  const hashedParitionKey = hashPartitionKey(partitionKey);\n  return Math.abs(hashedParitionKey % partitionCount);\n}\n\n/**\n * @internal\n */\nexport function hashPartitionKey(partitionKey: string): number {\n  const hash = computeHash(Buffer.from(partitionKey, \"utf8\"));\n  return castToInt16(hash.c ^ hash.b);\n}\n\nfunction readUInt32(data: Buffer, offset: number): number {\n  return data.readUInt32LE(offset);\n}\n\nfunction castToInt16(n: number): number {\n  return new Int16Array([n])[0];\n}\n\nfunction computeHash(\n  data: Buffer,\n  seed1: number = 0,\n  seed2: number = 0\n): {\n  b: number;\n  c: number;\n} {\n  let a: number, b: number, c: number;\n\n  a = b = c = 0xdeadbeef + data.length + seed1;\n  c += seed2;\n\n  let index = 0,\n    size = data.length;\n  while (size > 12) {\n    a += readUInt32(data, index);\n    b += readUInt32(data, index + 4);\n    c += readUInt32(data, index + 8);\n\n    a -= c;\n    a ^= (c << 4) | (c >>> 28);\n    c += b;\n\n    b -= a;\n    b ^= (a << 6) | (a >>> 26);\n    a += c;\n\n    c -= b;\n    c ^= (b << 8) | (b >>> 24);\n    b += a;\n\n    a -= c;\n    a ^= (c << 16) | (c >>> 16);\n    c += b;\n\n    b -= a;\n    b ^= (a << 19) | (a >>> 13);\n    a += c;\n\n    c -= b;\n    c ^= (b << 4) | (b >>> 28);\n    b += a;\n\n    index += 12;\n    size -= 12;\n  }\n\n  let curr = size;\n  switch (curr) {\n    case 12:\n      a += readUInt32(data, index);\n      b += readUInt32(data, index + 4);\n      c += readUInt32(data, index + 8);\n      break;\n    case 11:\n      c += data[index + 10] << 16;\n      curr = 10;\n    case 10:\n      c += data[index + 9] << 8;\n      curr = 9;\n    case 9:\n      c += data[index + 8];\n      curr = 8;\n    case 8:\n      b += readUInt32(data, index + 4);\n      a += readUInt32(data, index);\n      break;\n    case 7:\n      b += data[index + 6] << 16;\n      curr = 6;\n    case 6:\n      b += data[index + 5] << 8;\n      curr = 5;\n    case 5:\n      b += data[index + 4];\n      curr = 4;\n    case 4:\n      a += readUInt32(data, index);\n      break;\n    case 3:\n      a += data[index + 2] << 16;\n      curr = 2;\n    case 2:\n      a += data[index + 1] << 8;\n      curr = 1;\n    case 1:\n      a += data[index];\n      break;\n    case 0:\n      return { b: b >>> 0, c: c >>> 0 };\n  }\n\n  c ^= b;\n  c -= (b << 14) | (b >>> 18);\n\n  a ^= c;\n  a -= (c << 11) | (c >>> 21);\n\n  b ^= a;\n  b -= (a << 25) | (a >>> 7);\n\n  c ^= b;\n  c -= (b << 16) | (b >>> 16);\n\n  a ^= c;\n  a -= (c << 4) | (c >>> 28);\n\n  b ^= a;\n  b -= (a << 14) | (a >>> 18);\n\n  c ^= b;\n  c -= (b << 24) | (b >>> 8);\n\n  return { b: b >>> 0, c: c >>> 0 };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { isDefined } from \"@azure/core-util\";\nimport { mapPartitionKeyToId } from \"./partitionKeyToIdMapper\";\n\n/**\n * @internal\n * Assigns a partition based on the partition ids it knows about and an optional partition id or partition key.\n */\nexport class PartitionAssigner {\n  private _partitions: string[] = [];\n\n  private _lastRoundRobinPartitionIndex: number = -1;\n\n  /**\n   * Set the partition ids that can be used when assigning a partition.\n   * @param partitionIds - All valid partition ids.\n   */\n  public setPartitionIds(partitionIds: string[]): void {\n    this._partitions = partitionIds;\n  }\n\n  /**\n   * Returns a partitionId from the list of partition ids set via `setPartitionIds`.\n   *\n   * If a partitionId is specified, then that will be returned directly.\n   * If a partitionKey is specified, then a partitionId will be calculated based on the partitionKey.\n   * Specifying both partitionId and partitionKey results in an error.\n   *\n   * If neither partitionId nor partitionKey are specified, then a partitionId will be selected\n   * based on a round-robin approach.\n   */\n  assignPartition({\n    partitionId,\n    partitionKey,\n  }: {\n    partitionId?: string;\n    partitionKey?: string;\n  }): string {\n    if (isDefined(partitionId) && isDefined(partitionKey)) {\n      throw new Error(\n        `The partitionId (${partitionId}) and partitionKey (${partitionKey}) cannot both be specified.`\n      );\n    }\n\n    if (!this._partitions.length) {\n      throw new Error(`Unable to determine partitionIds, can't assign partitionId.`);\n    }\n\n    if (isDefined(partitionId) && this._partitions.includes(partitionId)) {\n      return partitionId;\n    }\n\n    if (isDefined(partitionKey)) {\n      return mapPartitionKeyToId(partitionKey, this._partitions.length).toString();\n    }\n\n    return this._assignRoundRobinPartition();\n  }\n\n  private _assignRoundRobinPartition(): string {\n    const maxPartitionIndex = this._partitions.length - 1;\n    const proposedPartitionIndex = this._lastRoundRobinPartitionIndex + 1;\n\n    const nextPartitionIndex =\n      proposedPartitionIndex > maxPartitionIndex ? 0 : proposedPartitionIndex;\n\n    this._lastRoundRobinPartitionIndex = nextPartitionIndex;\n    return this._partitions[nextPartitionIndex];\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { EventData } from \"./eventData\";\nimport { EventHubProducerClient } from \"./eventHubProducerClient\";\nimport { OperationOptions } from \"./util/operationOptions\";\nimport {\n  EventHubClientOptions,\n  GetEventHubPropertiesOptions,\n  GetPartitionIdsOptions,\n  GetPartitionPropertiesOptions,\n  SendBatchOptions,\n} from \"./models/public\";\nimport { EventHubProperties, PartitionProperties } from \"./managementClient\";\nimport { NamedKeyCredential, SASCredential, TokenCredential } from \"@azure/core-auth\";\nimport { isDefined } from \"@azure/core-util\";\nimport { isCredential } from \"./util/typeGuards\";\nimport { AbortController } from \"@azure/abort-controller\";\nimport { AmqpAnnotatedMessage, delay } from \"@azure/core-amqp\";\nimport { BatchingPartitionChannel } from \"./batchingPartitionChannel\";\nimport { PartitionAssigner } from \"./impl/partitionAssigner\";\nimport { logger } from \"./logger\";\n\n/**\n * Contains the events that were successfully sent to the Event Hub,\n * and the partition they were assigned to.\n */\nexport interface OnSendEventsSuccessContext {\n  /**\n   * The partition each event was assigned.\n   */\n  partitionId: string;\n  /**\n   * The array of {@link EventData} and/or `AmqpAnnotatedMessage` that were successfully sent to the Event Hub.\n   */\n  events: Array<EventData | AmqpAnnotatedMessage>;\n}\n\n/**\n * Contains the events that were not successfully sent to the Event Hub,\n * the partition they were assigned to, and the error that was encountered while sending.\n */\nexport interface OnSendEventsErrorContext {\n  /**\n   * The partition each event was assigned.\n   */\n  partitionId: string;\n  /**\n   * The array of {@link EventData} and/or `AmqpAnnotatedMessage` that were not successfully sent to the Event Hub.\n   */\n  events: Array<EventData | AmqpAnnotatedMessage>;\n  /**\n   * The error that occurred when sending the associated events to the Event Hub.\n   */\n  error: Error;\n}\n\n/**\n * Describes the options that can be provided while creating the `EventHubBufferedProducerClient`.\n */\nexport interface EventHubBufferedProducerClientOptions extends EventHubClientOptions {\n  /**\n   * The total number of events that can be buffered for publishing at a given time for a given partition.\n   *\n   * Default: 1500\n   */\n  maxEventBufferLengthPerPartition?: number;\n  /**\n   * The amount of time to wait for a new event to be enqueued in the buffer before publishing a partially full batch.\n   *\n   * Default: 1 second.\n   */\n  maxWaitTimeInMs?: number;\n  /**\n   * The handler to call once a batch has successfully published.\n   */\n  onSendEventsSuccessHandler?: (ctx: OnSendEventsSuccessContext) => void;\n  /**\n   * The handler to call when a batch fails to publish.\n   */\n  onSendEventsErrorHandler: (ctx: OnSendEventsErrorContext) => void;\n  /**\n   * Indicates whether or not the EventHubProducerClient should enable idempotent publishing to Event Hub partitions.\n   * If enabled, the producer will only be able to publish directly to partitions;\n   * it will not be able to publish to the Event Hubs gateway for automatic partition routing\n   * nor will it be able to use a partition key.\n   * Default: false\n   */\n  enableIdempotentRetries?: boolean;\n}\n\n/**\n * Options to configure the `flush` method on the `EventHubBufferedProducerClient`.\n */\nexport interface BufferedFlushOptions extends OperationOptions {}\n\n/**\n * Options to configure the `close` method on the `EventHubBufferedProducerClient`.\n */\nexport interface BufferedCloseOptions extends OperationOptions {\n  /**\n   * When `true`, all buffered events that are pending should be sent before closing.\n   * When `false`, abandon all buffered events and close immediately.\n   * Defaults to `true`.\n   */\n  flush?: boolean;\n}\n\n/**\n * Options to configure the `enqueueEvents` method on the `EventHubBufferedProcuerClient`.\n */\nexport interface EnqueueEventOptions extends SendBatchOptions {}\n\n/**\n * The `EventHubBufferedProducerClient`is used to publish events to a specific Event Hub.\n *\n * The `EventHubBufferedProducerClient` does not publish events immediately.\n * Instead, events are buffered so they can be efficiently batched and published\n * when the batch is full or the `maxWaitTimeInMs` has elapsed with no new events\n * enqueued.\n *\n * Depending on the options specified when events are enqueued, they may be\n * automatically assigned to a partition, grouped according to the specified partition key,\n * or assigned a specifically requested partition.\n *\n * This model is intended to shift the burden of batch management from callers, at the cost of\n * non-deterministic timing, for when events will be published. There are additional trade-offs\n * to consider, as well:\n * - If the application crashes, events in the buffer will not have been published. To prevent\n *   data loss, callers are encouraged to track publishing progress using the\n *   `onSendEventsSuccessHandler` and `onSendEventsErrorHandler` handlers.\n * - Events specifying a partition key may be assigned a different partition than those using\n *   the same key with other producers.\n * - In the unlikely event that a partition becomes temporarily unavailable, the\n *   `EventHubBufferedProducerClient` may take longer to recover than other producers.\n *\n * In scenarios where it is important to have events published immediately with a deterministic\n * outcome, ensure that partition keys are assigned to a partition consistent with other\n * publishers, or where maximizing availability is a requirement, using the\n * `EventHubProducerClient` is recommended.\n */\nexport class EventHubBufferedProducerClient {\n  /**\n   * Controls the `abortSignal` passed to each `BatchingPartitionChannel`.\n   * Used to signal when a channel should stop waiting for events.\n   */\n  private _abortController = new AbortController();\n\n  /**\n   * Indicates whether the client has been explicitly closed.\n   */\n  private _isClosed: boolean = false;\n\n  /**\n   * Handles assigning partitions.\n   */\n  private _partitionAssigner = new PartitionAssigner();\n\n  /**\n   * The known partitionIds that will be used when assigning events to partitions.\n   */\n  private _partitionIds: string[] = [];\n\n  /**\n   * The EventHubProducerClient to use when creating and sending batches to the Event Hub.\n   */\n  private _producer: EventHubProducerClient;\n\n  /**\n   * Mapping of partitionIds to `BatchingPartitionChannels`.\n   * Each `BatchingPartitionChannel` handles buffering events and backpressure independently.\n   */\n  private _partitionChannels = new Map<string, BatchingPartitionChannel>();\n\n  /**\n   * The options passed by the user when creating the EventHubBufferedProducerClient instance.\n   */\n  private _clientOptions: EventHubBufferedProducerClientOptions;\n\n  /**\n   * The interval at which the background management operation should run.\n   */\n  private _backgroundManagementInterval = 10000; // 10 seconds\n\n  /**\n   * Indicates whether the background management loop is running.\n   */\n  private _isBackgroundManagementRunning = false;\n\n  /**\n   * @readonly\n   * The name of the Event Hub instance for which this client is created.\n   */\n  get eventHubName(): string {\n    return this._producer.eventHubName;\n  }\n\n  /**\n   * @readonly\n   * The fully qualified namespace of the Event Hub instance for which this client is created.\n   * This is likely to be similar to <yournamespace>.servicebus.windows.net.\n   */\n  get fullyQualifiedNamespace(): string {\n    return this._producer.fullyQualifiedNamespace;\n  }\n\n  /**\n   * The `EventHubBufferedProducerClient` class is used to send events to an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param connectionString - The connection string to use for connecting to the Event Hub instance.\n   * It is expected that the shared key properties and the Event Hub path are contained in this connection string.\n   * e.g. 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key;EntityPath=my-event-hub-name'.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(connectionString: string, options: EventHubBufferedProducerClientOptions);\n  /**\n   * The `EventHubBufferedProducerClient` class is used to send events to an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param connectionString - The connection string to use for connecting to the Event Hubs namespace.\n   * It is expected that the shared key properties are contained in this connection string, but not the Event Hub path,\n   * e.g. 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key;'.\n   * @param eventHubName - The name of the specific Event Hub to connect the client to.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(\n    connectionString: string,\n    eventHubName: string,\n    options: EventHubBufferedProducerClientOptions\n  );\n  /**\n   * The `EventHubBufferedProducerClient` class is used to send events to an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param fullyQualifiedNamespace - The full namespace which is likely to be similar to\n   * <yournamespace>.servicebus.windows.net\n   * @param eventHubName - The name of the specific Event Hub to connect the client to.\n   * @param credential - An credential object used by the client to get the token to authenticate the connection\n   * with the Azure Event Hubs service.\n   * See &commat;azure/identity for creating credentials that support AAD auth.\n   * Use the `AzureNamedKeyCredential` from &commat;azure/core-auth if you want to pass in a `SharedAccessKeyName`\n   * and `SharedAccessKey` without using a connection string. These fields map to the `name` and `key` field respectively\n   * in `AzureNamedKeyCredential`.\n   * Use the `AzureSASCredential` from &commat;azure/core-auth if you want to pass in a `SharedAccessSignature`\n   * without using a connection string. This field maps to `signature` in `AzureSASCredential`.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(\n    fullyQualifiedNamespace: string,\n    eventHubName: string,\n    credential: TokenCredential | NamedKeyCredential | SASCredential,\n    options: EventHubBufferedProducerClientOptions\n  );\n  constructor(\n    fullyQualifiedNamespaceOrConnectionString1: string,\n    eventHubNameOrOptions2: string | EventHubBufferedProducerClientOptions,\n    credentialOrOptions3?:\n      | TokenCredential\n      | NamedKeyCredential\n      | SASCredential\n      | EventHubBufferedProducerClientOptions,\n    options4?: EventHubBufferedProducerClientOptions\n  ) {\n    if (typeof eventHubNameOrOptions2 !== \"string\") {\n      this._producer = new EventHubProducerClient(\n        fullyQualifiedNamespaceOrConnectionString1,\n        eventHubNameOrOptions2\n      );\n      this._clientOptions = { ...eventHubNameOrOptions2 };\n    } else if (!isCredential(credentialOrOptions3)) {\n      this._producer = new EventHubProducerClient(\n        fullyQualifiedNamespaceOrConnectionString1,\n        eventHubNameOrOptions2,\n        credentialOrOptions3\n      );\n      this._clientOptions = { ...credentialOrOptions3! };\n    } else {\n      this._producer = new EventHubProducerClient(\n        fullyQualifiedNamespaceOrConnectionString1,\n        eventHubNameOrOptions2,\n        credentialOrOptions3,\n        options4\n      );\n      this._clientOptions = { ...options4! };\n    }\n\n    // setting internal idempotent publishing option on the standard producer.\n    (this._producer as any)._enableIdempotentRetries = this._clientOptions.enableIdempotentRetries;\n  }\n\n  /**\n   * Closes the AMQP connection to the Event Hub instance,\n   * returning a promise that will be resolved when disconnection is completed.\n   *\n   * This will wait for enqueued events to be flushed to the service before closing\n   * the connection.\n   * To close without flushing, set the `flush` option to `false`.\n   *\n   * @param options - The set of options to apply to the operation call.\n   * @returns Promise<void>\n   * @throws Error if the underlying connection encounters an error while closing.\n   */\n  async close(options: BufferedCloseOptions = {}): Promise<void> {\n    logger.verbose(\"closing buffered producer client...\");\n    if (!isDefined(options.flush) || options.flush === true) {\n      await this.flush(options);\n    }\n    // Calling abort signals to the BatchingPartitionChannels that they\n    // should stop reading/sending events, and to the background management\n    // loop that it should stop periodic partition id updates.\n    this._abortController.abort();\n    await this._producer.close();\n    this._isClosed = true;\n  }\n\n  /**\n   * Enqueues an event into the buffer to be published to the Event Hub.\n   * If there is no capacity in the buffer when this method is invoked,\n   * it will wait for space to become available and ensure that the event\n   * has been enqueued.\n   *\n   * When this call returns, the event has been accepted into the buffer,\n   * but it may not have been published yet.\n   * Publishing will take place at a nondeterministic point in the future as the buffer is processed.\n   *\n   * @param events - An {@link EventData} or `AmqpAnnotatedMessage`.\n   * @param options - A set of options that can be specified to influence the way in which\n   * the event is sent to the associated Event Hub.\n   * - `abortSignal`  : A signal used to cancel the enqueueEvent operation.\n   * - `partitionId`  : The partition this set of events will be sent to. If set, `partitionKey` can not be set.\n   * - `partitionKey` : A value that is hashed to produce a partition assignment. If set, `partitionId` can not be set.\n   * @returns The total number of events that are currently buffered and waiting to be published, across all partitions.\n   */\n  async enqueueEvent(\n    event: EventData | AmqpAnnotatedMessage,\n    options: EnqueueEventOptions = {}\n  ): Promise<number> {\n    if (this._isClosed) {\n      throw new Error(\n        `This EventHubBufferedProducerClient has already been closed. Create a new client to enqueue events.`\n      );\n    }\n\n    if (!this._partitionIds.length) {\n      await this._updatePartitionIds();\n    }\n    if (!this._isBackgroundManagementRunning) {\n      this._startPartitionIdsUpdateLoop().catch((e) => {\n        logger.error(\n          `The following error occured during batch creation or sending: ${JSON.stringify(\n            e,\n            undefined,\n            \"  \"\n          )}`\n        );\n      });\n      this._isBackgroundManagementRunning = true;\n    }\n\n    const partitionId = this._partitionAssigner.assignPartition({\n      partitionId: options.partitionId,\n      partitionKey: options.partitionKey,\n    });\n\n    const partitionChannel = this._getPartitionChannel(partitionId);\n    await partitionChannel.enqueueEvent(event);\n    return this._getTotalBufferedEventsCount();\n  }\n\n  /**\n   * Enqueues events into the buffer to be published to the Event Hub.\n   * If there is no capacity in the buffer when this method is invoked,\n   * it will wait for space to become available and ensure that the events\n   * have been enqueued.\n   *\n   * When this call returns, the events have been accepted into the buffer,\n   * but it may not have been published yet.\n   * Publishing will take place at a nondeterministic point in the future as the buffer is processed.\n   *\n   * @param events - An array of {@link EventData} or `AmqpAnnotatedMessage`.\n   * @param options - A set of options that can be specified to influence the way in which\n   * events are sent to the associated Event Hub.\n   * - `abortSignal`  : A signal used to cancel the enqueueEvents operation.\n   * - `partitionId`  : The partition this set of events will be sent to. If set, `partitionKey` can not be set.\n   * - `partitionKey` : A value that is hashed to produce a partition assignment. If set, `partitionId` can not be set.\n   * @returns The total number of events that are currently buffered and waiting to be published, across all partitions.\n   */\n  async enqueueEvents(\n    events: EventData[] | AmqpAnnotatedMessage[],\n    options: EnqueueEventOptions = {}\n  ): Promise<number> {\n    for (const event of events) {\n      await this.enqueueEvent(event, options);\n    }\n\n    return this._getTotalBufferedEventsCount();\n  }\n\n  /**\n   * Attempts to publish all events in the buffer immediately.\n   * This may result in multiple batches being published,\n   * the outcome of each of which will be individually reported by\n   * the `onSendEventsSuccessHandler` and `onSendEventsErrorHandler` handlers.\n   *\n   * @param options - The set of options to apply to the operation call.\n   */\n  async flush(options: BufferedFlushOptions = {}): Promise<void> {\n    await Promise.all(\n      Array.from(this._partitionChannels.values()).map((channel) => channel.flush(options))\n    );\n  }\n\n  /**\n   * Provides the Event Hub runtime information.\n   * @param options - The set of options to apply to the operation call.\n   * @returns A promise that resolves with information about the Event Hub instance.\n   * @throws Error if the underlying connection has been closed, create a new EventHubBufferedProducerClient.\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   */\n  getEventHubProperties(options: GetEventHubPropertiesOptions = {}): Promise<EventHubProperties> {\n    return this._producer.getEventHubProperties(options);\n  }\n\n  /**\n   * Provides the id for each partition associated with the Event Hub.\n   * @param options - The set of options to apply to the operation call.\n   * @returns A promise that resolves with an Array of strings representing the id for\n   * each partition associated with the Event Hub.\n   * @throws Error if the underlying connection has been closed, create a new EventHubBufferedProducerClient.\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   */\n  getPartitionIds(options: GetPartitionIdsOptions = {}): Promise<Array<string>> {\n    return this._producer.getPartitionIds(options);\n  }\n\n  /**\n   * Provides information about the state of the specified partition.\n   * @param partitionId - The id of the partition for which information is required.\n   * @param options - The set of options to apply to the operation call.\n   * @returns A promise that resolves with information about the state of the partition .\n   * @throws Error if the underlying connection has been closed, create a new EventHubBufferedProducerClient.\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   */\n  getPartitionProperties(\n    partitionId: string,\n    options: GetPartitionPropertiesOptions = {}\n  ): Promise<PartitionProperties> {\n    return this._producer.getPartitionProperties(partitionId, options);\n  }\n\n  /**\n   * Gets the `BatchingPartitionChannel` associated with the partitionId.\n   *\n   * If one does not exist, it is created.\n   */\n  private _getPartitionChannel(partitionId: string): BatchingPartitionChannel {\n    const partitionChannel =\n      this._partitionChannels.get(partitionId) ??\n      new BatchingPartitionChannel({\n        loopAbortSignal: this._abortController.signal,\n        maxBufferSize: this._clientOptions.maxEventBufferLengthPerPartition || 1500,\n        maxWaitTimeInMs: this._clientOptions.maxWaitTimeInMs || 1000,\n        onSendEventsErrorHandler: this._clientOptions.onSendEventsErrorHandler,\n        onSendEventsSuccessHandler: this._clientOptions.onSendEventsSuccessHandler,\n        partitionId,\n        producer: this._producer,\n      });\n    this._partitionChannels.set(partitionId, partitionChannel);\n    return partitionChannel;\n  }\n\n  /**\n   * Returns the total number of buffered events across all partitions.\n   */\n  private _getTotalBufferedEventsCount(): number {\n    let total = 0;\n    for (const [_, channel] of this._partitionChannels) {\n      total += channel.getCurrentBufferedCount();\n    }\n\n    return total;\n  }\n\n  private async _updatePartitionIds(): Promise<void> {\n    logger.verbose(\"Checking for partition Id updates...\");\n    const queriedPartitionIds = await this.getPartitionIds();\n\n    if (this._partitionIds.length !== queriedPartitionIds.length) {\n      logger.verbose(\"Applying partition Id updates\");\n      this._partitionIds = queriedPartitionIds;\n      this._partitionAssigner.setPartitionIds(this._partitionIds);\n    }\n  }\n\n  private async _startPartitionIdsUpdateLoop(): Promise<void> {\n    logger.verbose(\"Starting a background loop to check and apply partition id updates...\");\n    while (!this._abortController.signal.aborted && !this._isClosed) {\n      await delay<void>(this._backgroundManagementInterval);\n      if (!this._isClosed) {\n        await this._updatePartitionIds();\n      }\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { EventData } from \"./eventData\";\n\n/**\n * A message with payload and content type fields\n *\n * This interface is hidden because it is already exported by `@azure/schema-registry-avro`\n *\n * @hidden\n */\nexport interface MessageContent {\n  /**\n   * The message's binary data\n   */\n  data: Uint8Array;\n  /**\n   * The message's content type\n   */\n  contentType: string;\n}\n\n/**\n * A message adapter interface that specifies methods for producing and consuming\n * messages with payloads and content type fields.\n *\n * This interface is hidden because it is already exported by `@azure/schema-registry-avro`\n *\n * @hidden\n */\nexport interface MessageAdapter<MessageT> {\n  /**\n   * defines how to create a message from a payload and a content type\n   */\n  produce: (MessageContent: MessageContent) => MessageT;\n  /**\n   * defines how to access the payload and the content type of a message\n   */\n  consume: (message: MessageT) => MessageContent;\n}\n\n// This type should always be equivalent to Omit<Omit<EventData, \"body\">, \"contentType\">\n/**\n * Parameters to the `createEventDataAdapter` function that creates an event data adapter.\n */\nexport interface EventDataAdapterParameters {\n  /**\n   * The correlation identifier that allows an\n   * application to specify a context for the message for the purposes of correlation, for example\n   * reflecting the MessageId of a message that is being replied to.\n   */\n  correlationId?: string | number | Buffer;\n\n  /**\n   * The message identifier is an\n   * application-defined value that uniquely identifies the message and its payload.\n   *\n   * Note: Numbers that are not whole integers are not allowed.\n   */\n  messageId?: string | number | Buffer;\n\n  /**\n   * Set of key value pairs that can be used to set properties specific to user application.\n   */\n  properties?: {\n    [key: string]: any;\n  };\n}\n\n/**\n * A function that constructs an event data adapter. That adapter can be used\n * with `@azure/schema-registry-avro` to encode and decode body in event data.\n *\n * @param params - parameters to create the event data\n * @returns An event data adapter that can produce and consume event data\n */\nexport function createEventDataAdapter(\n  params: EventDataAdapterParameters = {}\n): MessageAdapter<EventData> {\n  return {\n    produce: ({ data: body, contentType }: MessageContent) => {\n      return {\n        ...params,\n        body,\n        contentType,\n      };\n    },\n    consume: (message: EventData): MessageContent => {\n      const { body, contentType } = message;\n      if (body === undefined) {\n        throw new Error(\"Expected the body field to be defined\");\n      }\n      if (contentType === undefined) {\n        throw new Error(\"Expected the contentType field to be defined\");\n      }\n      return {\n        /**\n         * If the raw response was parsed as JSON, we need to convert it to a Uint8Array,\n         * otherwise, leave the payload as is.\n         */\n        data: typeof body === \"object\" ? Uint8Array.from(Object.values(body)) : body,\n        contentType,\n      };\n    },\n  };\n}\n"],"names":["createClientLogger","isObjectWithProperties","isDefined","Constants","translate","ErrorNameConditionMapper","objectHasProperty","CloseReason","message","isBuffer","Buffer","AmqpAnnotatedMessage","types","randomUUID","defaultCancellableLock","TokenType","isSasTokenProvider","logger","azureLogger","AbortError","StandardAbortMessage","retry","RetryOperationType","createAbortablePromise","AbortController","createTracingClient","delay","parseConnectionString","isMessagingError","isAmqpError","RequestResponseLink","SenderEvents","ReceiverEvents","ConnectionConfig","os","isTokenCredential","isNamedKeyCredential","isSASCredential","ConnectionContextBase","ConnectionEvents","createSasTokenProvider"],"mappings":"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"}
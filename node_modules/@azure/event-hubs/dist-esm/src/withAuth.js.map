{"version":3,"file":"withAuth.js","sourceRoot":"","sources":["../../src/withAuth.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  Constants,\n  TokenType,\n  defaultCancellableLock,\n  isSasTokenProvider,\n  SasTokenProvider,\n  CbsClient,\n  CbsResponse,\n} from \"@azure/core-amqp\";\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { AccessToken, TokenCredential } from \"@azure/core-auth\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { createTimerLoop, TimerLoop } from \"./util/timerLoop\";\nimport { SimpleLogger, logObj } from \"./logger\";\n\n/**\n *\n * @param callback - The callback to be executed after the token is obtained.\n * @param context - The connection context.\n * @param audience - The audience for which the token is needed.\n * @param timeoutInMs - The timeout in milliseconds.\n * @param logger - The logger to be used for logging.\n * @returns  A TimerLoop that keeps the token refreshed.\n * @internal\n */\nexport async function withAuth(\n  callback: () => Promise<void>,\n  context: ConnectionContext,\n  audience: string,\n  timeoutInMs: number,\n  logger: SimpleLogger,\n  options: {\n    abortSignal?: AbortSignalLike;\n  }\n): Promise<TimerLoop> {\n  const info = await getTokenInfo(context.tokenCredential, audience);\n  await setupClaimNegotiation(context, audience, info, timeoutInMs, logger, options);\n  await callback();\n  async function createTask() {\n    try {\n      await setupClaimNegotiation(context, audience, info, timeoutInMs, logger, options);\n      logger.verbose(\n        `next token renewal is in ${info.timeoutInMs} milliseconds @(${new Date(\n          Date.now() + info.timeoutInMs\n        ).toString()}).`\n      );\n    } catch (err) {\n      logger.verbose(`an error occurred while renewing the token: ${logObj(err)}`);\n    }\n  }\n  const loop = createTimerLoop(info.timeoutInMs, createTask);\n  loop.start();\n  return loop;\n}\n\n/**\n * @internal\n */\nexport async function openCbsSession(\n  client: CbsClient,\n  timeoutAfterStartTime: number,\n  { abortSignal }: { abortSignal?: AbortSignalLike } = {}\n): Promise<void> {\n  return defaultCancellableLock.acquire(\n    client.cbsLock,\n    () =>\n      client.init({\n        abortSignal,\n        timeoutInMs: timeoutAfterStartTime - Date.now(),\n      }),\n    {\n      abortSignal,\n      timeoutInMs: timeoutAfterStartTime - Date.now(),\n    }\n  );\n}\n\n/**\n * A representation of an access token.\n * @internal\n */\ninterface TokenInfo {\n  /** The access token */\n  token: AccessToken;\n  /** The type of the token */\n  type: TokenType;\n  /** The time duration after which the token should be refreshed */\n  timeoutInMs: number;\n}\n\nasync function getAadToken(cred: TokenCredential): Promise<TokenInfo> {\n  const token = await cred.getToken(Constants.aadEventHubsScope);\n  if (!token) {\n    throw new Error(`Failed to get token from the provided \"TokenCredential\" object`);\n  }\n  return {\n    token,\n    type: TokenType.CbsTokenTypeJwt,\n    timeoutInMs: token.expiresOnTimestamp - Date.now() - 2 * 60 * 1000,\n  };\n}\n\nfunction getSharedKeyBasedToken(cred: SasTokenProvider, audience: string): TokenInfo {\n  return {\n    token: cred.getToken(audience),\n    type: TokenType.CbsTokenTypeSas,\n    timeoutInMs: 45 * 60 * 1000,\n  };\n}\n\nasync function getTokenInfo(\n  cred: SasTokenProvider | TokenCredential,\n  audience: string\n): Promise<TokenInfo> {\n  return isSasTokenProvider(cred) ? getSharedKeyBasedToken(cred, audience) : getAadToken(cred);\n}\n\nfunction negotiateClaim(\n  { token, type }: TokenInfo,\n  audience: string,\n  cbsSession: CbsClient,\n  timeoutAfterStartTime: number,\n  lock: string,\n  abortSignal?: AbortSignalLike\n): Promise<CbsResponse> {\n  return defaultCancellableLock.acquire(\n    lock,\n    () =>\n      cbsSession.negotiateClaim(audience, token.token, type, {\n        abortSignal,\n        timeoutInMs: timeoutAfterStartTime - Date.now(),\n      }),\n    {\n      abortSignal,\n      timeoutInMs: timeoutAfterStartTime - Date.now(),\n    }\n  );\n}\n\nasync function setupClaimNegotiation(\n  context: ConnectionContext,\n  audience: string,\n  info: TokenInfo,\n  timeoutInMs: number,\n  logger: SimpleLogger,\n  {\n    abortSignal,\n  }: {\n    abortSignal?: AbortSignalLike;\n  }\n): Promise<void> {\n  const startTime = Date.now();\n  logger.verbose(\n    `acquiring cbs lock: '${context.cbsSession.cbsLock}' for creating the cbs session`\n  );\n\n  await openCbsSession(context.cbsSession, timeoutInMs + startTime, { abortSignal });\n  logger.verbose(`acquiring cbs lock: '${context.negotiateClaimLock}' for cbs auth`);\n  await negotiateClaim(\n    info,\n    audience,\n    context.cbsSession,\n    timeoutInMs + startTime,\n    context.negotiateClaimLock,\n    abortSignal\n  );\n  logger.verbose(\"claim negotiation succeeded\");\n}\n"]}
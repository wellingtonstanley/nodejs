{"version":3,"file":"partitionReceiver.js","sourceRoot":"","sources":["../../src/partitionReceiver.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;AAElC,OAAO,EAAE,eAAe,EAAE,UAAU,EAAmB,MAAM,yBAAyB,CAAC;AACvF,OAAO,EACL,SAAS,EAET,kBAAkB,EAClB,oBAAoB,EACpB,KAAK,EACL,SAAS,GAEV,MAAM,kBAAkB,CAAC;AAC1B,OAAO,EAKL,KAAK,GACN,MAAM,cAAc,CAAC;AACtB,OAAO,EAAwC,eAAe,EAAE,MAAM,aAAa,CAAC;AACpF,OAAO,EAAiB,sBAAsB,EAAE,MAAM,iBAAiB,CAAC;AACxE,OAAO,EACL,eAAe,EACf,kBAAkB,EAClB,kBAAkB,EAClB,MAAM,EACN,MAAM,IAAI,WAAW,GAEtB,MAAM,UAAU,CAAC;AAGlB,OAAO,EAAE,0BAA0B,EAAE,MAAM,gBAAgB,CAAC;AAC5D,OAAO,EAAE,sBAAsB,EAAE,MAAM,kBAAkB,CAAC;AAE1D,OAAO,EAAE,aAAa,EAAE,MAAM,cAAc,CAAC;AAC7C,OAAO,EAAE,QAAQ,EAAE,MAAM,YAAY,CAAC;AAQtC,MAAM,eAAe,GAAG,0CAA0C,CAAC;AACnE,sEAAsE;AACtE,MAAM,iBAAiB,GAAG,EAAE,CAAC;AAyD7B,gBAAgB;AAChB,MAAM,UAAU,cAAc,CAC5B,GAAsB,EACtB,aAAqB,EACrB,WAAmB,EACnB,aAA4B,EAC5B,UAAmC,EAAE;IAErC,MAAM,OAAO,GAAG,GAAG,CAAC,MAAM,CAAC,kBAAkB,CAAC,WAAW,EAAE,aAAa,CAAC,CAAC;IAC1E,MAAM,IAAI,GAAG,aAAa,CAAC,OAAO,CAAC,CAAC;IACpC,MAAM,QAAQ,GAAG,GAAG,CAAC,MAAM,CAAC,mBAAmB,CAAC,WAAW,EAAE,aAAa,CAAC,CAAC;IAC5E,MAAM,SAAS,GAAG,eAAe,CAAC,GAAG,CAAC,YAAY,EAAE,UAAU,EAAE,IAAI,CAAC,CAAC;IACtE,MAAM,MAAM,GAAG,kBAAkB,CAAC,WAAW,EAAE,SAAS,CAAC,CAAC;IAC1D,MAAM,KAAK,GAAwB,EAAE,CAAC;IACtC,MAAM,KAAK,GAAkB;QAC3B,YAAY,EAAE,KAAK;KACpB,CAAC;IAEF,MAAM,GAAG,GAAqB;QAC5B,QAAQ,EAAE,SAAS;QACnB,UAAU,EAAE,CAAC,CAAC;QACd,2BAA2B,EAAE,EAAE;QAC/B,QAAQ,EAAE,KAAK;QACf,KAAK,EAAE,KAAK,IAAI,EAAE;;YAChB,aAAa,CAAC,GAAG,CAAC,CAAC;YACnB,OAAO,GAAG,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;YAC3B,MAAM,CAAC,OAAO,CAAC,4CAA4C,CAAC,CAAC;YAC7D,MAAA,KAAK,CAAC,QAAQ,0CAAE,IAAI,EAAE,CAAC;YACvB,OAAO,MAAA,KAAK,CAAC,IAAI,0CACb,KAAK,GACN,KAAK,CAAC,CAAC,GAAG,EAAE,EAAE;gBACb,MAAM,CAAC,OAAO,CAAC,oCAAoC,GAAG,aAAH,GAAG,uBAAH,GAAG,CAAE,IAAI,KAAK,GAAG,aAAH,GAAG,uBAAH,GAAG,CAAE,OAAO,EAAE,CAAC,CAAC;gBACjF,kBAAkB,CAAC,GAAG,CAAC,CAAC;gBACxB,MAAM,GAAG,CAAC;YACZ,CAAC,EACA,OAAO,CAAC,GAAG,EAAE;gBACZ,GAAG,CAAC,QAAQ,GAAG,IAAI,CAAC;gBACpB,MAAM,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;gBAC5B,KAAK,CAAC,IAAI,GAAG,SAAS,CAAC;gBACvB,KAAK,CAAC,QAAQ,GAAG,SAAS,CAAC;YAC7B,CAAC,CAAC,CAAC;QACP,CAAC;QACD,KAAK,EAAE,GAAG,EAAE;;YACV,MAAA,GAAG,CAAC,QAAQ,oDAAG,IAAI,UAAU,CAAC,oBAAoB,CAAC,CAAC,CAAC;YACrD,MAAM,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;YAC7B,OAAO,GAAG,CAAC,KAAK,EAAE,CAAC;QACrB,CAAC;QACD,MAAM,EAAE,GAAG,EAAE;;YACX,MAAM,MAAM,GAAG,CAAC,CAAC,CAAA,MAAA,KAAK,CAAC,IAAI,0CAAE,MAAM,EAAE,CAAA,CAAC;YACtC,MAAM,CAAC,OAAO,CAAC,eAAe,MAAM,EAAE,CAAC,CAAC;YACxC,OAAO,MAAM,CAAC;QAChB,CAAC;QACD,KAAK,CAAC,OAAO,CAAC,EAAE,WAAW,EAAE,WAAW,EAAkB;YACxD,IAAI,KAAK,CAAC,YAAY,IAAI,GAAG,CAAC,MAAM,EAAE,EAAE;gBACtC,OAAO;aACR;YACD,KAAK,CAAC,YAAY,GAAG,IAAI,CAAC;YAC1B,MAAM,CAAC,OAAO,CAAC,sBAAsB,CAAC,CAAC;YACvC,IAAI;gBACF,MAAM,GAAG,CAAC,eAAe,CAAC,EAAE,WAAW,EAAE,CAAC,CAAC;gBAC3C,KAAK,CAAC,QAAQ,GAAG,MAAM,QAAQ,CAC7B,GAAG,EAAE,CACH,SAAS,CACP,GAAG,EACH,IAAI,EACJ,OAAO,EACP,GAAG,EACH,KAAK,EACL,KAAK,EACL,aAAa,EACb,MAAM,EACN,OAAO,EACP,WAAW,CACZ,EACH,GAAG,EACH,QAAQ,EACR,WAAW,EACX,MAAM,EACN;oBACE,WAAW;iBACZ,CACF,CAAC;aACH;YAAC,OAAO,GAAG,EAAE;gBACZ,KAAK,CAAC,YAAY,GAAG,KAAK,CAAC;gBAC3B,MAAM,KAAK,GAAG,SAAS,CAAC,GAAG,CAAC,CAAC;gBAC7B,MAAM,CAAC,KAAK,CACV,kDAAkD,KAAK,aAAL,KAAK,uBAAL,KAAK,CAAE,IAAI,KAAK,KAAK,aAAL,KAAK,uBAAL,KAAK,CAAE,OAAO,EAAE,CACnF,CAAC;gBACF,kBAAkB,CAAC,GAAG,CAAC,CAAC;gBACxB,MAAM,KAAK,CAAC;aACb;QACH,CAAC;QACD,YAAY,EAAE,CACZ,eAAuB,EACvB,uBAA+B,EAAE,EACjC,WAA6B,EAC7B,EAAE;;YACF,MAAM,kBAAkB,GAAG,GAAkB,EAAE;gBAC7C,MAAM,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;gBAC7B,OAAO,GAAG,CAAC,KAAK,EAAE,CAAC;YACrB,CAAC,CAAC;YACF,MAAM,cAAc,GAAG,GAAiC,EAAE;gBACxD,MAAM,qBAAqB,GAAG,IAAI,CAAC,GAAG,CAAC,eAAe,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;gBAC1E,MAAM,CAAC,OAAO,CACZ,eAAe,KAAK,CAAC,MAAM,gCAAgC,qBAAqB,cAAc,CAC/F,CAAC;gBACF,IAAI,WAAW,aAAX,WAAW,uBAAX,WAAW,CAAE,OAAO,EAAE;oBACxB,kBAAkB,EAAE,CAAC;oBACrB,OAAO,OAAO,CAAC,MAAM,CAAC,IAAI,UAAU,CAAC,oBAAoB,CAAC,CAAC,CAAC;iBAC7D;gBACD,OAAO,GAAG,CAAC,QAAQ,IAAI,GAAG,CAAC,wBAAwB;oBACjD,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;oBAClC,CAAC,CAAC,qBAAqB,KAAK,CAAC;wBAC7B,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,EAAE,eAAe,CAAC,CAAC;wBACnD,CAAC,CAAC,IAAI,OAAO,CAAO,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;4BACpC,GAAG,CAAC,QAAQ,GAAG,MAAM,CAAC;4BACtB,GAAG,CAAC,8CAA8C;iCAC/C,OAAO,CAAC;gCACP,WAAW;gCACX,WAAW,EAAE,0BAA0B,CAAC,OAAO,CAAC,YAAY,CAAC;6BAC9D,CAAC;iCACD,IAAI,CAAC,GAAG,EAAE;gCACT,IAAI,UAAU,CAAC,KAAK,CAAC,IAAI,EAAE,qBAAqB,CAAC,GAAG,CAAC,EAAE;oCACrD,OAAO,MAAM,CAAC,OAAO,CACnB,8BAA8B,oBAAoB,UAAU,CAC7D,CAAC;iCACH;;oCAAM,OAAO;4BAChB,CAAC,CAAC;iCACD,IAAI,CAAC,GAAG,EAAE,CACT,aAAa,CACX,eAAe,EACf,oBAAoB,GAAG,IAAI,EAC3B,iBAAiB,EACjB,KAAK,EACL;gCACE,WAAW;gCACX,kBAAkB;gCAClB,iBAAiB,EAAE,GAAG,EAAE,CACtB,MAAM,CAAC,IAAI,CACT,GAAG,IAAI,CAAC,GAAG,CACT,eAAe,EACf,KAAK,CAAC,MAAM,CACb,6BAA6B,oBAAoB,UAAU,CAC7D;gCACH,eAAe,EAAE,GAAG,EAAE,CACpB,MAAM,CAAC,IAAI,CAAC,GAAG,eAAe,4BAA4B,CAAC;gCAC7D,YAAY,EAAE,GAAG,EAAE,CACjB,MAAM,CAAC,IAAI,CACT,sDAAsD,oBAAoB,UAAU,CACrF;6BACJ,CACF,CACF;iCACA,KAAK,CAAC,MAAM,CAAC;iCACb,IAAI,CAAC,OAAO,CAAC,CAAC;wBACnB,CAAC,CAAC;6BACC,IAAI,CAAC,GAAG,EAAE,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,EAAE,eAAe,CAAC,CAAC;6BAC5C,OAAO,CAAC,GAAG,EAAE,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,CAAC;YAC3C,CAAC,CAAC;YACF,OAAO,KAAK,CACV,MAAM,CAAC,gBAAgB,CACrB;gBACE,SAAS,EAAE,cAAc;gBACzB,aAAa,EAAE,kBAAkB,CAAC,cAAc;gBAChD,WAAW,EAAE,WAAW;gBACxB,YAAY,EAAE,MAAA,OAAO,CAAC,YAAY,mCAAI,EAAE;aACzC,EACD;gBACE,YAAY,EAAE;oBACZ,UAAU,EAAE,IAAI;oBAChB,GAAG,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC,YAAY;iBAC5B;gBACD,cAAc,EAAE;oBACd,UAAU,EAAE,IAAI;oBAChB,GAAG,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI;iBAC3B;aACF,CACkC,CACtC,CAAC;QACJ,CAAC;KACF,CAAC;IACF,OAAO,GAAG,CAAC;AACb,CAAC;AAED,SAAS,KAAK,CACZ,YAAoB,EACpB,OAIC;IAED,IAAI,KAAoC,CAAC;IACzC,OAAO,sBAAsB,CAAO,CAAC,OAAO,EAAE,EAAE;QAC9C,KAAK,GAAG,UAAU,CAAC,OAAO,EAAE,YAAY,CAAC,CAAC;IAC5C,CAAC,EAAE,OAAO,CAAC,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,CAAC;AACjD,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,eAAe,CAC7B,YAAoB,EACpB,KAAoB,EACpB,OAIC;IAED,IAAI,KAAqC,CAAC;IAC1C,OAAO,sBAAsB,CAAO,CAAC,OAAO,EAAE,EAAE;QAC9C,KAAK,GAAG,WAAW,CAAC,GAAG,EAAE;YACvB,IAAI,KAAK,EAAE,EAAE;gBACX,OAAO,EAAE,CAAC;aACX;QACH,CAAC,EAAE,YAAY,CAAC,CAAC;IACnB,CAAC,EAAE,OAAO,CAAC,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC,CAAC;AAClD,CAAC;AAED;;;;;;;;;GASG;AACH,MAAM,UAAU,aAAa,CAC3B,aAAqB,EACrB,eAAuB,EACvB,wBAAgC,EAChC,KAAgB,EAChB,UAMI,EAAE;IAEN,MAAM,EACJ,WAAW,EAAE,iBAAiB,EAC9B,kBAAkB,EAClB,YAAY,EACZ,iBAAiB,EACjB,eAAe,GAChB,GAAG,OAAO,CAAC;IAEZ,IAAI,KAAK,CAAC,MAAM,IAAI,aAAa,EAAE;QACjC,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;KAChD;IAED,MAAM,OAAO,GAAG,IAAI,eAAe,EAAE,CAAC;IACtC,MAAM,aAAa,GAAG,GAAG,EAAE;QACzB,OAAO,CAAC,KAAK,EAAE,CAAC;IAClB,CAAC,CAAC;IACF,iBAAiB,aAAjB,iBAAiB,uBAAjB,iBAAiB,CAAE,gBAAgB,CAAC,OAAO,EAAE,aAAa,CAAC,CAAC;IAE5D,MAAM,cAAc,GAAG;QACrB,WAAW,EAAE,OAAO,CAAC,MAAM;QAC3B,aAAa,EAAE,oBAAoB;QACnC,kBAAkB,EAAE,GAAG,EAAE;YACvB,IAAI,iBAAiB,aAAjB,iBAAiB,uBAAjB,iBAAiB,CAAE,OAAO,EAAE;gBAC9B,kBAAkB,aAAlB,kBAAkB,uBAAlB,kBAAkB,EAAI,CAAC;aACxB;QACH,CAAC;KACF,CAAC;IACF,OAAO,OAAO,CAAC,IAAI,CAAC;QAClB,eAAe,CAAC,wBAAwB,EAAE,GAAG,EAAE,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,cAAc,CAAC;aAC9E,IAAI,CAAC,GAAG,EAAE,CAAC,KAAK,CAAC,wBAAwB,EAAE,cAAc,CAAC,CAAC;aAC3D,IAAI,CAAC,iBAAiB,CAAC;QAC1B,KAAK,CAAC,eAAe,EAAE,cAAc,CAAC,CAAC,IAAI,CAAC,YAAY,CAAC;KAC1D,CAAC,CAAC,OAAO,CAAC,GAAG,EAAE;QACd,OAAO,CAAC,KAAK,EAAE,CAAC;QAChB,iBAAiB,aAAjB,iBAAiB,uBAAjB,iBAAiB,CAAE,mBAAmB,CAAC,OAAO,EAAE,aAAa,CAAC,CAAC;IACjE,CAAC,CAAC,CAAC;AACL,CAAC;AAED,SAAS,iBAAiB,CAAC,IAAuB;IAChD,MAAM,UAAU,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAC;IAC5C,MAAM,iBAAiB,GAAsB;QAC3C,IAAI,EAAE,IAAI,CAAC,IAAI;QACf,UAAU,EAAE,IAAI,CAAC,UAAU;QAC3B,MAAM,EAAE,IAAI,CAAC,MAAO;QACpB,cAAc,EAAE,IAAI,CAAC,cAAe;QACpC,eAAe,EAAE,IAAI,CAAC,eAAgB;QACtC,YAAY,EAAE,IAAI,CAAC,YAAa;QAChC,gBAAgB,EAAE,IAAI,CAAC,gBAAgB;QACvC,iBAAiB;YACf,OAAO,UAAU,CAAC;QACpB,CAAC;KACF,CAAC;IACF,IAAI,IAAI,CAAC,aAAa,IAAI,IAAI,EAAE;QAC9B,iBAAiB,CAAC,aAAa,GAAG,IAAI,CAAC,aAAa,CAAC;KACtD;IACD,IAAI,IAAI,CAAC,WAAW,IAAI,IAAI,EAAE;QAC5B,iBAAiB,CAAC,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC;KAClD;IACD,IAAI,IAAI,CAAC,SAAS,IAAI,IAAI,EAAE;QAC1B,iBAAiB,CAAC,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC;KAC9C;IACD,OAAO,iBAAiB,CAAC;AAC3B,CAAC;AAED,SAAS,aAAa,CAAC,UAAuC,EAAE,IAAuB;IACrF,UAAU,CAAC,cAAc,GAAG,IAAI,CAAC,kBAAkB,CAAC;IACpD,UAAU,CAAC,UAAU,GAAG,IAAI,CAAC,gBAAgB,CAAC;IAC9C,UAAU,CAAC,MAAM,GAAG,IAAI,CAAC,kBAAkB,CAAC;IAC5C,UAAU,CAAC,WAAW,GAAG,IAAI,CAAC,aAAa,CAAC;AAC9C,CAAC;AAED,SAAS,UAAU,CAAC,QAA0B,EAAE,qBAA6B;;IAC3E,MAAM,YAAY,GAAG,qBAAqB,GAAG,CAAC,MAAA,QAAQ,aAAR,QAAQ,uBAAR,QAAQ,CAAE,MAAM,mCAAI,CAAC,CAAC,CAAC;IACrE,IAAI,YAAY,GAAG,CAAC,EAAE;QACpB,QAAQ,aAAR,QAAQ,uBAAR,QAAQ,CAAE,SAAS,CAAC,YAAY,CAAC,CAAC;KACnC;IACD,OAAO,YAAY,CAAC;AACtB,CAAC;AAED,SAAS,aAAa,CAAC,GAAqB;IAC1C,GAAG,CAAC,QAAQ,GAAG,SAAS,CAAC;AAC3B,CAAC;AAED,SAAS,SAAS,CAChB,OAAqB,EACrB,GAAqB,EACrB,KAA0B,EAC1B,OAAgC;IAEhC,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE;QACpB,OAAO;KACR;IACD,MAAM,IAAI,GAAG,eAAe,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC,CAAC,OAAO,CAAC,qBAAqB,CAAC,CAAC;IAC/E,MAAM,iBAAiB,GAAG,iBAAiB,CAAC,IAAI,CAAC,CAAC;IAClD,GAAG,CAAC,UAAU,GAAG,iBAAiB,CAAC,cAAc,CAAC;IAClD,IAAI,OAAO,CAAC,gCAAgC,EAAE;QAC5C,aAAa,CAAC,GAAG,CAAC,2BAA2B,EAAE,IAAI,CAAC,CAAC;KACtD;IACD,KAAK,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;AAChC,CAAC;AAED,SAAS,OAAO,CACd,OAAqB,EACrB,GAAsB,EACtB,QAA0B,EAC1B,MAAoB;IAEpB,MAAM,YAAY,GAAG,QAAQ,IAAI,OAAO,CAAC,QAAQ,CAAC;IAClD,MAAM,SAAS,GAAG,YAAY,aAAZ,YAAY,uBAAZ,YAAY,CAAE,KAAK,CAAC;IACtC,MAAM,CAAC,OAAO,CAAC,oCAAoC,MAAM,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC;IACxE,IAAI,GAAG,CAAC,QAAQ,IAAI,SAAS,EAAE;QAC7B,MAAM,KAAK,GAAG,SAAS,CAAC,SAAS,CAAC,CAAC;QACnC,kBAAkB,CAAC,KAAK,CAAC,CAAC;QAC1B,GAAG,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;KACrB;AACH,CAAC;AAED,SAAS,cAAc,CAAC,OAAqB,EAAE,GAAsB,EAAE,MAAoB;;IACzF,MAAM,YAAY,GAAG,MAAA,OAAO,CAAC,OAAO,0CAAE,KAAK,CAAC;IAC5C,MAAM,CAAC,OAAO,CAAC,mCAAmC,MAAM,CAAC,YAAY,CAAC,EAAE,CAAC,CAAC;IAC1E,IAAI,GAAG,CAAC,QAAQ,IAAI,YAAY,EAAE;QAChC,MAAM,KAAK,GAAG,SAAS,CAAC,YAAY,CAAC,CAAC;QACtC,kBAAkB,CAAC,KAAK,CAAC,CAAC;QAC1B,GAAG,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;KACrB;AACH,CAAC;AAED,KAAK,UAAU,OAAO,CACpB,OAAqB,EACrB,KAAoB,EACpB,MAAoB;IAEpB,MAAM,YAAY,GAAG,KAAK,CAAC,IAAI,IAAI,OAAO,CAAC,QAAQ,CAAC;IACpD,MAAM,CAAC,OAAO,CACZ,kFAAkF,YAAY,aAAZ,YAAY,uBAAZ,YAAY,CAC1F,cAAc,GACf,QAAQ,EAAE,gDAAgD,KAAK,CAAC,YAAY,GAAG,CACnF,CAAC;IACF,IAAI,YAAY,IAAI,CAAC,KAAK,CAAC,YAAY,EAAE;QACvC,OAAO,YAAY,CAAC,KAAK,EAAE,CAAC,KAAK,CAAC,CAAC,GAAG,EAAE,EAAE;YACxC,MAAM,CAAC,OAAO,CAAC,oDAAoD,MAAM,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;QACpF,CAAC,CAAC,CAAC;KACJ;AACH,CAAC;AAED,KAAK,UAAU,cAAc,CAC3B,OAAqB,EACrB,KAAoB,EACpB,MAAoB;IAEpB,MAAM,YAAY,GAAG,KAAK,CAAC,IAAI,IAAI,OAAO,CAAC,QAAQ,CAAC;IACpD,MAAM,CAAC,OAAO,CACZ,uFAAuF,YAAY,aAAZ,YAAY,uBAAZ,YAAY,CAC/F,qBAAqB,GACtB,QAAQ,EAAE,gDAAgD,KAAK,CAAC,YAAY,GAAG,CACnF,CAAC;IACF,IAAI,YAAY,IAAI,CAAC,KAAK,CAAC,YAAY,EAAE;QACvC,OAAO,YAAY,CAAC,KAAK,EAAE,CAAC,KAAK,CAAC,CAAC,GAAG,EAAE,EAAE;YACxC,MAAM,CAAC,OAAO,CAAC,mDAAmD,MAAM,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;QACnF,CAAC,CAAC,CAAC;KACJ;AACH,CAAC;AAED,SAAS,iBAAiB,CACxB,IAAY,EACZ,OAAe,EACf,GAAsB,EACtB,KAAoB,EACpB,KAA0B,EAC1B,aAA4B,EAC5B,MAAoB,EACpB,OAAgC;IAEhC,MAAM,WAAW,GAA6C;QAC5D,IAAI;QACJ,UAAU,EAAE,IAAI;QAChB,MAAM,EAAE;YACN,OAAO;SACR;QACD,aAAa,EAAE,CAAC;QAChB,OAAO,EAAE,CAAC,OAAO,EAAE,EAAE,CAAC,OAAO,CAAC,OAAO,EAAE,KAAK,EAAE,MAAM,CAAC;QACrD,cAAc,EAAE,CAAC,OAAO,EAAE,EAAE,CAAC,cAAc,CAAC,OAAO,EAAE,KAAK,EAAE,MAAM,CAAC;QACnE,OAAO,EAAE,CAAC,OAAO,EAAE,EAAE,CAAC,OAAO,CAAC,OAAO,EAAE,GAAG,EAAE,KAAK,CAAC,IAAI,EAAE,MAAM,CAAC;QAC/D,SAAS,EAAE,CAAC,OAAO,EAAE,EAAE,CAAC,SAAS,CAAC,OAAO,EAAE,GAAG,EAAE,KAAK,EAAE,OAAO,CAAC;QAC/D,cAAc,EAAE,CAAC,OAAO,EAAE,EAAE,CAAC,cAAc,CAAC,OAAO,EAAE,GAAG,EAAE,MAAM,CAAC;KAClE,CAAC;IACF,MAAM,UAAU,GAAG,OAAO,CAAC,UAAU,CAAC;IACtC,IAAI,OAAO,UAAU,KAAK,QAAQ,EAAE;QAClC,WAAW,CAAC,UAAU,GAAG;YACvB,CAAC,SAAS,CAAC,WAAW,CAAC,EAAE,KAAK,CAAC,SAAS,CAAC,UAAU,CAAC;SACrD,CAAC;KACH;IACD,IAAI,OAAO,CAAC,gCAAgC,EAAE;QAC5C,WAAW,CAAC,oBAAoB,GAAG,SAAS,CAAC,+BAA+B,CAAC;KAC9E;IACD,MAAM,YAAY,GAAG,sBAAsB,CACzC,GAAG,CAAC,UAAU,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,cAAc,EAAE,GAAG,CAAC,UAAU,EAAE,CAAC,CAAC,CAAC,aAAa,CACzE,CAAC;IACF,WAAW,CAAC,MAAM,CAAC,MAAM,GAAG;QAC1B,mCAAmC,EAAE,KAAK,CAAC,cAAc,CAAC,YAAY,EAAE,cAAc,CAAC;KACxF,CAAC;IACF,OAAO,WAAW,CAAC;AACrB,CAAC;AAED,KAAK,UAAU,SAAS,CACtB,GAAsB,EACtB,IAAY,EACZ,OAAe,EACf,GAAsB,EACtB,KAAoB,EACpB,KAA0B,EAC1B,aAA4B,EAC5B,MAAoB,EACpB,OAAgC,EAChC,WAA6B;IAE7B,MAAM,WAAW,GAAG,iBAAiB,CACnC,IAAI,EACJ,OAAO,EACP,GAAG,EACH,KAAK,EACL,KAAK,EACL,aAAa,EACb,MAAM,EACN,OAAO,CACR,CAAC;IACF,MAAM,CAAC,OAAO,CAAC,qCAAqC,MAAM,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC;IAC3E,KAAK,CAAC,IAAI,GAAG,MAAM,GAAG,CAAC,UAAU,CAAC,cAAc,iCAC3C,WAAW,KACd,WAAW,IACX,CAAC;IACH,KAAK,CAAC,YAAY,GAAG,KAAK,CAAC;IAC3B,MAAM,CAAC,OAAO,CAAC,yBAAyB,CAAC,CAAC;IAC1C,GAAG,CAAC,SAAS,CAAC,IAAI,CAAC,GAAG,GAAG,CAAC;AAC5B,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortController, AbortError, AbortSignalLike } from \"@azure/abort-controller\";\nimport {\n  Constants,\n  MessagingError,\n  RetryOperationType,\n  StandardAbortMessage,\n  retry,\n  translate,\n  RetryConfig,\n} from \"@azure/core-amqp\";\nimport {\n  EventContext,\n  Receiver as Link,\n  ReceiverOptions as RheaReceiverOptions,\n  Source,\n  types,\n} from \"rhea-promise\";\nimport { EventDataInternal, ReceivedEventData, fromRheaMessage } from \"./eventData\";\nimport { EventPosition, getEventPositionFilter } from \"./eventPosition\";\nimport {\n  createLogPrefix,\n  createSimpleLogger,\n  logErrorStackTrace,\n  logObj,\n  logger as azureLogger,\n  SimpleLogger,\n} from \"./logger\";\nimport { ConnectionContext } from \"./connectionContext\";\nimport { EventHubConsumerOptions } from \"./models/private\";\nimport { getRetryAttemptTimeoutInMs } from \"./util/retries\";\nimport { createAbortablePromise } from \"@azure/core-util\";\nimport { TimerLoop } from \"./util/timerLoop\";\nimport { getRandomName } from \"./util/utils\";\nimport { withAuth } from \"./withAuth\";\n\ntype Writable<T> = {\n  -readonly [P in keyof T]: T[P];\n};\n/** @internal */\nexport type WritableReceiver = Writable<PartitionReceiver>;\n\nconst abortLogMessage = \"operation has been cancelled by the user\";\n/** The time to wait in ms before attempting to read from the queue */\nconst qReadIntervalInMs = 20;\n\n/**\n * A set of information about the last enqueued event of a partition, as observed by the consumer as\n * events are received from the Event Hubs service\n */\nexport interface LastEnqueuedEventProperties {\n  /**\n   * The sequence number of the event that was last enqueued into the Event Hub partition from which\n   * this event was received.\n   */\n  sequenceNumber?: number;\n  /**\n   * The date and time, in UTC, that the last event was enqueued into the Event Hub partition from\n   * which this event was received.\n   */\n  enqueuedOn?: Date;\n  /**\n   * The offset of the event that was last enqueued into the Event Hub partition from which\n   * this event was received.\n   */\n  offset?: string;\n  /**\n   * The date and time, in UTC, that the last event was retrieved from the Event Hub partition.\n   */\n  retrievedOn?: Date;\n}\n\n/** @internal */\nexport interface PartitionReceiver {\n  readonly checkpoint: number;\n  readonly lastEnqueuedEventProperties: LastEnqueuedEventProperties;\n  readonly isClosed: boolean;\n  readonly close: () => Promise<void>;\n  readonly abort: () => Promise<void>;\n  readonly isOpen: () => boolean;\n  readonly receiveBatch: (\n    maxMessageCount: number,\n    maxWaitTimeInSeconds?: number,\n    abortSignal?: AbortSignalLike\n  ) => Promise<ReceivedEventData[]>;\n  /** Needed for tests only */\n  readonly _onError?: (error: MessagingError | Error) => void;\n  readonly connect: (options: ConnectOptions) => Promise<void>;\n}\n\ninterface ConnectOptions {\n  abortSignal: AbortSignalLike | undefined;\n  timeoutInMs: number;\n}\n\ninterface ReceiverState {\n  link?: Link;\n  authLoop?: TimerLoop;\n  isConnecting: boolean;\n}\n\n/** @internal */\nexport function createReceiver(\n  ctx: ConnectionContext,\n  consumerGroup: string,\n  partitionId: string,\n  eventPosition: EventPosition,\n  options: EventHubConsumerOptions = {}\n): PartitionReceiver {\n  const address = ctx.config.getReceiverAddress(partitionId, consumerGroup);\n  const name = getRandomName(address);\n  const audience = ctx.config.getReceiverAudience(partitionId, consumerGroup);\n  const logPrefix = createLogPrefix(ctx.connectionId, \"Receiver\", name);\n  const logger = createSimpleLogger(azureLogger, logPrefix);\n  const queue: ReceivedEventData[] = [];\n  const state: ReceiverState = {\n    isConnecting: false,\n  };\n\n  const obj: WritableReceiver = {\n    _onError: undefined,\n    checkpoint: -1,\n    lastEnqueuedEventProperties: {},\n    isClosed: false,\n    close: async () => {\n      clearHandlers(obj);\n      delete ctx.receivers[name];\n      logger.verbose(\"deleted the receiver from the client cache\");\n      state.authLoop?.stop();\n      return state.link\n        ?.close()\n        .catch((err) => {\n          logger.warning(`an error occurred while closing: ${err?.name}: ${err?.message}`);\n          logErrorStackTrace(err);\n          throw err;\n        })\n        .finally(() => {\n          obj.isClosed = true;\n          logger.verbose(\"is closed\");\n          state.link = undefined;\n          state.authLoop = undefined;\n        });\n    },\n    abort: () => {\n      obj._onError?.(new AbortError(StandardAbortMessage));\n      logger.info(abortLogMessage);\n      return obj.close();\n    },\n    isOpen: () => {\n      const isOpen = !!state.link?.isOpen();\n      logger.verbose(`is open? -> ${isOpen}`);\n      return isOpen;\n    },\n    async connect({ abortSignal, timeoutInMs }: ConnectOptions): Promise<void> {\n      if (state.isConnecting || obj.isOpen()) {\n        return;\n      }\n      state.isConnecting = true;\n      logger.verbose(\"is trying to connect\");\n      try {\n        await ctx.readyToOpenLink({ abortSignal });\n        state.authLoop = await withAuth(\n          () =>\n            setupLink(\n              ctx,\n              name,\n              address,\n              obj,\n              state,\n              queue,\n              eventPosition,\n              logger,\n              options,\n              abortSignal\n            ),\n          ctx,\n          audience,\n          timeoutInMs,\n          logger,\n          {\n            abortSignal,\n          }\n        );\n      } catch (err) {\n        state.isConnecting = false;\n        const error = translate(err);\n        logger.error(\n          `an error occurred while creating the receiver: ${error?.name}: ${error?.message}`\n        );\n        logErrorStackTrace(err);\n        throw error;\n      }\n    },\n    receiveBatch: (\n      maxMessageCount: number,\n      maxWaitTimeInSeconds: number = 60,\n      abortSignal?: AbortSignalLike\n    ) => {\n      const cleanupBeforeAbort = (): Promise<void> => {\n        logger.info(abortLogMessage);\n        return obj.close();\n      };\n      const retrieveEvents = (): Promise<ReceivedEventData[]> => {\n        const eventsToRetrieveCount = Math.max(maxMessageCount - queue.length, 0);\n        logger.verbose(\n          `already has ${queue.length} events and wants to receive ${eventsToRetrieveCount} more events`\n        );\n        if (abortSignal?.aborted) {\n          cleanupBeforeAbort();\n          return Promise.reject(new AbortError(StandardAbortMessage));\n        }\n        return obj.isClosed || ctx.wasConnectionCloseCalled\n          ? Promise.resolve(queue.splice(0))\n          : eventsToRetrieveCount === 0\n          ? Promise.resolve(queue.splice(0, maxMessageCount))\n          : new Promise<void>((resolve, reject) => {\n              obj._onError = reject;\n              obj // eslint-disable-line promise/catch-or-return\n                .connect({\n                  abortSignal,\n                  timeoutInMs: getRetryAttemptTimeoutInMs(options.retryOptions),\n                })\n                .then(() => {\n                  if (addCredits(state.link, eventsToRetrieveCount) > 0) {\n                    return logger.verbose(\n                      `setting the wait timer for ${maxWaitTimeInSeconds} seconds`\n                    );\n                  } else return;\n                })\n                .then(() =>\n                  waitForEvents(\n                    maxMessageCount,\n                    maxWaitTimeInSeconds * 1000,\n                    qReadIntervalInMs,\n                    queue,\n                    {\n                      abortSignal,\n                      cleanupBeforeAbort,\n                      receivedAfterWait: () =>\n                        logger.info(\n                          `${Math.min(\n                            maxMessageCount,\n                            queue.length\n                          )} messages received within ${maxWaitTimeInSeconds} seconds`\n                        ),\n                      receivedAlready: () =>\n                        logger.info(`${maxMessageCount} messages already received`),\n                      receivedNone: () =>\n                        logger.info(\n                          `no messages received when max wait time in seconds ${maxWaitTimeInSeconds} is over`\n                        ),\n                    }\n                  )\n                )\n                .catch(reject)\n                .then(resolve);\n            })\n              .then(() => queue.splice(0, maxMessageCount))\n              .finally(() => clearHandlers(obj));\n      };\n      return retry(\n        Object.defineProperties(\n          {\n            operation: retrieveEvents,\n            operationType: RetryOperationType.receiveMessage,\n            abortSignal: abortSignal,\n            retryOptions: options.retryOptions ?? {},\n          },\n          {\n            connectionId: {\n              enumerable: true,\n              get: () => ctx.connectionId,\n            },\n            connectionHost: {\n              enumerable: true,\n              get: () => ctx.config.host,\n            },\n          }\n        ) as RetryConfig<ReceivedEventData[]>\n      );\n    },\n  };\n  return obj;\n}\n\nfunction delay(\n  waitTimeInMs: number,\n  options?: {\n    abortSignal?: AbortSignalLike;\n    cleanupBeforeAbort?: () => void;\n    abortErrorMsg?: string;\n  }\n): Promise<void> {\n  let token: ReturnType<typeof setTimeout>;\n  return createAbortablePromise<void>((resolve) => {\n    token = setTimeout(resolve, waitTimeInMs);\n  }, options).finally(() => clearTimeout(token));\n}\n\n/**\n * @internal\n */\nexport function checkOnInterval(\n  waitTimeInMs: number,\n  check: () => boolean,\n  options?: {\n    abortSignal?: AbortSignalLike;\n    cleanupBeforeAbort?: () => void;\n    abortErrorMsg?: string;\n  }\n): Promise<void> {\n  let token: ReturnType<typeof setInterval>;\n  return createAbortablePromise<void>((resolve) => {\n    token = setInterval(() => {\n      if (check()) {\n        resolve();\n      }\n    }, waitTimeInMs);\n  }, options).finally(() => clearInterval(token));\n}\n\n/**\n * Returns a promise that will resolve when it is time to read from the queue\n * @param maxEventCount - The maximum number of events to receive.\n * @param maxWaitTimeInMs - The maximum time to wait in ms for the queue to contain any events.\n * @param readIntervalWaitTimeInMs - The time interval to wait in ms before checking the queue.\n * @param queue - The queue to read from.\n * @param options - The options bag.\n * @returns a promise that will resolve when it is time to read from the queue\n * @internal\n */\nexport function waitForEvents(\n  maxEventCount: number,\n  maxWaitTimeInMs: number,\n  readIntervalWaitTimeInMs: number,\n  queue: unknown[],\n  options: {\n    abortSignal?: AbortSignalLike;\n    cleanupBeforeAbort?: () => void;\n    receivedAfterWait?: () => void;\n    receivedAlready?: () => void;\n    receivedNone?: () => void;\n  } = {}\n): Promise<void> {\n  const {\n    abortSignal: clientAbortSignal,\n    cleanupBeforeAbort,\n    receivedNone,\n    receivedAfterWait,\n    receivedAlready,\n  } = options;\n\n  if (queue.length >= maxEventCount) {\n    return Promise.resolve().then(receivedAlready);\n  }\n\n  const aborter = new AbortController();\n  const abortListener = () => {\n    aborter.abort();\n  };\n  clientAbortSignal?.addEventListener(\"abort\", abortListener);\n\n  const updatedOptions = {\n    abortSignal: aborter.signal,\n    abortErrorMsg: StandardAbortMessage,\n    cleanupBeforeAbort: () => {\n      if (clientAbortSignal?.aborted) {\n        cleanupBeforeAbort?.();\n      }\n    },\n  };\n  return Promise.race([\n    checkOnInterval(readIntervalWaitTimeInMs, () => queue.length > 0, updatedOptions)\n      .then(() => delay(readIntervalWaitTimeInMs, updatedOptions))\n      .then(receivedAfterWait),\n    delay(maxWaitTimeInMs, updatedOptions).then(receivedNone),\n  ]).finally(() => {\n    aborter.abort();\n    clientAbortSignal?.removeEventListener(\"abort\", abortListener);\n  });\n}\n\nfunction convertAMQPMesage(data: EventDataInternal): ReceivedEventData {\n  const rawMessage = data.getRawAmqpMessage();\n  const receivedEventData: ReceivedEventData = {\n    body: data.body,\n    properties: data.properties,\n    offset: data.offset!,\n    sequenceNumber: data.sequenceNumber!,\n    enqueuedTimeUtc: data.enqueuedTimeUtc!,\n    partitionKey: data.partitionKey!,\n    systemProperties: data.systemProperties,\n    getRawAmqpMessage() {\n      return rawMessage;\n    },\n  };\n  if (data.correlationId != null) {\n    receivedEventData.correlationId = data.correlationId;\n  }\n  if (data.contentType != null) {\n    receivedEventData.contentType = data.contentType;\n  }\n  if (data.messageId != null) {\n    receivedEventData.messageId = data.messageId;\n  }\n  return receivedEventData;\n}\n\nfunction setEventProps(eventProps: LastEnqueuedEventProperties, data: EventDataInternal): void {\n  eventProps.sequenceNumber = data.lastSequenceNumber;\n  eventProps.enqueuedOn = data.lastEnqueuedTime;\n  eventProps.offset = data.lastEnqueuedOffset;\n  eventProps.retrievedOn = data.retrievalTime;\n}\n\nfunction addCredits(receiver: Link | undefined, eventsToRetrieveCount: number): number {\n  const creditsToAdd = eventsToRetrieveCount - (receiver?.credit ?? 0);\n  if (creditsToAdd > 0) {\n    receiver?.addCredit(creditsToAdd);\n  }\n  return creditsToAdd;\n}\n\nfunction clearHandlers(obj: WritableReceiver): void {\n  obj._onError = undefined;\n}\n\nfunction onMessage(\n  context: EventContext,\n  obj: WritableReceiver,\n  queue: ReceivedEventData[],\n  options: EventHubConsumerOptions\n): void {\n  if (!context.message) {\n    return;\n  }\n  const data = fromRheaMessage(context.message, !!options.skipParsingBodyAsJson);\n  const receivedEventData = convertAMQPMesage(data);\n  obj.checkpoint = receivedEventData.sequenceNumber;\n  if (options.trackLastEnqueuedEventProperties) {\n    setEventProps(obj.lastEnqueuedEventProperties, data);\n  }\n  queue.push(receivedEventData);\n}\n\nfunction onError(\n  context: EventContext,\n  obj: PartitionReceiver,\n  receiver: Link | undefined,\n  logger: SimpleLogger\n): void {\n  const rheaReceiver = receiver || context.receiver;\n  const amqpError = rheaReceiver?.error;\n  logger.verbose(`'receiver_error' event occurred: ${logObj(amqpError)}`);\n  if (obj._onError && amqpError) {\n    const error = translate(amqpError);\n    logErrorStackTrace(error);\n    obj._onError(error);\n  }\n}\n\nfunction onSessionError(context: EventContext, obj: PartitionReceiver, logger: SimpleLogger): void {\n  const sessionError = context.session?.error;\n  logger.verbose(`'session_error' event occurred: ${logObj(sessionError)}`);\n  if (obj._onError && sessionError) {\n    const error = translate(sessionError);\n    logErrorStackTrace(error);\n    obj._onError(error);\n  }\n}\n\nasync function onClose(\n  context: EventContext,\n  state: ReceiverState,\n  logger: SimpleLogger\n): Promise<void> {\n  const rheaReceiver = state.link || context.receiver;\n  logger.verbose(\n    `'receiver_close' event occurred. Value for isItselfClosed on the receiver is: '${rheaReceiver\n      ?.isItselfClosed()\n      .toString()}' Value for isConnecting on the session is: '${state.isConnecting}'`\n  );\n  if (rheaReceiver && !state.isConnecting) {\n    return rheaReceiver.close().catch((err) => {\n      logger.verbose(`error when closing after 'receiver_close' event: ${logObj(err)}`);\n    });\n  }\n}\n\nasync function onSessionClose(\n  context: EventContext,\n  state: ReceiverState,\n  logger: SimpleLogger\n): Promise<void> {\n  const rheaReceiver = state.link || context.receiver;\n  logger.verbose(\n    `'session_close' event occurred. Value for isSessionItselfClosed on the session is: '${rheaReceiver\n      ?.isSessionItselfClosed()\n      .toString()}' Value for isConnecting on the session is: '${state.isConnecting}'`\n  );\n  if (rheaReceiver && !state.isConnecting) {\n    return rheaReceiver.close().catch((err) => {\n      logger.verbose(`error when closing after 'session_close' event: ${logObj(err)}`);\n    });\n  }\n}\n\nfunction createRheaOptions(\n  name: string,\n  address: string,\n  obj: PartitionReceiver,\n  state: ReceiverState,\n  queue: ReceivedEventData[],\n  eventPosition: EventPosition,\n  logger: SimpleLogger,\n  options: EventHubConsumerOptions\n): RheaReceiverOptions {\n  const rheaOptions: RheaReceiverOptions & { source: Source } = {\n    name,\n    autoaccept: true,\n    source: {\n      address,\n    },\n    credit_window: 0,\n    onClose: (context) => onClose(context, state, logger),\n    onSessionClose: (context) => onSessionClose(context, state, logger),\n    onError: (context) => onError(context, obj, state.link, logger),\n    onMessage: (context) => onMessage(context, obj, queue, options),\n    onSessionError: (context) => onSessionError(context, obj, logger),\n  };\n  const ownerLevel = options.ownerLevel;\n  if (typeof ownerLevel === \"number\") {\n    rheaOptions.properties = {\n      [Constants.attachEpoch]: types.wrap_long(ownerLevel),\n    };\n  }\n  if (options.trackLastEnqueuedEventProperties) {\n    rheaOptions.desired_capabilities = Constants.enableReceiverRuntimeMetricName;\n  }\n  const filterClause = getEventPositionFilter(\n    obj.checkpoint > -1 ? { sequenceNumber: obj.checkpoint } : eventPosition\n  );\n  rheaOptions.source.filter = {\n    \"apache.org:selector-filter:string\": types.wrap_described(filterClause, 0x468c00000004),\n  };\n  return rheaOptions;\n}\n\nasync function setupLink(\n  ctx: ConnectionContext,\n  name: string,\n  address: string,\n  obj: PartitionReceiver,\n  state: ReceiverState,\n  queue: ReceivedEventData[],\n  eventPosition: EventPosition,\n  logger: SimpleLogger,\n  options: EventHubConsumerOptions,\n  abortSignal?: AbortSignalLike\n): Promise<void> {\n  const rheaOptions = createRheaOptions(\n    name,\n    address,\n    obj,\n    state,\n    queue,\n    eventPosition,\n    logger,\n    options\n  );\n  logger.verbose(`trying to be created with options ${logObj(rheaOptions)}`);\n  state.link = await ctx.connection.createReceiver({\n    ...rheaOptions,\n    abortSignal,\n  });\n  state.isConnecting = false;\n  logger.verbose(\"is created successfully\");\n  ctx.receivers[name] = obj;\n}\n"]}